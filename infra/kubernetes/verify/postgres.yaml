apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-init
  namespace: k1s0-system
data:
  01-create-databases.sql: |
    CREATE DATABASE auth_db;
    CREATE DATABASE config_db;
    CREATE DATABASE k1s0_system;
  02-auth-schema.sql: |
    \c auth_db;

    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    CREATE SCHEMA IF NOT EXISTS auth;

    CREATE OR REPLACE FUNCTION auth.update_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TABLE IF NOT EXISTS auth.users (
        id            UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
        keycloak_sub  VARCHAR(255) UNIQUE NOT NULL,
        username      VARCHAR(255) UNIQUE NOT NULL,
        email         VARCHAR(255) UNIQUE NOT NULL,
        display_name  VARCHAR(255) NOT NULL,
        status        VARCHAR(50)  NOT NULL DEFAULT 'active',
        created_at    TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        updated_at    TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        CONSTRAINT chk_users_status CHECK (status IN ('active', 'inactive', 'suspended'))
    );
    CREATE INDEX IF NOT EXISTS idx_users_keycloak_sub ON auth.users (keycloak_sub);
    CREATE INDEX IF NOT EXISTS idx_users_status ON auth.users (status);
    CREATE TRIGGER trigger_users_update_updated_at
        BEFORE UPDATE ON auth.users FOR EACH ROW
        EXECUTE FUNCTION auth.update_updated_at();

    CREATE TABLE IF NOT EXISTS auth.roles (
        id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
        name        VARCHAR(100) UNIQUE NOT NULL,
        description TEXT,
        tier        VARCHAR(20)  NOT NULL,
        created_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        CONSTRAINT chk_roles_tier CHECK (tier IN ('system', 'business', 'service'))
    );
    CREATE INDEX IF NOT EXISTS idx_roles_tier ON auth.roles (tier);

    CREATE TABLE IF NOT EXISTS auth.permissions (
        id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
        resource    VARCHAR(255) NOT NULL,
        action      VARCHAR(50)  NOT NULL,
        description TEXT,
        CONSTRAINT uq_permissions_resource_action UNIQUE (resource, action),
        CONSTRAINT chk_permissions_action CHECK (action IN ('read', 'write', 'delete', 'admin'))
    );

    CREATE TABLE IF NOT EXISTS auth.user_roles (
        id          UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
        user_id     UUID        NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
        role_id     UUID        NOT NULL REFERENCES auth.roles(id) ON DELETE CASCADE,
        assigned_by UUID        REFERENCES auth.users(id) ON DELETE SET NULL,
        assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        CONSTRAINT uq_user_roles_user_role UNIQUE (user_id, role_id)
    );
    CREATE TABLE IF NOT EXISTS auth.role_permissions (
        id            UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
        role_id       UUID        NOT NULL REFERENCES auth.roles(id) ON DELETE CASCADE,
        permission_id UUID        NOT NULL REFERENCES auth.permissions(id) ON DELETE CASCADE,
        granted_at    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        CONSTRAINT uq_role_permissions_role_permission UNIQUE (role_id, permission_id)
    );

    CREATE TABLE IF NOT EXISTS auth.audit_logs (
        id          UUID         NOT NULL DEFAULT gen_random_uuid(),
        user_id     UUID         REFERENCES auth.users(id) ON DELETE SET NULL,
        event_type  VARCHAR(100) NOT NULL,
        action      VARCHAR(100) NOT NULL,
        resource    VARCHAR(255),
        resource_id VARCHAR(255),
        result      VARCHAR(50)  NOT NULL DEFAULT 'SUCCESS',
        detail      JSONB,
        ip_address  INET,
        user_agent  TEXT,
        trace_id    VARCHAR(64),
        created_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        PRIMARY KEY (id, created_at)
    ) PARTITION BY RANGE (created_at);
    CREATE TABLE IF NOT EXISTS auth.audit_logs_2026_01 PARTITION OF auth.audit_logs
        FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
    CREATE TABLE IF NOT EXISTS auth.audit_logs_2026_02 PARTITION OF auth.audit_logs
        FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');
    CREATE TABLE IF NOT EXISTS auth.audit_logs_2026_03 PARTITION OF auth.audit_logs
        FOR VALUES FROM ('2026-03-01') TO ('2026-04-01');
    CREATE TABLE IF NOT EXISTS auth.audit_logs_default PARTITION OF auth.audit_logs DEFAULT;

    CREATE TABLE IF NOT EXISTS auth.api_keys (
        id           UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
        name         VARCHAR(255) NOT NULL,
        key_hash     VARCHAR(255) UNIQUE NOT NULL,
        key_prefix   VARCHAR(10)  NOT NULL,
        service_name VARCHAR(255) NOT NULL,
        tier         VARCHAR(20)  NOT NULL,
        permissions  JSONB        NOT NULL DEFAULT '[]',
        expires_at   TIMESTAMPTZ,
        last_used_at TIMESTAMPTZ,
        is_active    BOOLEAN      NOT NULL DEFAULT true,
        created_by   UUID         REFERENCES auth.users(id) ON DELETE SET NULL,
        created_at   TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        updated_at   TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        CONSTRAINT chk_api_keys_tier CHECK (tier IN ('system', 'business', 'service'))
    );
    CREATE TRIGGER trigger_api_keys_update_updated_at
        BEFORE UPDATE ON auth.api_keys FOR EACH ROW
        EXECUTE FUNCTION auth.update_updated_at();

    INSERT INTO auth.roles (name, description, tier) VALUES
        ('sys_admin',    'システム全体の管理者', 'system'),
        ('sys_operator', 'システム運用担当',     'system'),
        ('sys_auditor',  '監査担当',             'system')
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO auth.permissions (resource, action, description) VALUES
        ('users',      'read',   'ユーザー情報の閲覧'),
        ('users',      'write',  'ユーザー情報の作成・更新'),
        ('users',      'delete', 'ユーザーの削除'),
        ('users',      'admin',  'ユーザー管理の全権限'),
        ('audit_logs', 'read',   '監査ログの閲覧'),
        ('monitoring', 'read',   '監視データの閲覧'),
        ('monitoring', 'write',  '監視設定の作成・更新')
    ON CONFLICT (resource, action) DO NOTHING;
  03-config-schema.sql: |
    \c config_db;

    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    CREATE SCHEMA IF NOT EXISTS config;

    CREATE OR REPLACE FUNCTION config.update_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TABLE IF NOT EXISTS config.config_entries (
        id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
        namespace   VARCHAR(255) NOT NULL,
        key         VARCHAR(255) NOT NULL,
        value_json  JSONB        NOT NULL DEFAULT '{}',
        version     INT          NOT NULL DEFAULT 1,
        description TEXT,
        created_by  VARCHAR(255) NOT NULL,
        updated_by  VARCHAR(255) NOT NULL,
        created_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        updated_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        CONSTRAINT uq_config_entries_namespace_key UNIQUE (namespace, key)
    );
    CREATE INDEX IF NOT EXISTS idx_config_entries_namespace ON config.config_entries (namespace);
    CREATE TRIGGER trigger_config_entries_update_updated_at
        BEFORE UPDATE ON config.config_entries FOR EACH ROW
        EXECUTE FUNCTION config.update_updated_at();

    CREATE TABLE IF NOT EXISTS config.config_change_logs (
        id               UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
        config_entry_id  UUID         REFERENCES config.config_entries(id) ON DELETE SET NULL,
        namespace        VARCHAR(255) NOT NULL,
        key              VARCHAR(255) NOT NULL,
        change_type      VARCHAR(20)  NOT NULL,
        old_value_json   JSONB,
        new_value_json   JSONB,
        changed_by       VARCHAR(255) NOT NULL,
        trace_id         VARCHAR(64),
        created_at       TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
        CONSTRAINT chk_config_change_logs_change_type
            CHECK (change_type IN ('CREATED', 'UPDATED', 'DELETED'))
    );

    INSERT INTO config.config_entries (namespace, key, value_json, description, created_by, updated_by) VALUES
        ('system.auth.database', 'host',     '"localhost"', 'DB ホスト名',   'migration', 'migration'),
        ('system.auth.database', 'port',     '5432',        'DB ポート番号', 'migration', 'migration'),
        ('system.auth.database', 'ssl_mode', '"disable"',   'SSL モード',    'migration', 'migration')
    ON CONFLICT (namespace, key) DO NOTHING;
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: k1s0-system
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:17
          env:
            - name: POSTGRES_USER
              value: "dev"
            - name: POSTGRES_PASSWORD
              value: "dev"
            - name: POSTGRES_DB
              value: "dev"
          ports:
            - containerPort: 5432
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "dev"]
            initialDelaySeconds: 5
            periodSeconds: 5
          volumeMounts:
            - name: init-scripts
              mountPath: /docker-entrypoint-initdb.d
      volumes:
        - name: init-scripts
          configMap:
            name: postgres-init
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: k1s0-system
spec:
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432
