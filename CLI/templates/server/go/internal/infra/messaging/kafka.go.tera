{% if has_kafka %}
package messaging

import (
	"context"
	"log/slog"

	"github.com/segmentio/kafka-go"

	"{{ go_module }}/internal/infra/config"
)

// Producer は Kafka プロデューサー。
type Producer struct {
	writer *kafka.Writer
}

// NewProducer はプロデューサーを生成する。
// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
func NewProducer(cfg config.KafkaConfig) *Producer {
	w := &kafka.Writer{
		Addr:     kafka.TCP(cfg.Brokers...),
		Balancer: &kafka.LeastBytes{},
	}
	return &Producer{writer: w}
}

// Publish はメッセージを送信する。
func (p *Producer) Publish(ctx context.Context, topic string, key, value []byte) error {
	return p.writer.WriteMessages(ctx, kafka.Message{
		Topic: topic,
		Key:   key,
		Value: value,
	})
}

// Close はプロデューサーを閉じる。
func (p *Producer) Close() {
	if err := p.writer.Close(); err != nil {
		slog.Error("failed to close kafka producer", "error", err)
	}
}

// Consumer は Kafka コンシューマー。
type Consumer struct {
	reader *kafka.Reader
}

// NewConsumer はコンシューマーを生成する。
// コンシューマーグループ命名規則: {service-name}.{purpose}
func NewConsumer(cfg config.KafkaConfig, topic, groupID string) *Consumer {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  cfg.Brokers,
		Topic:    topic,
		GroupID:  groupID,
		MinBytes: 10e3,
		MaxBytes: 10e6,
	})
	return &Consumer{reader: r}
}

// Consume はメッセージを受信する。
func (c *Consumer) Consume(ctx context.Context, handler func(kafka.Message) error) error {
	for {
		msg, err := c.reader.ReadMessage(ctx)
		if err != nil {
			return err
		}
		if err := handler(msg); err != nil {
			slog.Error("failed to handle message", "topic", msg.Topic, "error", err)
		}
	}
}

// Close はコンシューマーを閉じる。
func (c *Consumer) Close() {
	if err := c.reader.Close(); err != nil {
		slog.Error("failed to close kafka consumer", "error", err)
	}
}
{% endif %}
