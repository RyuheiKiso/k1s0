package main

import (
	"context"
	"log/slog"
{% if api_styles is containing("grpc") %}
	"net"
{% endif %}
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
{% if api_styles is containing("grpc") %}
	"google.golang.org/grpc"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"

	pb "{{ go_module }}/api/proto/gen"
{% endif %}

	"{{ go_module }}/internal/adapter/handler"
	"{{ go_module }}/internal/infra/config"
{% if has_database %}
	"{{ go_module }}/internal/infra/persistence"
{% endif %}
{% if has_kafka %}
	"{{ go_module }}/internal/infra/messaging"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

func main() {
	// --- Config ---
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		slog.Error("failed to load config", "error", err)
		os.Exit(1)
	}

	// --- Logger ---
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))
	slog.SetDefault(logger)

{% if has_database %}
	// --- Database ---
	db, err := persistence.NewDB(cfg.Database)
	if err != nil {
		slog.Error("failed to connect database", "error", err)
		os.Exit(1)
	}
	defer db.Close()
{% endif %}

{% if has_kafka %}
	// --- Kafka ---
	producer := messaging.NewProducer(cfg.Kafka)
	defer producer.Close()
{% endif %}

	// --- DI: Repository → UseCase → Handler ---
{% if has_database %}
	repo := persistence.NewRepository(db)
{% endif %}
	uc := usecase.New{{ service_name_pascal }}UseCase(
{% if has_database %}
		repo,
{% endif %}
	)
	h := handler.NewHandler(uc)

	// --- Router ---
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(otelgin.Middleware("{{ service_name }}"))

	// ヘルスチェック
	r.GET("/healthz", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})
	r.GET("/readyz", func(c *gin.Context) {
{% if has_database %}
		if err := db.PingContext(c.Request.Context()); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"status": "not ready", "error": err.Error()})
			return
		}
{% endif %}
		c.JSON(http.StatusOK, gin.H{"status": "ready"})
	})

	// API ルート登録
	h.RegisterRoutes(r)

{% if api_styles is containing("grpc") %}
	// --- gRPC Server ---
	grpcServer := grpc.NewServer()

	// gRPC Health Service
	healthServer := health.NewServer()
	healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)
	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)

	// gRPC ハンドラ登録
	grpcHandler := handler.NewGRPCHandler(uc)
	pb.Register{{ service_name_pascal }}ServiceServer(grpcServer, grpcHandler)

	go func() {
		lis, err := net.Listen("tcp", ":"+cfg.Server.GRPCPort)
		if err != nil {
			slog.Error("failed to listen gRPC", "error", err)
			os.Exit(1)
		}
		slog.Info("gRPC server starting", "port", cfg.Server.GRPCPort)
		if err := grpcServer.Serve(lis); err != nil {
			slog.Error("gRPC server failed", "error", err)
			os.Exit(1)
		}
	}()
{% endif %}

	// --- HTTP Server ---
	srv := &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: r,
	}

	go func() {
		slog.Info("server starting", "port", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("server failed", "error", err)
			os.Exit(1)
		}
	}()

	// --- Graceful Shutdown ---
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	slog.Info("shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
{% if api_styles is containing("grpc") %}
	grpcServer.GracefulStop()
	slog.Info("gRPC server exited")
{% endif %}
	if err := srv.Shutdown(ctx); err != nil {
		slog.Error("server forced to shutdown", "error", err)
	}
	slog.Info("server exited")
}
