use std::path::PathBuf;

pub fn generate(name: &str) -> Vec<(PathBuf, String)> {
    vec![
        (PathBuf::from("Cargo.toml"), cargo_toml(name)),
        (PathBuf::from("src/main.rs"), main_rs(name)),
        (PathBuf::from("src/lib.rs"), lib_rs()),
        (PathBuf::from("tests/health_check.rs"), health_check_test(name)),
        (PathBuf::from("README.md"), readme(name)),
        (PathBuf::from(".github/workflows/ci.yml"), ci_yml()),
        (PathBuf::from("Dockerfile"), dockerfile(name)),
        (PathBuf::from(".dockerignore"), dockerignore()),
    ]
}

pub fn dockerfile(name: &str) -> String {
    format!(
        r#"FROM rust:1.83-alpine AS build
RUN apk add --no-cache musl-dev
WORKDIR /app
COPY . .
RUN cargo build --release

FROM alpine:3.20
COPY --from=build /app/target/release/{name} /usr/local/bin/app
EXPOSE 3000
CMD ["app"]
"#
    )
}

pub fn dockerignore() -> String {
    r#"target
.git
.github
.env
"#
    .to_string()
}

fn cargo_toml(name: &str) -> String {
    format!(
        r#"[package]
name = "{name}"
version = "0.1.0"
edition = "2024"

[dependencies]
axum = "0.8"
tokio = {{ version = "1", features = ["full"] }}
serde = {{ version = "1", features = ["derive"] }}
serde_json = "1"

[dev-dependencies]
reqwest = {{ version = "0.12", features = ["json"] }}
tokio = {{ version = "1", features = ["full"] }}
"#
    )
}

fn main_rs(name: &str) -> String {
    let crate_name = name.replace('-', "_");
    format!(
        r#"use {crate_name}::create_router;

#[tokio::main]
async fn main() {{
    let app = create_router();

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    println!("Server running on http://0.0.0.0:3000");
    axum::serve(listener, app).await.unwrap();
}}
"#
    )
}

fn lib_rs() -> String {
    r#"use axum::{Router, routing::get};
use serde_json::json;

pub fn create_router() -> Router {
    Router::new()
        .route("/health", get(health))
}

async fn health() -> axum::Json<serde_json::Value> {
    axum::Json(json!({ "status": "ok" }))
}
"#
    .to_string()
}

fn health_check_test(name: &str) -> String {
    let crate_name = name.replace('-', "_");
    format!(
        r#"use {crate_name}::create_router;
use axum::body::Body;
use axum::http::{{Request, StatusCode}};
use tower::ServiceExt;

#[tokio::test]
async fn health_check_works() {{
    let app = create_router();

    let response = app
        .oneshot(
            Request::builder()
                .uri("/health")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}}
"#
    )
}

fn readme(name: &str) -> String {
    format!(
        r#"# {name}

A Rust (axum) backend project generated by k1s0.

## Getting Started

```bash
cargo run
```

The server will start on `http://0.0.0.0:3000`.

## Testing

```bash
cargo test
```

## Endpoints

- `GET /health` - Health check endpoint
"#
    )
}

fn ci_yml() -> String {
    r#"name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo test
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generates_expected_files() {
        let files = generate("my-rust-svc");
        let paths: Vec<PathBuf> = files.iter().map(|(p, _)| p.clone()).collect();

        assert!(paths.contains(&PathBuf::from("Cargo.toml")));
        assert!(paths.contains(&PathBuf::from("src/main.rs")));
        assert!(paths.contains(&PathBuf::from("src/lib.rs")));
        assert!(paths.contains(&PathBuf::from("tests/health_check.rs")));
        assert!(paths.contains(&PathBuf::from("README.md")));
        assert!(paths.contains(&PathBuf::from(".github/workflows/ci.yml")));
        assert!(paths.contains(&PathBuf::from("Dockerfile")));
        assert!(paths.contains(&PathBuf::from(".dockerignore")));
    }

    #[test]
    fn test_dockerfile_uses_rust_alpine() {
        let content = dockerfile("my-rust-svc");
        assert!(content.contains("rust:1.83-alpine"));
        assert!(content.contains("alpine:3.20"));
        assert!(content.contains("cargo build --release"));
        assert!(content.contains("my-rust-svc"));
        assert!(content.contains("EXPOSE 3000"));
    }

    #[test]
    fn test_dockerignore_excludes_target() {
        let content = dockerignore();
        assert!(content.contains("target"));
    }

    #[test]
    fn test_cargo_toml_contains_name_and_deps() {
        let files = generate("my-rust-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("Cargo.toml")).unwrap();
        assert!(content.contains("name = \"my-rust-svc\""));
        assert!(content.contains("axum"));
        assert!(content.contains("tokio"));
    }

    #[test]
    fn test_lib_rs_has_router() {
        let files = generate("my-rust-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("src/lib.rs")).unwrap();
        assert!(content.contains("create_router"));
        assert!(content.contains("/health"));
    }

    #[test]
    fn test_health_check_test_exists() {
        let files = generate("my-rust-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("tests/health_check.rs")).unwrap();
        assert!(content.contains("health_check_works"));
    }

    #[test]
    fn test_ci_yml_runs_cargo_test() {
        let files = generate("my-rust-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from(".github/workflows/ci.yml")).unwrap();
        assert!(content.contains("cargo test"));
    }
}
