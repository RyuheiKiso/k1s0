use std::path::PathBuf;

pub fn generate(name: &str) -> Vec<(PathBuf, String)> {
    vec![
        (PathBuf::from("go.mod"), go_mod(name)),
        (PathBuf::from("main.go"), main_go()),
        (PathBuf::from("main_test.go"), main_test_go()),
        (PathBuf::from("README.md"), readme(name)),
        (PathBuf::from(".github/workflows/ci.yml"), ci_yml()),
    ]
}

fn go_mod(name: &str) -> String {
    format!(
        r#"module {name}

go 1.22

require github.com/gin-gonic/gin v1.10.0
"#
    )
}

fn main_go() -> String {
    r#"package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func setupRouter() *gin.Engine {
	r := gin.Default()

	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status": "ok",
		})
	})

	return r
}

func main() {
	r := setupRouter()
	r.Run(":8080")
}
"#
    .to_string()
}

fn main_test_go() -> String {
    r#"package main

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestHealthEndpoint(t *testing.T) {
	router := setupRouter()

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/health", nil)
	router.ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", w.Code)
	}

	expected := `{"status":"ok"}`
	if w.Body.String() != expected {
		t.Errorf("Expected body %s, got %s", expected, w.Body.String())
	}
}
"#
    .to_string()
}

fn readme(name: &str) -> String {
    format!(
        r#"# {name}

A Go (gin) backend project generated by k1s0.

## Getting Started

```bash
go mod tidy
go run .
```

The server will start on `http://localhost:8080`.

## Testing

```bash
go test ./...
```

## Endpoints

- `GET /health` - Health check endpoint
"#
    )
}

fn ci_yml() -> String {
    r#"name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      - run: go test ./...
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generates_expected_files() {
        let files = generate("my-go-svc");
        let paths: Vec<PathBuf> = files.iter().map(|(p, _)| p.clone()).collect();

        assert!(paths.contains(&PathBuf::from("go.mod")));
        assert!(paths.contains(&PathBuf::from("main.go")));
        assert!(paths.contains(&PathBuf::from("main_test.go")));
        assert!(paths.contains(&PathBuf::from("README.md")));
        assert!(paths.contains(&PathBuf::from(".github/workflows/ci.yml")));
    }

    #[test]
    fn test_go_mod_contains_module_name() {
        let files = generate("my-go-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("go.mod")).unwrap();
        assert!(content.contains("module my-go-svc"));
        assert!(content.contains("go 1.22"));
    }

    #[test]
    fn test_main_go_has_health_endpoint() {
        let files = generate("my-go-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("main.go")).unwrap();
        assert!(content.contains("setupRouter"));
        assert!(content.contains("/health"));
    }

    #[test]
    fn test_main_test_go_has_test() {
        let files = generate("my-go-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from("main_test.go")).unwrap();
        assert!(content.contains("TestHealthEndpoint"));
        assert!(content.contains("httptest"));
    }

    #[test]
    fn test_ci_yml_runs_go_test() {
        let files = generate("my-go-svc");
        let (_, content) = files.iter().find(|(p, _)| p == &PathBuf::from(".github/workflows/ci.yml")).unwrap();
        assert!(content.contains("go test ./..."));
    }
}
