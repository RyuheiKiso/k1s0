{% if has_database %}
use sqlx::{{ database_type }}::{{ database_type | title }}Pool;
use sqlx::{{ database_type }}::{{ database_type | title }}PoolOptions;
use async_trait::async_trait;
use std::time::Duration;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::domain::repository::{{ service_name_pascal }}Repository;
use crate::infra::config::DatabaseConfig;

pub type DbPool = {{ database_type | title }}Pool;

pub async fn create_pool(cfg: &DatabaseConfig) -> anyhow::Result<DbPool> {
    let pool = {{ database_type | title }}PoolOptions::new()
        .max_connections(cfg.pool.max_open)
        .idle_timeout(Duration::from_secs(cfg.pool.max_lifetime_sec))
        .connect(&cfg.connection_string())
        .await?;
    Ok(pool)
}

pub struct Repository {
    pool: DbPool,
}

impl Repository {
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl {{ service_name_pascal }}Repository for Repository {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
        let entity = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        Ok(entity)
    }

    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
        let entities = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;
        Ok(entities)
    }

    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "INSERT INTO examples (id, name, description, status) VALUES ($1, $2, $3, $4)"
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "UPDATE examples SET name = $1, description = $2, status = $3 WHERE id = $4"
        )
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .bind(&entity.id)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn delete(&self, id: &str) -> anyhow::Result<()> {
        sqlx::query("DELETE FROM examples WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}
{% endif %}
