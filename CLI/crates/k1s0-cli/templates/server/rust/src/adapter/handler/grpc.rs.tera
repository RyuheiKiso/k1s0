{% if api_styles is containing("grpc") %}
use tonic::{Request, Response, Status};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

pub mod proto {
    tonic::include_proto!("{{ service_name_snake }}.v1");
}

use proto::{{ service_name_snake }}_service_server::{{ service_name_pascal }}Service;
use proto::{
    Get{{ service_name_pascal }}Request, Get{{ service_name_pascal }}Response,
    List{{ service_name_pascal }}Request, List{{ service_name_pascal }}Response,
    Create{{ service_name_pascal }}Request, Create{{ service_name_pascal }}Response,
};

pub struct {{ service_name_pascal }}GrpcService {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl {{ service_name_pascal }}GrpcService {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }
}

#[tonic::async_trait]
impl {{ service_name_pascal }}Service for {{ service_name_pascal }}GrpcService {
    async fn get_{{ service_name_snake }}(
        &self,
        request: Request<Get{{ service_name_pascal }}Request>,
    ) -> Result<Response<Get{{ service_name_pascal }}Response>, Status> {
        let id = request.into_inner().id;
        match self.uc.get_by_id(&id).await {
            Ok(Some(entity)) => Ok(Response::new(Get{{ service_name_pascal }}Response {
                id: entity.id,
                name: entity.name,
                description: entity.description.unwrap_or_default(),
                status: entity.status,
                created_at: entity.created_at,
                updated_at: entity.updated_at,
            })),
            Ok(None) => Err(Status::not_found(format!("resource not found: {}", id))),
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn list_{{ service_name_snake }}(
        &self,
        _request: Request<List{{ service_name_pascal }}Request>,
    ) -> Result<Response<List{{ service_name_pascal }}Response>, Status> {
        match self.uc.get_all().await {
            Ok(entities) => {
                let items = entities.into_iter().map(|e| Get{{ service_name_pascal }}Response {
                    id: e.id,
                    name: e.name,
                    description: e.description.unwrap_or_default(),
                    status: e.status,
                    created_at: e.created_at,
                    updated_at: e.updated_at,
                }).collect();
                Ok(Response::new(List{{ service_name_pascal }}Response { items }))
            }
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn create_{{ service_name_snake }}(
        &self,
        request: Request<Create{{ service_name_pascal }}Request>,
    ) -> Result<Response<Create{{ service_name_pascal }}Response>, Status> {
        let req = request.into_inner();
        let entity = crate::domain::model::{{ service_name_pascal }}Entity {
            id: uuid::Uuid::new_v4().to_string(),
            name: req.name,
            description: if req.description.is_empty() { None } else { Some(req.description) },
            status: "active".to_string(),
            created_at: String::new(),
            updated_at: String::new(),
        };
        match self.uc.create(&entity).await {
            Ok(()) => Ok(Response::new(Create{{ service_name_pascal }}Response {
                id: entity.id,
            })),
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }
}
{% endif %}
