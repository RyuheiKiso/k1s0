# テンプレート仕様 — レンダリングテスト

## 概要

本ドキュメントは、k1s0 CLI のテンプレートレンダリング機能に対するテスト仕様を定義する。テンプレートから生成されたコードが仕様書（テンプレート仕様-サーバー.md 等）と一致し、Tera 構文の残留がないことを体系的に検証する。

### 目的

- テンプレートレンダリングの品質保証
- 仕様書とテンプレート実装の一致性検証
- 条件分岐（API 方式・DB・Kafka・Redis）の正確性保証
- テンプレート変数（ケース変換含む）の置換精度保証

### テスト2層構成

| 層 | 技術 | 対象 | 実行場所 |
|---|---|---|---|
| Rust 統合テスト | `cargo test` | テンプレートエンジンのレンダリング結果検証 | `CLI/tests/` |
| E2E テスト | Python + pytest | テンプレートファイルの存在・内容準拠検証 | `e2e/tests/docs_compliance/` |

Rust 統合テストは `TemplateEngine::render_to_dir()` を呼び出し、生成されたファイルの内容を直接検証する。E2E テストは `.tera` テンプレートファイル自体の存在と仕様書コードブロックとの一致を検証する。

---

## テスト対象マトリクス

| kind | language | オプション | Rust テスト | E2E テスト |
|------|----------|-----------|-----------|----------|
| server | go | REST/gRPC/GraphQL/DB/Kafka/Redis | `server_template_rendering.rs` | `test_template_content_server.py` |
| server | rust | REST/gRPC/GraphQL/DB/Kafka/Redis | `server_template_rendering.rs` | `test_template_content_server.py` |
| client | react | — | 新規追加 | `test_template_content_client.py` |
| client | flutter | — | 新規追加 | `test_template_content_client.py` |
| library | go/rust/ts/dart | — | 新規追加 | `test_template_content_library.py` |
| database | postgresql/mysql/sqlite | — | 新規追加 | `test_template_content_database.py` |

---

## Rust 統合テスト仕様

テスト配置: `CLI/tests/` 配下。

### ヘルパー関数

`server_template_rendering.rs` で確立されたパターンに準拠する。

#### `template_dir()` — テンプレートディレクトリ取得

```rust
fn template_dir() -> std::path::PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("templates")
}
```

`CARGO_MANIFEST_DIR` を用いて `CLI/templates/` への絶対パスを取得する。テスト実行時のカレントディレクトリに依存しない。

#### `render_server()` — サーバーテンプレートのレンダリング

```rust
fn render_server(
    lang: &str,
    api_style: &str,
    has_database: bool,
    database_type: &str,
    has_kafka: bool,
    has_redis: bool,
) -> (TempDir, Vec<String>)
```

- `TemplateContextBuilder::new(service_name, tier, lang, kind)` でコンテキストを構築
- `TempDir` に出力し、生成されたファイルの相対パス一覧を返す
- パス区切りを `/` に正規化（Windows 互換）

テスト用デフォルト値:
- `service_name`: `"order-api"`
- `tier`: `"service"`

#### `read_output()` — 生成ファイルの読み取り

```rust
fn read_output(tmp: &TempDir, path: &str) -> String {
    fs::read_to_string(tmp.path().join("output").join(path)).unwrap()
}
```

#### 新規 kind 用ヘルパー（追加予定）

client / library / database 用のヘルパーも同様のパターンで作成する。

```rust
// client 用
fn render_client(lang: &str) -> (TempDir, Vec<String>)

// library 用
fn render_library(lang: &str) -> (TempDir, Vec<String>)

// database 用
fn render_database(db_type: &str) -> (TempDir, Vec<String>)
```

### テストパターン

#### 1. ファイルリスト検証

生成されるファイルの一覧が仕様書と一致することを検証する。

```rust
#[test]
fn test_go_server_rest_full_stack_file_list() {
    let (tmp, names) = render_server("go", "rest", true, "postgresql", true, false);

    // 必須ファイルの存在確認
    assert!(names.iter().any(|n| n == "go.mod"), "go.mod missing");
    assert!(names.iter().any(|n| n == "cmd/main.go"), "cmd/main.go missing");
    // ...

    // 排他的ファイルの不在確認（REST の場合 gRPC/GraphQL ファイルは除外）
    assert!(!names.iter().any(|n| n.contains("grpc_handler")));
    assert!(!names.iter().any(|n| n.contains("graphql_resolver")));
}
```

検証項目:
- 必須ファイルの存在（`assert!` + `names.iter().any()`）
- 排他的ファイルの不在（`assert!` + `!names.iter().any()`）
- テストファイルの存在確認

#### 2. 条件付きファイル検証

API style / DB / Kafka / Redis の組み合わせによるファイル生成分岐を検証する。

| 条件 | 生成されるファイル | 生成されないファイル |
|------|-------------------|-------------------|
| `api_styles is containing("rest")` | `rest_handler.go` / `openapi.yaml` | `grpc_handler.go` / `service.proto` / `graphql_resolver.go` / `schema.graphql` |
| `api_styles is containing("grpc")` | `grpc_handler.go` / `service.proto` / `buf.yaml` | `rest_handler.go` / `openapi.yaml` / `graphql_resolver.go` |
| `api_styles is containing("graphql")` | `graphql_resolver.go` / `schema.graphql` / `gqlgen.yml` | `rest_handler.go` / `grpc_handler.go` / `service.proto` |
| `has_database == false` | — | `persistence/` 配下全ファイル |
| `has_kafka == false` | — | `messaging/` 配下全ファイル |

#### 3. テンプレート変数置換検証

`service_name` のケース変換が正しく適用されることを検証する。

```rust
#[test]
fn test_tera_variable_substitution_consistency() {
    // service_name = "user-auth" で検証
    let ctx = TemplateContextBuilder::new("user-auth", "service", "go", "server")
        .api_style("rest")
        .with_database("postgresql")
        .build();

    // PascalCase
    assert!(entity.contains("type UserAuthEntity struct {"));
    // camelCase
    assert!(persistence.contains("type userAuthRepository struct {"));
    // kebab-case（ルーティング）
    assert!(handler.contains("v1.GET(\"/user-auth\""));
    // snake_case（DB名）
    assert!(config_yaml.contains("name: \"user_auth_db\""));
}
```

検証対象のケース変換:

| 変数名 | ケース | 使用箇所 |
|--------|--------|---------|
| `service_name` | kebab-case | ルーティングパス、モジュールパス、config |
| `service_name_snake` | snake_case | DB名、パッケージ名 |
| `service_name_pascal` | PascalCase | 構造体名、インターフェース名 |
| `service_name_camel` | camelCase | プライベート構造体名 |

#### 4. Tera 構文残留チェック

レンダリング結果に Tera の制御構文が残っていないことを検証する。

検証対象の構文パターン:
- `{{` — 変数展開の未解決
- `{%` — 制御構文の未解決
- `{#` — コメントの未解決

このチェックはすべてのレンダリングテストで暗黙的に行われる（正しく置換されていればこれらの構文は残らない）。専用テストとして明示的に追加する場合:

```rust
#[test]
fn test_no_tera_syntax_remaining() {
    let (tmp, names) = render_server("go", "rest", true, "postgresql", true, true);
    for name in &names {
        let content = read_output(&tmp, name);
        assert!(!content.contains("{{"), "Tera variable syntax remaining in {name}");
        assert!(!content.contains("{%"), "Tera control syntax remaining in {name}");
        assert!(!content.contains("{#"), "Tera comment syntax remaining in {name}");
    }
}
```

#### 5. 設定ファイル内容検証

`config/config.yaml` 等の設定ファイルが正しい内容で生成されることを検証する。

```rust
#[test]
fn test_go_server_rest_config_yaml() {
    let (tmp, _) = render_server("go", "rest", true, "postgresql", true, true);
    let content = read_output(&tmp, "config/config.yaml");

    assert!(content.contains("name: \"order-api\""));
    assert!(content.contains("port: 8080"));
    assert!(content.contains("database:"));
    assert!(content.contains("port: 5432"));          // postgresql
    assert!(content.contains("kafka:"));
    assert!(content.contains("redis:"));
    assert!(content.contains("observability:"));
}
```

DB 種別ごとの設定差分:

| DB 種別 | ポート | ドライバ固有設定 |
|---------|-------|----------------|
| postgresql | 5432 | `ssl_mode: "disable"` |
| mysql | 3306 | `parseTime=true&charset=utf8mb4` |
| sqlite | — | ファイルパス指定 |

### テスト命名規則

```
test_{kind}_{language}_{feature}
```

#### サーバーテスト例

| テスト名 | 検証内容 |
|---------|---------|
| `test_go_server_rest_full_stack_file_list` | Go REST フルスタック構成のファイル一覧 |
| `test_go_server_rest_main_go_content` | Go REST の main.go 内容 |
| `test_go_server_grpc_file_list` | Go gRPC のファイル一覧 |
| `test_go_server_grpc_handler` | Go gRPC ハンドラの内容 |
| `test_go_server_graphql_file_list` | Go GraphQL のファイル一覧 |
| `test_go_server_no_database` | Go DB なし構成の除外検証 |
| `test_go_server_mysql` | Go MySQL 固有設定の検証 |
| `test_go_server_sqlite` | Go SQLite 固有設定の検証 |
| `test_rust_server_rest_full_stack_file_list` | Rust REST フルスタック構成のファイル一覧 |
| `test_rust_server_rest_cargo_toml` | Rust REST の Cargo.toml 内容 |
| `test_rust_server_grpc_file_list` | Rust gRPC のファイル一覧 |
| `test_rust_server_graphql_file_list` | Rust GraphQL のファイル一覧 |
| `test_rust_server_no_database` | Rust DB なし構成の除外検証 |
| `test_rust_server_mysql_config` | Rust MySQL 固有設定の検証 |
| `test_tera_variable_substitution_consistency` | Go での変数置換一貫性 |
| `test_tera_variable_substitution_rust` | Rust での変数置換一貫性 |
| `test_snapshot_go_rest_grpc_postgresql` | Go REST+gRPC + PostgreSQL のファイル一覧 |
| `test_snapshot_rust_rest_grpc_minimal` | Rust REST+gRPC 最小構成のファイル一覧 |
| `test_snapshot_bff_go` | Go BFF のファイル一覧 |
| `test_snapshot_bff_rust` | Rust BFF のファイル一覧 |

#### 新規テスト例（追加予定）

| テスト名 | 検証内容 |
|---------|---------|
| `test_client_react_file_list` | React クライアントのファイル一覧 |
| `test_client_react_package_json` | React の package.json 内容 |
| `test_client_flutter_file_list` | Flutter クライアントのファイル一覧 |
| `test_client_flutter_pubspec` | Flutter の pubspec.yaml 内容 |
| `test_library_go_file_list` | Go ライブラリのファイル一覧 |
| `test_library_go_module_path` | Go ライブラリの go.mod モジュールパス |
| `test_library_rust_file_list` | Rust ライブラリのファイル一覧 |
| `test_library_typescript_file_list` | TypeScript ライブラリのファイル一覧 |
| `test_library_dart_file_list` | Dart ライブラリのファイル一覧 |
| `test_database_postgresql_file_list` | PostgreSQL マイグレーションのファイル一覧 |
| `test_database_mysql_file_list` | MySQL マイグレーションのファイル一覧 |
| `test_database_sqlite_file_list` | SQLite マイグレーションのファイル一覧 |

---

## E2E テスト仕様

テスト配置: `e2e/tests/docs_compliance/` 配下。

### テスト構造パターン

E2E テストは pytest のクラスベーススタイルを採用する。

```python
ROOT = Path(__file__).resolve().parents[3]
TEMPLATES = ROOT / "CLI" / "templates"

class TestGoModContent:
    """テンプレート仕様-サーバー.md: go.mod.tera の内容検証。"""

    def setup_method(self) -> None:
        self.content = (SERVER_GO / "go.mod.tera").read_text(encoding="utf-8")

    def test_module_variable(self) -> None:
        assert "{{ go_module }}" in self.content
```

#### パターン要素

| 要素 | 説明 |
|------|------|
| `ROOT` | プロジェクトルート（`Path(__file__).resolve().parents[3]`） |
| `TEMPLATES` | テンプレートディレクトリ（`ROOT / "CLI" / "templates"`） |
| `setup_method` | テスト対象ファイルの読み込み |
| `pytest.mark.parametrize` | 複数値のパラメトリックテスト |
| クラス名 | `Test{対象ファイル}Content` |
| テストメソッド名 | `test_{検証項目}` |

### ファイル存在テスト

テンプレートエンジン仕様.md で定義されたディレクトリ構成に対応するテンプレートファイルの存在を検証する。

テストファイル: `test_template_files.py`

```python
class TestServerGoTemplates:
    """server/go テンプレートの検証。"""

    @pytest.mark.parametrize(
        "template",
        [
            "cmd/main.go.tera",
            "internal/domain/model/entity.go.tera",
            "internal/domain/repository/repository.go.tera",
            # ... 仕様書に定義された全テンプレート
        ],
    )
    def test_server_go_template_exists(self, template: str) -> None:
        path = TEMPLATES / "server" / "go" / template
        assert path.exists(), f"server/go/{template} が存在しません"
```

テスト対象クラス:

| クラス | 対象ディレクトリ |
|--------|----------------|
| `TestServerGoTemplates` | `server/go/` |
| `TestServerRustTemplates` | `server/rust/` |
| `TestClientReactTemplates` | `client/react/` |
| `TestClientFlutterTemplates` | `client/flutter/` |
| `TestLibraryGoTemplates` | `library/go/` |
| `TestLibraryRustTemplates` | `library/rust/` |
| `TestLibraryTypescriptTemplates` | `library/typescript/` |
| `TestLibraryDartTemplates` | `library/dart/` |
| `TestDatabasePostgresqlTemplates` | `database/postgresql/` |
| `TestDatabaseMysqlTemplates` | `database/mysql/` |
| `TestDatabaseSqliteTemplates` | `database/sqlite/` |

### 内容準拠テスト

テンプレートファイルの内容が仕様書のコードブロックと一致することを検証する。

テストファイル:
- `test_template_content_server.py` — サーバーテンプレートの内容検証
- `test_template_content_client.py` — クライアントテンプレートの内容検証
- `test_template_content_library.py` — ライブラリテンプレートの内容検証
- `test_template_content_database.py` — データベーステンプレートの内容検証

#### 検証項目

1. **テンプレート変数の存在**: `{{ service_name }}` 等の Tera 変数が含まれること
2. **条件分岐の存在**: `{% if has_database %}` 等の制御構文が含まれること
3. **依存ライブラリの宣言**: 仕様書に定義された依存が含まれること
4. **構造体・関数の定義**: 仕様書に定義されたシグネチャが含まれること

#### パラメトリックテストの活用

```python
@pytest.mark.parametrize(
    "condition,dep",
    [
        ('api_styles is containing("rest")', "oapi-codegen"),
        ('api_styles is containing("grpc")', "google.golang.org/grpc"),
        ('api_styles is containing("graphql")', "gqlgen"),
        ("has_database", "github.com/jmoiron/sqlx"),
        ('database_type == "postgresql"', "github.com/lib/pq"),
        ('database_type == "mysql"', "go-sql-driver/mysql"),
        ('database_type == "sqlite"', "go-sqlite3"),
        ("has_kafka", "kafka-go"),
        ("has_redis", "go-redis"),
    ],
)
def test_conditional_dependency(self, condition: str, dep: str) -> None:
    assert condition in self.content
    assert dep in self.content
```

### レンダリング結果テスト（将来拡張）

E2E テストで CLI を実際に実行し、レンダリング結果の構造・内容を検証する。現在は Rust 統合テストがこの役割を担っている。

将来的には以下を追加する:
- CLI コマンドの E2E 実行（`subprocess` で CLI を呼び出し）
- 生成されたプロジェクトのビルド検証（`go build` / `cargo check`）
- 生成されたプロジェクトのテスト実行（`go test` / `cargo test`）

### スナップショットテスト

`insta` crate を使用したスナップショットテストにより、テンプレートレンダリング結果のファイル一覧を固定化・回帰検証する。

テスト配置: `CLI/tests/snapshot_tests.rs`

依存追加: `CLI/Cargo.toml`
```toml
[dev-dependencies]
insta = { version = "1", features = ["yaml"] }
```

#### 対象パターン（サーバー代表6パターン）

| # | パターン | kind | language | api_style | DB | Kafka | Redis |
|---|---------|------|----------|-----------|-----|-------|-------|
| 1 | Go REST フルスタック | server | go | rest | postgresql | true | true |
| 2 | Go gRPC 最小 | server | go | grpc | — | false | false |
| 3 | Go GraphQL 最小 | server | go | graphql | — | false | false |
| 4 | Rust REST + DB | server | rust | rest | postgresql | false | false |
| 5 | Rust gRPC 最小 | server | rust | grpc | — | false | false |
| 6 | Rust GraphQL 最小 | server | rust | graphql | — | false | false |

#### 対象パターン（クライアント・ライブラリ・DB・Helm・CICD 追加12パターン）

| # | パターン | kind | language/framework | オプション |
|---|---------|------|-------------------|-----------|
| 7 | React クライアント | client | react | — |
| 8 | Flutter クライアント | client | flutter | — |
| 9 | Go ライブラリ | library | go | — |
| 10 | Rust ライブラリ | library | rust | — |
| 11 | TypeScript ライブラリ | library | typescript | — |
| 12 | Dart ライブラリ | library | dart | — |
| 13 | PostgreSQL DB | database | postgresql | — |
| 14 | MySQL DB | database | mysql | — |
| 15 | SQLite DB | database | sqlite | — |
| 16 | Helm Chart (REST+DB) | helm | — | rest, postgresql |
| 17 | CICD Go (REST+DB) | cicd | go | rest, postgresql, server |
| 18 | CICD Rust (gRPC) | cicd | rust | grpc, server |

#### 対象パターン（複数APIスタイル・BFF 追加4パターン）

| # | パターン | kind | language | api_styles | DB | Kafka | Redis |
|---|---------|------|----------|-----------|-----|-------|-------|
| 19 | Go REST+gRPC + PostgreSQL | server | go | [rest, grpc] | postgresql | - | - |
| 20 | Rust REST+gRPC (最小) | server | rust | [rest, grpc] | - | - | - |
| 21 | Go BFF | bff | go | [graphql] | - | - | - |
| 22 | Rust BFF | bff | rust | [graphql] | - | - | - |

パターン 19-20 は、複数の API スタイルを同時に選択した場合のレンダリング結果を検証する。従来の `render_server()` は単一の `api_style` のみを受け付けるため、複数 API スタイル対応の `render_server_multi()` ヘルパーを使用する。

パターン 21-22 は、BFF テンプレートのレンダリング結果を検証する。BFF は service Tier + GraphQL 選択時に生成される GraphQL BFF ゲートウェイのひな形であり、`kind = "bff"` として `TemplateContextBuilder` に渡す。

#### `render_server_multi()` — 複数APIスタイル対応ヘルパー

パターン 19-20 で使用する。従来の `render_server()` が単一の `api_style: &str` を受け取るのに対し、`render_server_multi()` は `api_styles: Vec<&str>` を受け取り、複数の API スタイルを同時に設定する。

```rust
fn render_server_multi(
    lang: &str,
    api_styles: Vec<&str>,
    has_database: bool,
    database_type: &str,
    has_kafka: bool,
    has_redis: bool,
) -> (TempDir, Vec<String>)
```

引数:
- `lang`: `"go"` | `"rust"` — サーバー言語
- `api_styles`: `Vec<&str>` — API スタイルのリスト（例: `vec!["rest", "grpc"]`）
- `has_database`: DB を含むか
- `database_type`: `"postgresql"` | `"mysql"` | `"sqlite"` | `""`
- `has_kafka`: Kafka を含むか
- `has_redis`: Redis を含むか

戻り値:
- `(TempDir, Vec<String>)` — 一時ディレクトリと生成されたファイルの相対パス一覧

実装イメージ:

```rust
fn render_server_multi(
    lang: &str,
    api_styles: Vec<&str>,
    has_database: bool,
    database_type: &str,
    has_kafka: bool,
    has_redis: bool,
) -> (TempDir, Vec<String>) {
    let tpl_dir = template_dir();
    let tmp = TempDir::new().unwrap();
    let output_dir = tmp.path().join("output");
    fs::create_dir_all(&output_dir).unwrap();

    let mut builder = TemplateContextBuilder::new("order-api", "service", lang, "server")
        .api_styles(api_styles.clone());

    if has_database {
        builder = builder.with_database(database_type);
    }
    if has_kafka {
        builder = builder.with_kafka();
    }
    if has_redis {
        builder = builder.with_redis();
    }

    let ctx = builder.build();
    let mut engine = TemplateEngine::new(&tpl_dir).unwrap();
    let generated = engine.render_to_dir(&ctx, &output_dir).unwrap();

    let names: Vec<String> = generated
        .iter()
        .map(|p| {
            p.strip_prefix(&output_dir)
                .unwrap()
                .to_string_lossy()
                .replace('\\', "/")
        })
        .collect();

    (tmp, names)
}
```

`render_server()` との主な違い:
- `api_style(&str)` の代わりに `api_styles(Vec<&str>)` を使用
- 複数 API スタイル分のファイルが同時に生成される（REST + gRPC の場合、`rest_handler` と `grpc_handler` の両方が存在）

#### `render_bff()` — BFF テンプレートヘルパー

パターン 21-22 で使用する。BFF テンプレートを `kind = "bff"` としてレンダリングする。

```rust
fn render_bff(lang: &str) -> (TempDir, Vec<String>)
```

引数:
- `lang`: `"go"` | `"rust"` — BFF 言語

戻り値:
- `(TempDir, Vec<String>)` — 一時ディレクトリと生成されたファイルの相対パス一覧

実装イメージ:

```rust
fn render_bff(lang: &str) -> (TempDir, Vec<String>) {
    let tpl_dir = template_dir();
    let tmp = TempDir::new().unwrap();
    let output_dir = tmp.path().join("output");
    fs::create_dir_all(&output_dir).unwrap();

    let ctx = TemplateContextBuilder::new("order-api", "service", lang, "bff")
        .api_style("graphql")
        .build();
    let mut engine = TemplateEngine::new(&tpl_dir).unwrap();
    let generated = engine.render_to_dir(&ctx, &output_dir).unwrap();

    let names: Vec<String> = generated
        .iter()
        .map(|p| {
            p.strip_prefix(&output_dir)
                .unwrap()
                .to_string_lossy()
                .replace('\\', "/")
        })
        .collect();

    (tmp, names)
}
```

BFF は常に GraphQL ベースのため、`api_style("graphql")` を固定で設定する。

#### 追加パターン用ヘルパー関数（パターン 7-18）

パターン 7〜18 のレンダリングには、以下のヘルパー関数を使用する。`render_server()` と同様に `TemplateContextBuilder` でコンテキストを構築し、`TempDir` に出力する。

```rust
/// クライアントテンプレートのレンダリング
/// framework: "react" | "flutter"
fn render_client(framework: &str) -> (TempDir, Vec<String>)

/// ライブラリテンプレートのレンダリング
/// lang: "go" | "rust" | "typescript" | "dart"
fn render_library(lang: &str) -> (TempDir, Vec<String>)

/// データベーステンプレートのレンダリング
/// db_type: "postgresql" | "mysql" | "sqlite"
fn render_database(db_type: &str) -> (TempDir, Vec<String>)

/// Helm Chart テンプレートのレンダリング
/// api_style: "rest" | "grpc" | "graphql"
/// has_database: DB を含むか
/// database_type: "postgresql" | "mysql" | "sqlite"
fn render_helm(api_style: &str, has_database: bool, database_type: &str) -> (TempDir, Vec<String>)

/// CI/CD テンプレートのレンダリング
/// lang: "go" | "rust"
/// kind: "server" | "client" | "library"
/// api_style: "rest" | "grpc" | "graphql"
/// has_database: DB を含むか
/// database_type: "postgresql" | "mysql" | "sqlite"
fn render_cicd(lang: &str, kind: &str, api_style: &str, has_database: bool, database_type: &str) -> (TempDir, Vec<String>)
```

#### テストパターン

```rust
// サーバーパターン（既存）
#[test]
fn test_snapshot_go_rest_full_stack() {
    let (_, names) = render_server("go", "rest", true, "postgresql", true, true);
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("go_rest_full_stack", sorted);
}

// クライアントパターン（#7, #8）
#[test]
fn test_snapshot_client_react() {
    let (_, names) = render_client("react");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("client_react", sorted);
}

#[test]
fn test_snapshot_client_flutter() {
    let (_, names) = render_client("flutter");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("client_flutter", sorted);
}

// ライブラリパターン（#9〜#12）
#[test]
fn test_snapshot_library_go() {
    let (_, names) = render_library("go");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("library_go", sorted);
}

#[test]
fn test_snapshot_library_rust() {
    let (_, names) = render_library("rust");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("library_rust", sorted);
}

#[test]
fn test_snapshot_library_typescript() {
    let (_, names) = render_library("typescript");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("library_typescript", sorted);
}

#[test]
fn test_snapshot_library_dart() {
    let (_, names) = render_library("dart");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("library_dart", sorted);
}

// データベースパターン（#13〜#15）
#[test]
fn test_snapshot_database_postgresql() {
    let (_, names) = render_database("postgresql");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("database_postgresql", sorted);
}

#[test]
fn test_snapshot_database_mysql() {
    let (_, names) = render_database("mysql");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("database_mysql", sorted);
}

#[test]
fn test_snapshot_database_sqlite() {
    let (_, names) = render_database("sqlite");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("database_sqlite", sorted);
}

// Helm Chart パターン（#16）
#[test]
fn test_snapshot_helm_rest_postgresql() {
    let (_, names) = render_helm("rest", true, "postgresql");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("helm_rest_postgresql", sorted);
}

// CI/CD パターン（#17, #18）
#[test]
fn test_snapshot_cicd_go_rest_postgresql() {
    let (_, names) = render_cicd("go", "server", "rest", true, "postgresql");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("cicd_go_rest_postgresql", sorted);
}

#[test]
fn test_snapshot_cicd_rust_grpc() {
    let (_, names) = render_cicd("rust", "server", "grpc", false, "");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("cicd_rust_grpc", sorted);
}
```

// 複数APIスタイルパターン（#19, #20）
#[test]
fn test_snapshot_go_rest_grpc_postgresql() {
    let (_, names) = render_server_multi("go", vec!["rest", "grpc"], true, "postgresql", false, false);
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("go_rest_grpc_postgresql", sorted);
}

#[test]
fn test_snapshot_rust_rest_grpc_minimal() {
    let (_, names) = render_server_multi("rust", vec!["rest", "grpc"], false, "", false, false);
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("rust_rest_grpc_minimal", sorted);
}

// BFF パターン（#21, #22）
#[test]
fn test_snapshot_bff_go() {
    let (_, names) = render_bff("go");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("bff_go", sorted);
}

#[test]
fn test_snapshot_bff_rust() {
    let (_, names) = render_bff("rust");
    let mut sorted = names.clone();
    sorted.sort();
    insta::assert_yaml_snapshot!("bff_rust", sorted);
}
```

各テストは生成ファイル一覧をソートし、YAML スナップショットとして保存する。初回実行時は `cargo insta test --accept` でスナップショットを生成し、以降はスナップショットとの差分を検出する。

#### BFF スナップショットの説明

BFF（Backend for Frontend）スナップショットテスト（パターン 21-22）は、service Tier で GraphQL を選択した際に生成される GraphQL BFF ゲートウェイのファイル一覧を検証する。

BFF テンプレートは通常のサーバーテンプレートと同じ構造を持つが、以下の点が異なる:

- `kind` が `"bff"` として `TemplateContextBuilder` に渡される
- API スタイルは常に `"graphql"` 固定
- 生成先は `regions/service/{service_name}/server/{lang}/bff/` 配下
- GraphQL スキーマ定義（`schema.graphql`）とリゾルバが必ず含まれる

BFF スナップショットで検証されるファイル構成の例（Go BFF の場合）:

| ファイル | 説明 |
|---------|------|
| `cmd/main.go` | BFF エントリポイント |
| `internal/handler/graphql_resolver.go` | GraphQL リゾルバ |
| `schema.graphql` | GraphQL スキーマ定義 |
| `gqlgen.yml` | gqlgen 設定ファイル |
| `go.mod` | Go モジュール定義 |
| `Dockerfile` | コンテナイメージ定義 |
| `config/config.yaml` | アプリケーション設定 |

Rust BFF の場合も同様の構造で、Rust 固有のファイル（`Cargo.toml`、`src/main.rs` 等）が生成される。

---

## Library Chart 連携テスト

Helm テンプレートから生成されるマニフェストファイルが、k1s0-common Library Chart を正しく呼び出していることを検証する。

### 概要

k1s0 の Helm テンプレートは、共通ロジックを Library Chart（`k1s0-common`）に集約している。各サービスの Helm Chart はアプリケーション Chart として、Library Chart が提供するヘルパーテンプレートを `include` で呼び出す構造となっている。本テストでは、この連携が正しく機能することを検証する。

### Rust 統合テスト — Library Chart 呼び出し検証

テスト配置: `CLI/tests/snapshot_tests.rs`（スナップショットテストと同ファイル、または `CLI/tests/helm_library_chart_tests.rs` として分離）

Helm テンプレートのレンダリング結果（`deployment.yaml`, `service.yaml` 等）が、Library Chart のヘルパーテンプレートを正しく参照していることを検証する。

#### 検証対象の include 呼び出し

| マニフェストファイル | 期待される include 呼び出し |
|--------------------|-----------------------------|
| `deployment.yaml` | `{{- include "k1s0-common.deployment" . }}` |
| `service.yaml` | `{{- include "k1s0-common.service" . }}` |
| `hpa.yaml` | `{{- include "k1s0-common.hpa" . }}` |
| `pdb.yaml` | `{{- include "k1s0-common.pdb" . }}` |
| `configmap.yaml` | `{{- include "k1s0-common.configmap" . }}` |
| `ingress.yaml` | `{{- include "k1s0-common.ingress" . }}` |

#### テストパターン

```rust
#[test]
fn test_helm_deployment_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/deployment.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.deployment\" . }}"),
        "deployment.yaml が k1s0-common.deployment を include していません"
    );
}

#[test]
fn test_helm_service_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/service.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.service\" . }}"),
        "service.yaml が k1s0-common.service を include していません"
    );
}

#[test]
fn test_helm_hpa_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/hpa.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.hpa\" . }}"),
        "hpa.yaml が k1s0-common.hpa を include していません"
    );
}

#[test]
fn test_helm_pdb_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/pdb.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.pdb\" . }}"),
        "pdb.yaml が k1s0-common.pdb を include していません"
    );
}

#[test]
fn test_helm_configmap_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/configmap.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.configmap\" . }}"),
        "configmap.yaml が k1s0-common.configmap を include していません"
    );
}

#[test]
fn test_helm_ingress_includes_library_chart() {
    let (tmp, _) = render_helm("rest", true, "postgresql");
    let content = read_output(&tmp, "templates/ingress.yaml");
    assert!(
        content.contains("{{- include \"k1s0-common.ingress\" . }}"),
        "ingress.yaml が k1s0-common.ingress を include していません"
    );
}
```

### E2E テスト — Library Chart ヘルパーテンプレート存在検証

テスト配置: `e2e/tests/docs_compliance/test_helm_library_chart.py`

`infra/helm/charts/k1s0-common/templates/` 配下に、Library Chart のヘルパーテンプレートが全て存在することを検証する。

#### 検証対象ファイル

| ヘルパーテンプレート | 役割 |
|--------------------|----|
| `_deployment.tpl` | Deployment マニフェスト生成ヘルパー |
| `_service.tpl` | Service マニフェスト生成ヘルパー |
| `_hpa.tpl` | HorizontalPodAutoscaler マニフェスト生成ヘルパー |
| `_pdb.tpl` | PodDisruptionBudget マニフェスト生成ヘルパー |
| `_configmap.tpl` | ConfigMap マニフェスト生成ヘルパー |
| `_helpers.tpl` | 共通ラベル・セレクタ等のユーティリティヘルパー |
| `_ingress.tpl` | Ingress マニフェスト生成ヘルパー |

#### テストパターン

```python
ROOT = Path(__file__).resolve().parents[3]
LIBRARY_CHART_TEMPLATES = ROOT / "infra" / "helm" / "charts" / "k1s0-common" / "templates"


class TestLibraryChartHelperTemplates:
    """Library Chart のヘルパーテンプレートが全て存在することを検証する。"""

    @pytest.mark.parametrize(
        "template",
        [
            "_deployment.tpl",
            "_service.tpl",
            "_hpa.tpl",
            "_pdb.tpl",
            "_configmap.tpl",
            "_helpers.tpl",
            "_ingress.tpl",
        ],
    )
    def test_helper_template_exists(self, template: str) -> None:
        path = LIBRARY_CHART_TEMPLATES / template
        assert path.exists(), (
            f"k1s0-common/templates/{template} が存在しません"
        )
```

#### Chart.yaml 依存関係検証

生成される Helm Chart の `Chart.yaml` が Library Chart への依存を正しく宣言していることも検証する。

```python
class TestHelmChartDependency:
    """生成される Chart.yaml が k1s0-common への依存を宣言していることを検証する。"""

    def setup_method(self) -> None:
        self.chart_template = (
            ROOT / "CLI" / "templates" / "helm" / "Chart.yaml.tera"
        )

    def test_library_chart_dependency_declared(self) -> None:
        content = self.chart_template.read_text(encoding="utf-8")
        assert "k1s0-common" in content, (
            "Chart.yaml.tera に k1s0-common への依存宣言がありません"
        )

    def test_library_chart_repository(self) -> None:
        content = self.chart_template.read_text(encoding="utf-8")
        assert "file://" in content or "repository:" in content, (
            "Chart.yaml.tera に Library Chart のリポジトリ参照がありません"
        )
```

---

## テストデータ定義

### 標準コンテキスト

Rust 統合テストで使用するデフォルトのテンプレートコンテキスト値。

| 変数 | テスト用デフォルト値 | 備考 |
|------|-------------------|------|
| `service_name` | `"order-api"` | kebab-case 正規形 |
| `service_name_snake` | `"order_api"` | 自動導出 |
| `service_name_pascal` | `"OrderApi"` | 自動導出 |
| `service_name_camel` | `"orderApi"` | 自動導出 |
| `tier` | `"service"` | 最も一般的な階層 |
| `domain` | `""` | service tier では空 |
| `language` | テストにより変動 | `"go"` / `"rust"` |
| `kind` | テストにより変動 | `"server"` / `"client"` / `"library"` / `"database"` |
| `api_style` | テストにより変動 | `"rest"` / `"grpc"` / `"graphql"` |
| `has_database` | テストにより変動 | `true` / `false` |
| `database_type` | テストにより変動 | `"postgresql"` / `"mysql"` / `"sqlite"` |
| `has_kafka` | テストにより変動 | `true` / `false` |
| `has_redis` | テストにより変動 | `true` / `false` |
| `go_module` | 自動導出 | `"github.com/org/k1s0/regions/service/order-api/server/go"` |
| `rust_crate` | 自動導出 | `"order-api"` |
| `docker_registry` | `"harbor.internal.example.com"` | デフォルト値 |
| `docker_project` | `"k1s0-service"` | 自動導出: `"k1s0-{tier}"` |

### 変数置換テスト用コンテキスト

ケース変換の正確性を検証するため、別名 `"user-auth"` を使用する。

| 変数 | 値 |
|------|-----|
| `service_name` | `"user-auth"` |
| `service_name_snake` | `"user_auth"` |
| `service_name_pascal` | `"UserAuth"` |
| `service_name_camel` | `"userAuth"` |

---

## テスト命名規則

### Rust 統合テスト

```
test_{kind}_{language}_{feature}
```

| セグメント | 値の例 |
|-----------|--------|
| `kind` | `go_server` / `rust_server` / `client_react` / `library_go` / `database_postgresql` |
| `feature` | `file_list` / `content` / `config` / `no_database` / `mysql` |

### E2E テスト

クラス名:

```
Test{対象ファイルPascalCase}Content
```

例: `TestGoModContent`, `TestReactPackageJsonContent`, `TestFlutterPubspecContent`

テストメソッド名:

```
test_{検証項目}
```

例: `test_module_variable`, `test_gin_dependency`, `test_conditional_dependency`

---

## 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) — テンプレート変数・フィルタ・構文の定義
- [テンプレート仕様-サーバー](テンプレート仕様-サーバー.md) — サーバーテンプレートの詳細仕様
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) — クライアントテンプレートの詳細仕様
- [テンプレート仕様-ライブラリ](テンプレート仕様-ライブラリ.md) — ライブラリテンプレートの詳細仕様
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) — データベーステンプレートの詳細仕様
