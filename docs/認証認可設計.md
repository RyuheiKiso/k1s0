# 認証認可設計

k1s0 における認証・認可・シークレット管理の設計を定義する。
Tier アーキテクチャの詳細は [tier-architecture.md](tier-architecture.md) を参照。

## 基本方針

- 認証基盤は **Keycloak**（セルフホスト）を使用する
- クライアント別に最適な OAuth 2.0 フローを採用する
- サービス間通信は **mTLS**（Istio STRICT モード）で保護する
- API Gateway（Kong）で JWT 検証を一元化する
- アプリケーションレベルの認可は **RBAC** で制御する
- シークレット管理は **HashiCorp Vault** で一元化する

---

## D-001: OAuth 2.0 / OIDC 実装

### Keycloak セルフホスト

認証基盤として Keycloak をオンプレミス Kubernetes クラスタ上にデプロイする。

| 項目               | 値                                          |
| ------------------ | ------------------------------------------- |
| デプロイ先         | `k1s0-system` Namespace                     |
| Realm              | `k1s0`                                      |
| IdP プロトコル     | OpenID Connect (OIDC)                       |
| ユーザーストア     | LDAP / AD 連携                              |
| 管理コンソール     | `auth.k1s0.internal.example.com`            |
| OIDC Discovery     | `https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration` |

### クライアント別 OAuth 2.0 フロー

| クライアント種別   | OAuth 2.0 フロー                     | 用途                   |
| ------------------ | ------------------------------------ | ---------------------- |
| SPA（React）       | Authorization Code + PKCE            | ブラウザベースの認証   |
| Mobile（Flutter）  | Authorization Code + PKCE            | モバイルアプリの認証   |
| CLI                | Device Authorization Grant           | CLI ツールからの認証   |
| サービス間         | Client Credentials                   | バックエンド間の認証   |

### Authorization Code + PKCE（SPA / Mobile）

```
1. Client → Keycloak: GET /authorize?response_type=code&code_challenge=...&code_challenge_method=S256
2. User → Keycloak: ログイン
3. Keycloak → Client: redirect with authorization_code
4. Client → Keycloak: POST /token (code + code_verifier)
5. Keycloak → Client: access_token + refresh_token + id_token
```

### Device Authorization Grant（CLI）

```
1. CLI → Keycloak: POST /device (client_id, scope)
2. Keycloak → CLI: device_code, user_code, verification_uri
3. CLI → User: 「ブラウザで https://auth.../device にアクセスし、コード XXXX-XXXX を入力してください」
4. User → Keycloak: ブラウザでコード入力・ログイン
5. CLI → Keycloak: POST /token (device_code) をポーリング
6. Keycloak → CLI: access_token + refresh_token
```

### Client Credentials（サービス間）

```
1. Service → Keycloak: POST /token (client_id, client_secret, grant_type=client_credentials)
2. Keycloak → Service: access_token
```

サービス間通信では mTLS に加え、必要に応じて Client Credentials で取得したトークンを使用する。

### トークンライフタイム

| トークン種別   | 有効期限 | 説明                                   |
| -------------- | -------- | -------------------------------------- |
| Access Token   | 15 分    | 短命にしてリスクを最小化               |
| Refresh Token  | 7 日     | Access Token の更新に使用              |
| ID Token       | 15 分    | ユーザー情報の取得に使用（Access と同期） |

### JWT Claims 構造

Access Token の JWT ペイロードは以下の Claims を含む。

```json
{
  "iss": "https://auth.k1s0.internal.example.com/realms/k1s0",
  "sub": "user-uuid-1234",
  "aud": "order-service",
  "exp": 1710000900,
  "iat": 1710000000,
  "jti": "token-uuid-5678",
  "typ": "Bearer",
  "azp": "react-spa",
  "scope": "openid profile email",
  "realm_access": {
    "roles": ["user", "order_manager"]
  },
  "resource_access": {
    "order-service": {
      "roles": ["read", "write"]
    }
  },
  "preferred_username": "taro.yamada",
  "email": "taro.yamada@example.com",
  "tier_access": ["system", "business", "service"]
}
```

| Claim              | 説明                                          |
| ------------------ | --------------------------------------------- |
| `sub`              | ユーザーの一意識別子（UUID）                  |
| `realm_access`     | グローバルロール                              |
| `resource_access`  | サービス固有のロール                          |
| `tier_access`      | アクセス可能な Tier の一覧                    |

### config.yaml の auth セクション拡張

既存の [config設計.md](config設計.md) の `auth` セクションに OIDC 設定を追加する。

```yaml
# config/config.yaml（auth セクション）
auth:
  jwt:
    issuer: "https://auth.k1s0.internal.example.com/realms/k1s0"
    audience: "order-service"
    public_key_path: "/etc/secrets/jwt-public.pem"
  oidc:
    discovery_url: "https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration"
    client_id: "order-service"
    client_secret: ""              # Vault から注入
    jwks_uri: "https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs"
    jwks_cache_ttl: "10m"
```

---

## D-002: JWT 公開鍵ローテーション

### JWKS エンドポイント方式

JWT の公開鍵配布には **JWKS（JSON Web Key Set）エンドポイント方式** を採用する。各サービスは Keycloak の JWKS エンドポイントから公開鍵を動的に取得する。

```
JWKS URL: https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs
```

### 鍵ローテーションスケジュール

| 項目                 | 値                                     |
| -------------------- | -------------------------------------- |
| アルゴリズム         | RS256（RSA 2048-bit）                  |
| ローテーション周期   | 90 日                                  |
| オーバーラップ期間   | 14 日（新旧鍵の並行運用）             |
| JWKS キャッシュ TTL  | 10 分                                  |

### ローテーションフロー

```
Day 0:     鍵 A で署名（JWKS には鍵 A のみ）
Day 76:    鍵 B を生成・JWKS に追加（鍵 A + 鍵 B）
Day 76-90: 新規トークンは鍵 B で署名、鍵 A のトークンも検証可能
Day 90:    鍵 A を JWKS から削除（鍵 B のみ）
```

### Go 実装例

```go
// internal/infra/auth/jwks.go

type JWKSVerifier struct {
    jwksURL    string
    cacheTTL   time.Duration
    mu         sync.RWMutex
    keySet     jwk.Set
    lastFetch  time.Time
}

func NewJWKSVerifier(jwksURL string, cacheTTL time.Duration) *JWKSVerifier {
    return &JWKSVerifier{
        jwksURL:  jwksURL,
        cacheTTL: cacheTTL,
    }
}

func (v *JWKSVerifier) VerifyToken(tokenString string) (*jwt.Token, error) {
    keySet, err := v.getKeySet()
    if err != nil {
        return nil, fmt.Errorf("failed to get JWKS: %w", err)
    }

    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        kid, ok := token.Header["kid"].(string)
        if !ok {
            return nil, fmt.Errorf("missing kid in token header")
        }
        key, found := keySet.LookupKeyID(kid)
        if !found {
            // キャッシュを強制更新して再試行
            v.invalidateCache()
            keySet, err := v.getKeySet()
            if err != nil {
                return nil, err
            }
            key, found = keySet.LookupKeyID(kid)
            if !found {
                return nil, fmt.Errorf("unknown kid: %s", kid)
            }
        }
        var pubKey interface{}
        if err := key.Raw(&pubKey); err != nil {
            return nil, err
        }
        return pubKey, nil
    })
    return token, err
}

func (v *JWKSVerifier) getKeySet() (jwk.Set, error) {
    v.mu.RLock()
    if v.keySet != nil && time.Since(v.lastFetch) < v.cacheTTL {
        defer v.mu.RUnlock()
        return v.keySet, nil
    }
    v.mu.RUnlock()

    v.mu.Lock()
    defer v.mu.Unlock()

    keySet, err := jwk.Fetch(context.Background(), v.jwksURL)
    if err != nil {
        return nil, err
    }
    v.keySet = keySet
    v.lastFetch = time.Now()
    return keySet, nil
}
```

### Rust 実装例

```rust
// src/infra/auth/jwks.rs

use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct JwksVerifier {
    jwks_url: String,
    cache_ttl: std::time::Duration,
    cache: Arc<RwLock<Option<JwksCache>>>,
}

struct JwksCache {
    keys: Vec<Jwk>,
    fetched_at: std::time::Instant,
}

impl JwksVerifier {
    pub fn new(jwks_url: String, cache_ttl: std::time::Duration) -> Self {
        Self {
            jwks_url,
            cache_ttl,
            cache: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let header = jsonwebtoken::decode_header(token)
            .map_err(|_| AuthError::InvalidToken)?;

        let kid = header.kid.ok_or(AuthError::MissingKid)?;
        let key = self.get_key(&kid).await?;

        let mut validation = Validation::new(Algorithm::RS256);
        validation.set_issuer(&["https://auth.k1s0.internal.example.com/realms/k1s0"]);

        let token_data = decode::<Claims>(token, &key, &validation)
            .map_err(|_| AuthError::InvalidToken)?;

        Ok(token_data.claims)
    }
}
```

---

## D-003: サービス間認証 mTLS

### Istio STRICT モード

サービス間通信の暗号化と認証には **Istio の mTLS STRICT モード** を使用する。全 Namespace に PeerAuthentication を適用する。

```yaml
# Namespace 全体に STRICT mTLS を強制
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-system
spec:
  mtls:
    mode: STRICT
---
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-business
spec:
  mtls:
    mode: STRICT
---
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-service
spec:
  mtls:
    mode: STRICT
```

### Tier 間 AuthorizationPolicy

[kubernetes設計.md](kubernetes設計.md) の NetworkPolicy と連携し、Istio の AuthorizationPolicy で Tier 間のアクセス制御を行う。NetworkPolicy が L3/L4 レベルの制御を担い、AuthorizationPolicy が L7 レベルの制御を担う。

```yaml
# system 層: business・service からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-lower-tiers
  namespace: k1s0-system
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["k1s0-business", "k1s0-service"]
    - from:
        - source:
            namespaces: ["k1s0-system"]           # 同一 Tier 内の通信も許可
---
# business 層: service からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-service-tier
  namespace: k1s0-business
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["k1s0-service"]
    - from:
        - source:
            namespaces: ["k1s0-business"]         # 同一 Tier 内の通信も許可
---
# service 層: ingress と同一 Tier からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-ingress
  namespace: k1s0-service
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["ingress"]
    - from:
        - source:
            namespaces: ["k1s0-service"]          # 同一 Tier 内の通信も許可
```

### 証明書管理

| 項目                   | 値                                  |
| ---------------------- | ----------------------------------- |
| CA                     | Istio CA（istiod 内蔵）            |
| 証明書ローテーション   | 24 時間（自動）                    |
| ルート CA 有効期限     | 10 年                              |
| ワークロード証明書     | SAN に SPIFFE ID を使用            |

cert-manager と Istio CA の連携により、ワークロード証明書は自動的にローテーションされる。

```
SPIFFE ID 形式: spiffe://k1s0.internal/ns/{namespace}/sa/{service-account}
```

---

## D-004: Kong API Gateway 認証フロー

### JWT プラグイン

Kong API Gateway で JWT 検証を一元化し、バックエンドサービスからの認証ロジックの重複を排除する。

```
Client → Kong (JWT検証) → Backend Service
```

### Kong JWT プラグイン設定

```yaml
plugins:
  - name: jwt
    config:
      key_claim_name: kid
      claims_to_verify:
        - exp
      maximum_expiration: 900           # 15分（Access Token のライフタイム）
      header_names:
        - Authorization
```

### JWKS 連携

Kong は Keycloak の JWKS エンドポイントから公開鍵を取得して JWT を検証する。

```yaml
# Kong Consumer + JWT Credential
consumers:
  - username: keycloak
    jwt_secrets:
      - algorithm: RS256
        key: "https://auth.k1s0.internal.example.com/realms/k1s0"
        rsa_public_key: |
          # JWKS エンドポイントから自動取得
```

### ヘッダー転送

JWT 検証後、Kong はユーザー情報をヘッダーとしてバックエンドに転送する。

```yaml
plugins:
  - name: post-function
    config:
      header_filter:
        - |
          local jwt = kong.ctx.shared.authenticated_jwt_token
          if jwt then
            kong.service.request.set_header("X-User-Id", jwt.claims.sub)
            kong.service.request.set_header("X-User-Roles", table.concat(jwt.claims.realm_access.roles, ","))
            kong.service.request.set_header("X-User-Email", jwt.claims.email or "")
          end
```

| 転送ヘッダー     | 値                                | 説明               |
| ---------------- | --------------------------------- | ------------------ |
| `X-User-Id`     | JWT の `sub` Claim                | ユーザー UUID      |
| `X-User-Roles`  | JWT の `realm_access.roles`       | カンマ区切りロール |
| `X-User-Email`  | JWT の `email` Claim              | メールアドレス     |

### CORS 設定

```yaml
plugins:
  - name: cors
    config:
      origins:
        - "https://*.k1s0.internal.example.com"
      methods:
        - GET
        - POST
        - PUT
        - PATCH
        - DELETE
        - OPTIONS
      headers:
        - Authorization
        - Content-Type
        - X-Request-ID
      credentials: true
      max_age: 3600
```

### ルーティング設計

Kong のルーティングは Tier × バージョンで整理する。

```yaml
services:
  # system 層
  - name: auth-service
    url: http://auth-server.k1s0-system.svc.cluster.local:80
    routes:
      - name: auth-routes
        paths:
          - /api/v1/auth
        strip_path: false

  # business 層
  - name: accounting-ledger
    url: http://ledger-server.k1s0-business.svc.cluster.local:80
    routes:
      - name: ledger-routes
        paths:
          - /api/v1/accounting/ledger
        strip_path: false

  # service 層
  - name: order-service
    url: http://order-server.k1s0-service.svc.cluster.local:80
    routes:
      - name: order-routes
        paths:
          - /api/v1/orders
        strip_path: false
```

---

## D-005: アプリケーションレベル RBAC

### Role → Permission → Resource モデル

```
User ──(has)──▶ Role ──(grants)──▶ Permission ──(on)──▶ Resource
```

- **Role**: ユーザーに割り当てる役割
- **Permission**: 操作の種類（`read`, `write`, `delete`, `admin`）
- **Resource**: 操作対象のリソース（`orders`, `ledger`, `users`）

### Tier 別ロール定義

#### system Tier ロール

| ロール              | 説明                           | Permission                          |
| ------------------- | ------------------------------ | ----------------------------------- |
| `sys_admin`         | システム全体の管理者           | すべてのリソースに対する全権限      |
| `sys_operator`      | システム運用担当               | 監視・ログ閲覧・設定変更           |
| `sys_auditor`       | 監査担当                       | 全リソースの読み取り専用           |

#### business Tier ロール

| ロール                 | 説明                          | Permission                          |
| ---------------------- | ----------------------------- | ----------------------------------- |
| `biz_{domain}_admin`   | 領域管理者                    | 領域内の全リソースに対する全権限    |
| `biz_{domain}_manager` | 領域マネージャー              | 領域内リソースの読み書き           |
| `biz_{domain}_viewer`  | 領域閲覧者                    | 領域内リソースの読み取り専用       |

#### service Tier ロール

| ロール                 | 説明                          | Permission                          |
| ---------------------- | ----------------------------- | ----------------------------------- |
| `svc_{service}_admin`  | サービス管理者                | サービス内の全リソースに対する全権限 |
| `svc_{service}_user`   | サービス利用者                | サービスの通常操作                  |
| `svc_{service}_viewer` | サービス閲覧者                | サービスリソースの読み取り専用      |

### Go ミドルウェア実装例

```go
// internal/adapter/middleware/rbac.go

type RBACMiddleware struct {
    requiredPermission string
    requiredResource   string
}

func RequirePermission(permission, resource string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Kong から転送されたヘッダーからロール情報を取得
            roles := strings.Split(r.Header.Get("X-User-Roles"), ",")
            userID := r.Header.Get("X-User-Id")

            if userID == "" {
                WriteError(w, r, http.StatusUnauthorized, "SYS_AUTH_UNAUTHENTICATED", "認証が必要です")
                return
            }

            if !hasPermission(roles, permission, resource) {
                WriteError(w, r, http.StatusForbidden, "SYS_AUTH_FORBIDDEN", "この操作を実行する権限がありません")
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}

// ルーティング例
mux.Handle("GET /api/v1/orders",
    RequirePermission("read", "orders")(orderHandler.List))
mux.Handle("POST /api/v1/orders",
    RequirePermission("write", "orders")(orderHandler.Create))
mux.Handle("DELETE /api/v1/orders/{id}",
    RequirePermission("delete", "orders")(orderHandler.Delete))
```

### Rust ミドルウェア実装例

```rust
// src/adapter/middleware/rbac.rs

use axum::{extract::Request, middleware::Next, response::Response};

pub async fn require_permission(
    permission: &str,
    resource: &str,
    req: Request,
    next: Next,
) -> Result<Response, ErrorResponse> {
    let user_id = req.headers()
        .get("X-User-Id")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| ErrorResponse::unauthenticated("認証が必要です"))?;

    let roles: Vec<&str> = req.headers()
        .get("X-User-Roles")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("")
        .split(',')
        .collect();

    if !has_permission(&roles, permission, resource) {
        return Err(ErrorResponse::forbidden("この操作を実行する権限がありません"));
    }

    Ok(next.run(req).await)
}
```

### クライアントのトークン管理

#### React（SPA）

```typescript
// src/lib/auth.ts

class AuthClient {
  private accessToken: string | null = null;
  private refreshToken: string | null = null;

  async login(): Promise<void> {
    // Authorization Code + PKCE フローを開始
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    sessionStorage.setItem('code_verifier', codeVerifier);

    const params = new URLSearchParams({
      response_type: 'code',
      client_id: AUTH_CONFIG.clientId,
      redirect_uri: AUTH_CONFIG.redirectUri,
      scope: 'openid profile email',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
    });

    window.location.href = `${AUTH_CONFIG.authorizationEndpoint}?${params}`;
  }

  async refreshAccessToken(): Promise<string> {
    const response = await fetch(AUTH_CONFIG.tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: AUTH_CONFIG.clientId,
        refresh_token: this.refreshToken!,
      }),
    });

    const data = await response.json();
    this.accessToken = data.access_token;
    this.refreshToken = data.refresh_token;
    return this.accessToken!;
  }
}
```

#### Flutter（Mobile）

```dart
// lib/features/auth/data/auth_repository.dart

class AuthRepository {
  final FlutterAppAuth _appAuth = const FlutterAppAuth();

  Future<TokenResponse> login() async {
    final result = await _appAuth.authorizeAndExchangeCode(
      AuthorizationTokenRequest(
        'flutter-mobile',                             // client_id
        'com.example.k1s0://callback',                // redirect_url
        issuer: 'https://auth.k1s0.internal.example.com/realms/k1s0',
        scopes: ['openid', 'profile', 'email'],
      ),
    );
    // Access Token はセキュアストレージに保存
    await _secureStorage.write(key: 'access_token', value: result.accessToken);
    await _secureStorage.write(key: 'refresh_token', value: result.refreshToken);
    return result;
  }
}
```

#### CLI

```rust
// CLI/src/commands/login.rs

pub async fn login() -> Result<()> {
    let client = reqwest::Client::new();

    // 1. Device Authorization Request
    let device_resp: DeviceAuthResponse = client
        .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/auth/device")
        .form(&[
            ("client_id", "k1s0-cli"),
            ("scope", "openid profile email"),
        ])
        .send()
        .await?
        .json()
        .await?;

    println!("ブラウザで {} にアクセスし、コード {} を入力してください",
        device_resp.verification_uri_complete,
        device_resp.user_code);

    // 2. Token Polling
    loop {
        tokio::time::sleep(Duration::from_secs(device_resp.interval as u64)).await;

        let token_resp = client
            .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/token")
            .form(&[
                ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
                ("client_id", "k1s0-cli"),
                ("device_code", &device_resp.device_code),
            ])
            .send()
            .await?;

        match token_resp.status() {
            StatusCode::OK => {
                let tokens: TokenResponse = token_resp.json().await?;
                save_tokens(&tokens)?;
                println!("ログインに成功しました");
                return Ok(());
            }
            _ => {
                let err: ErrorResponse = token_resp.json().await?;
                if err.error != "authorization_pending" {
                    return Err(anyhow!("認証エラー: {}", err.error_description));
                }
            }
        }
    }
}
```

---

## D-006: Vault 戦略

### 認証方式

| 認証方式         | 用途                                    |
| ---------------- | --------------------------------------- |
| Kubernetes Auth  | Kubernetes Pod からのアクセス           |
| AppRole          | CI/CD パイプラインからのアクセス        |
| LDAP             | 人間のオペレーターによる管理アクセス    |

### シークレットエンジン

| エンジン    | マウントパス       | 用途                                          |
| ----------- | ------------------ | --------------------------------------------- |
| KV v2       | `secret/`          | 静的シークレット（API キー、設定値等）        |
| Database    | `database/`        | データベースクレデンシャルの動的生成           |
| PKI         | `pki/`             | 内部 TLS 証明書の発行                         |

### Tier 別アクセスポリシー

各 Tier のサービスがアクセスできる Vault パスを制限する。

```hcl
# policy/system.hcl — system 層のポリシー
path "secret/data/k1s0/system/*" {
  capabilities = ["read", "list"]
}
path "database/creds/system-*" {
  capabilities = ["read"]
}
path "pki/issue/system" {
  capabilities = ["create", "update"]
}

# policy/business.hcl — business 層のポリシー
path "secret/data/k1s0/business/*" {
  capabilities = ["read", "list"]
}
path "database/creds/business-*" {
  capabilities = ["read"]
}

# policy/service.hcl — service 層のポリシー
path "secret/data/k1s0/service/*" {
  capabilities = ["read", "list"]
}
path "database/creds/service-*" {
  capabilities = ["read"]
}
```

### Kubernetes Auth 設定

```hcl
# Kubernetes Auth Backend の設定
resource "vault_auth_backend" "kubernetes" {
  type = "kubernetes"
}

resource "vault_kubernetes_auth_backend_config" "k8s" {
  backend            = vault_auth_backend.kubernetes.path
  kubernetes_host    = "https://kubernetes.default.svc"
  kubernetes_ca_cert = file("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
}

# system 層のロール
resource "vault_kubernetes_auth_backend_role" "system" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "system"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-system"]
  token_policies                   = ["system"]
  token_ttl                        = 3600
}

# business 層のロール
resource "vault_kubernetes_auth_backend_role" "business" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "business"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-business"]
  token_policies                   = ["business"]
  token_ttl                        = 3600
}

# service 層のロール
resource "vault_kubernetes_auth_backend_role" "service" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "service"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-service"]
  token_policies                   = ["service"]
  token_ttl                        = 3600
}
```

上記の Terraform 設定は [terraform設計.md](terraform設計.md) の `modules/vault/` に配置する。

### Database シークレットエンジン

データベースクレデンシャルは Vault が動的に生成・ローテーションする。

```hcl
# modules/vault/database.tf

resource "vault_database_secret_backend" "db" {
  path = "database"
}

resource "vault_database_secret_backend_connection" "order_db" {
  backend       = vault_database_secret_backend.db.path
  name          = "service-order"
  allowed_roles = ["service-order-rw", "service-order-ro"]

  postgresql {
    connection_url = "postgresql://{{username}}:{{password}}@postgres.k1s0-service.svc.cluster.local:5432/order_db"
  }
}

resource "vault_database_secret_backend_role" "order_rw" {
  backend             = vault_database_secret_backend.db.path
  name                = "service-order-rw"
  db_name             = vault_database_secret_backend_connection.order_db.name
  creation_statements = ["CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT ALL ON ALL TABLES IN SCHEMA public TO \"{{name}}\";"]
  default_ttl         = 86400     # 24 時間
  max_ttl             = 172800    # 48 時間
}
```

### 監査ログ設定

```hcl
# modules/vault/audit.tf

resource "vault_audit" "file" {
  type = "file"
  options = {
    file_path = "/vault/logs/audit.log"
    log_raw   = false              # シークレット値をマスク
  }
}
```

監査ログの内容:
- すべての認証試行（成功・失敗）
- すべてのシークレット読み取り操作
- ポリシー変更
- 設定変更

### クレデンシャルローテーション

| クレデンシャル種別     | ローテーション間隔 | 方式                        |
| ---------------------- | ------------------ | --------------------------- |
| DB パスワード          | 24 時間            | Vault Database エンジン自動 |
| API キー               | 90 日              | Vault KV v2 + 手動更新     |
| TLS 証明書             | 90 日              | Vault PKI エンジン自動     |
| JWT 署名鍵             | 90 日              | Keycloak の鍵ローテーション |

### Vault Agent Injector パターン

[helm設計.md](helm設計.md) の Vault Agent Injector と連携して Pod にシークレットを注入する。

```yaml
# Deployment の annotations
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "service"
        # 静的シークレット（KV v2）
        vault.hashicorp.com/agent-inject-secret-api-key: "secret/data/k1s0/service/order/api-key"
        # 動的シークレット（Database）
        vault.hashicorp.com/agent-inject-secret-db-creds: "database/creds/service-order-rw"
        vault.hashicorp.com/agent-inject-template-db-creds: |
          {{- with secret "database/creds/service-order-rw" -}}
          host=postgres.k1s0-service.svc.cluster.local
          port=5432
          dbname=order_db
          user={{ .Data.username }}
          password={{ .Data.password }}
          {{- end -}}
```

---

## 関連ドキュメント

- [tier-architecture.md](tier-architecture.md) — Tier アーキテクチャの詳細
- [config設計.md](config設計.md) — config.yaml スキーマと環境別管理
- [kubernetes設計.md](kubernetes設計.md) — Namespace・NetworkPolicy 設計
- [helm設計.md](helm設計.md) — Helm Chart・Vault Agent Injector
- [terraform設計.md](terraform設計.md) — Terraform モジュール（vault/ モジュール）
- [インフラ設計.md](インフラ設計.md) — オンプレミスインフラ全体構成
- [API設計.md](API設計.md) — REST API・gRPC・GraphQL・レート制限
