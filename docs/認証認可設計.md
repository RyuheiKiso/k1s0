# 認証認可設計

k1s0 における認証・認可・シークレット管理の設計を定義する。
Tier アーキテクチャの詳細は [tier-architecture.md](tier-architecture.md) を参照。

## 技術スタック

| コンポーネント       | 技術                     | バージョン |
| -------------------- | ------------------------ | ---------- |
| 認証基盤             | Keycloak（セルフホスト） | 26.0 (LTS) |
| API Gateway          | Kong                     | —          |
| サービスメッシュ     | Istio                    | —          |
| シークレット管理     | HashiCorp Vault          | —          |
| BFF Proxy            | Go (net/http)            | —          |
| セッションストア     | Redis Sentinel           | —          |

## 基本方針

- 認証基盤は **Keycloak 26.0**（セルフホスト、LTS）を使用する
- クライアント別に最適な OAuth 2.0 フローを採用する
- サービス間通信は **mTLS**（Istio STRICT モード）で保護する
- API Gateway（Kong）で JWT 検証を一元化する
- アプリケーションレベルの認可は **RBAC** で制御する
- シークレット管理は **HashiCorp Vault** で一元化する

---

## D-001: OAuth 2.0 / OIDC 実装

### Keycloak セルフホスト

認証基盤として Keycloak 26.0（LTS）をオンプレミス Kubernetes クラスタ上にデプロイする。

| 項目               | 値                                          |
| ------------------ | ------------------------------------------- |
| バージョン         | 26.0（LTS）                                |
| デプロイ先         | `k1s0-system` Namespace                     |
| Realm              | `k1s0`                                      |
| IdP プロトコル     | OpenID Connect (OIDC)                       |
| ユーザーストア     | LDAP / AD 連携                              |
| 管理コンソール     | `auth.k1s0.internal.example.com`            |
| OIDC Discovery     | `https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration` |

### Keycloak HA 構成

環境ごとに異なる構成でデプロイする。

| 環境    | Keycloak ノード数 | セッションストア / DB          | キャッシュ             |
| ------- | ----------------- | ------------------------------ | ---------------------- |
| prod    | 3 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| staging | 2 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| dev     | 1 ノード          | 組み込み H2 または外部 PostgreSQL | ローカルキャッシュ     |

- **prod**: Keycloak 3 ノード構成。外部 PostgreSQL をセッションストアおよびデータベースとして共有し、Infinispan 分散キャッシュによりノード間でセッション・認証キャッシュを同期する
- **staging**: Keycloak 2 ノード構成。prod と同一アーキテクチャで縮小運用
- **dev**: Keycloak 1 ノード構成。開発・検証用途のためシングルノードで運用

### LDAP / AD 連携

Keycloak の **User Federation** 機能を使用して LDAP プロバイダーを設定する。

#### 接続設定

| 項目           | 値                                      |
| -------------- | --------------------------------------- |
| プロトコル     | LDAPS（636 ポート）                     |
| 暗号化         | TLS 必須（平文 LDAP 接続は禁止）       |
| Bind DN        | `cn=keycloak,ou=service-accounts,dc=example,dc=com` |
| User DN        | `ou=users,dc=example,dc=com`           |

#### 属性マッピングルール

| LDAP 属性         | Keycloak 属性   | 説明                         |
| ----------------- | --------------- | ---------------------------- |
| `sAMAccountName`  | `username`      | ログイン ID                  |
| `mail`            | `email`         | メールアドレス               |
| `memberOf`        | グループ        | LDAP グループ → Keycloak グループにマッピング |

#### 同期方式

| 同期種別               | 方式                    | 間隔             |
| ---------------------- | ----------------------- | ---------------- |
| 差分同期               | Changed Users Sync      | 60 秒間隔        |
| 完全同期               | Full Sync               | 毎日深夜（0:00） |

- **Changed Users Sync（差分同期）**: 60 秒間隔で LDAP の変更分のみを同期する。通常運用ではこの差分同期により、ユーザーの追加・変更・無効化が 1 分以内に反映される
- **Full Sync（完全同期）**: 毎日深夜に LDAP 全ユーザーの完全同期を実行する。差分同期で漏れた変更を補完し、データの整合性を保証する

### クライアント別 OAuth 2.0 フロー

| クライアント種別   | OAuth 2.0 フロー                     | 用途                   |
| ------------------ | ------------------------------------ | ---------------------- |
| SPA（React）       | Authorization Code + PKCE            | ブラウザベースの認証   |
| Mobile（Flutter）  | Authorization Code + PKCE            | モバイルアプリの認証   |
| CLI                | Device Authorization Grant           | CLI ツールからの認証   |
| サービス間         | Client Credentials                   | バックエンド間の認証   |

### Authorization Code + PKCE（SPA / Mobile）

```
1. Client → Keycloak: GET /authorize?response_type=code&code_challenge=...&code_challenge_method=S256
2. User → Keycloak: ログイン
3. Keycloak → Client: redirect with authorization_code
4. Client → Keycloak: POST /token (code + code_verifier)
5. Keycloak → Client: access_token + refresh_token + id_token
```

### Device Authorization Grant（CLI）

```
1. CLI → Keycloak: POST /device (client_id, scope)
2. Keycloak → CLI: device_code, user_code, verification_uri
3. CLI → User: 「ブラウザで https://auth.../device にアクセスし、コード XXXX-XXXX を入力してください」
4. User → Keycloak: ブラウザでコード入力・ログイン
5. CLI → Keycloak: POST /token (device_code) をポーリング
6. Keycloak → CLI: access_token + refresh_token
```

### Client Credentials（サービス間）

```
1. Service → Keycloak: POST /token (client_id, client_secret, grant_type=client_credentials)
2. Keycloak → Service: access_token
```

サービス間通信では mTLS に加え、必要に応じて Client Credentials で取得したトークンを使用する。

### トークンライフタイム

| トークン種別   | 有効期限 | 説明                                   |
| -------------- | -------- | -------------------------------------- |
| Access Token   | 15 分    | 短命にしてリスクを最小化               |
| Refresh Token  | 7 日     | Access Token の更新に使用              |
| ID Token       | 15 分    | ユーザー情報の取得に使用（Access と同期） |

### JWT Claims 構造

Access Token の JWT ペイロードは以下の Claims を含む。

```json
{
  "iss": "https://auth.k1s0.internal.example.com/realms/k1s0",
  "sub": "user-uuid-1234",
  "aud": "order-service",
  "exp": 1710000900,
  "iat": 1710000000,
  "jti": "token-uuid-5678",
  "typ": "Bearer",
  "azp": "react-spa",
  "scope": "openid profile email",
  "realm_access": {
    "roles": ["user", "order_manager"]
  },
  "resource_access": {
    "order-service": {
      "roles": ["read", "write"]
    }
  },
  "preferred_username": "taro.yamada",
  "email": "taro.yamada@example.com",
  "tier_access": ["system", "business", "service"]
}
```

| Claim              | 説明                                          |
| ------------------ | --------------------------------------------- |
| `sub`              | ユーザーの一意識別子（UUID）                  |
| `realm_access`     | グローバルロール                              |
| `resource_access`  | サービス固有のロール                          |
| `tier_access`      | アクセス可能な Tier の一覧                    |

### config.yaml の auth セクション拡張

既存の [config設計.md](config設計.md) の `auth` セクションに OIDC 設定を追加する。

```yaml
# config/config.yaml（auth セクション）
auth:
  jwt:
    issuer: "https://auth.k1s0.internal.example.com/realms/k1s0"
    audience: "order-service"
    public_key_path: "/etc/secrets/jwt-public.pem"
  oidc:
    discovery_url: "https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration"
    client_id: "order-service"
    client_secret: ""              # Vault パス: secret/data/k1s0/system/auth/oidc キー: client_secret
    jwks_uri: "https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs"
    jwks_cache_ttl: "10m"
```

---

## D-002: JWT 公開鍵ローテーション

### JWKS エンドポイント方式

JWT の公開鍵配布には **JWKS（JSON Web Key Set）エンドポイント方式** を採用する。各サービスは Keycloak の JWKS エンドポイントから公開鍵を動的に取得する。

```
JWKS URL: https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs
```

### 鍵ローテーションスケジュール

| 項目                 | 値                                     |
| -------------------- | -------------------------------------- |
| アルゴリズム         | RS256（RSA 2048-bit）                  |
| ローテーション周期   | 90 日                                  |
| オーバーラップ期間   | 14 日（新旧鍵の並行運用）             |
| JWKS キャッシュ TTL  | 10 分                                  |

### ローテーションフロー

```
Day 0:     鍵 A で署名（JWKS には鍵 A のみ）
Day 76:    鍵 B を生成・JWKS に追加（鍵 A + 鍵 B）
Day 76-90: 新規トークンは鍵 B で署名、鍵 A のトークンも検証可能
Day 90:    鍵 A を JWKS から削除（鍵 B のみ）
```

### Go 実装例

```go
// internal/infra/auth/jwks.go

type JWKSVerifier struct {
    jwksURL    string
    cacheTTL   time.Duration
    mu         sync.RWMutex
    keySet     jwk.Set
    lastFetch  time.Time
}

func NewJWKSVerifier(jwksURL string, cacheTTL time.Duration) *JWKSVerifier {
    return &JWKSVerifier{
        jwksURL:  jwksURL,
        cacheTTL: cacheTTL,
    }
}

func (v *JWKSVerifier) VerifyToken(tokenString string) (*jwt.Token, error) {
    keySet, err := v.getKeySet()
    if err != nil {
        return nil, fmt.Errorf("failed to get JWKS: %w", err)
    }

    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        kid, ok := token.Header["kid"].(string)
        if !ok {
            return nil, fmt.Errorf("missing kid in token header")
        }
        key, found := keySet.LookupKeyID(kid)
        if !found {
            // キャッシュを強制更新して再試行
            v.invalidateCache()
            keySet, err := v.getKeySet()
            if err != nil {
                return nil, err
            }
            key, found = keySet.LookupKeyID(kid)
            if !found {
                return nil, fmt.Errorf("unknown kid: %s", kid)
            }
        }
        var pubKey interface{}
        if err := key.Raw(&pubKey); err != nil {
            return nil, err
        }
        return pubKey, nil
    })
    return token, err
}

func (v *JWKSVerifier) getKeySet() (jwk.Set, error) {
    v.mu.RLock()
    if v.keySet != nil && time.Since(v.lastFetch) < v.cacheTTL {
        defer v.mu.RUnlock()
        return v.keySet, nil
    }
    v.mu.RUnlock()

    v.mu.Lock()
    defer v.mu.Unlock()

    keySet, err := jwk.Fetch(context.Background(), v.jwksURL)
    if err != nil {
        return nil, err
    }
    v.keySet = keySet
    v.lastFetch = time.Now()
    return keySet, nil
}
```

### Rust 実装例

```rust
// src/infra/auth/jwks.rs

use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct JwksVerifier {
    jwks_url: String,
    cache_ttl: std::time::Duration,
    cache: Arc<RwLock<Option<JwksCache>>>,
}

struct JwksCache {
    keys: Vec<Jwk>,
    fetched_at: std::time::Instant,
}

impl JwksVerifier {
    pub fn new(jwks_url: String, cache_ttl: std::time::Duration) -> Self {
        Self {
            jwks_url,
            cache_ttl,
            cache: Arc::new(RwLock::new(None)),
        }
    }

    pub async fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let header = jsonwebtoken::decode_header(token)
            .map_err(|_| AuthError::InvalidToken)?;

        let kid = header.kid.ok_or(AuthError::MissingKid)?;
        let key = self.get_key(&kid).await?;

        let mut validation = Validation::new(Algorithm::RS256);
        validation.set_issuer(&["https://auth.k1s0.internal.example.com/realms/k1s0"]);

        let token_data = decode::<Claims>(token, &key, &validation)
            .map_err(|_| AuthError::InvalidToken)?;

        Ok(token_data.claims)
    }
}
```

---

## D-003: サービス間認証 mTLS

### Istio STRICT モード

サービス間通信の暗号化と認証には **Istio の mTLS STRICT モード** を使用する。全 Namespace に PeerAuthentication を適用する。

```yaml
# Namespace 全体に STRICT mTLS を強制
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-system
spec:
  mtls:
    mode: STRICT
---
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-business
spec:
  mtls:
    mode: STRICT
---
apiVersion: security.istio.io/v1
kind: PeerAuthentication
metadata:
  name: default
  namespace: k1s0-service
spec:
  mtls:
    mode: STRICT
```

### Tier 間 AuthorizationPolicy

[kubernetes設計.md](kubernetes設計.md) の NetworkPolicy と連携し、Istio の AuthorizationPolicy で Tier 間のアクセス制御を行う。NetworkPolicy が L3/L4 レベルの制御を担い、AuthorizationPolicy が L7 レベルの制御を担う。

```yaml
# system 層: business・service からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-lower-tiers
  namespace: k1s0-system
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["k1s0-business", "k1s0-service"]
    - from:
        - source:
            namespaces: ["k1s0-system"]           # 同一 Tier 内の通信も許可
---
# business 層: service からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-service-tier
  namespace: k1s0-business
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["k1s0-service"]
    - from:
        - source:
            namespaces: ["k1s0-business"]         # 同一 Tier 内の通信も許可
---
# service 層: ingress と同一 Tier からのアクセスのみ許可
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: allow-from-ingress
  namespace: k1s0-service
spec:
  action: ALLOW
  rules:
    - from:
        - source:
            namespaces: ["ingress"]
    - from:
        - source:
            namespaces: ["k1s0-service"]          # 同一 Tier 内の通信も許可
```

### 証明書管理

| 項目                   | 値                                  |
| ---------------------- | ----------------------------------- |
| CA                     | Istio CA（istiod 内蔵）            |
| 証明書ローテーション   | 24 時間（自動）                    |
| ルート CA 有効期限     | 10 年                              |
| ワークロード証明書     | SAN に SPIFFE ID を使用            |

cert-manager と Istio CA の連携により、ワークロード証明書は自動的にローテーションされる。

```
SPIFFE ID 形式: spiffe://k1s0.internal/ns/{namespace}/sa/{service-account}
```

---

## D-004: Kong API Gateway 認証フロー

### JWT プラグイン

Kong API Gateway で JWT 検証を一元化し、バックエンドサービスからの認証ロジックの重複を排除する。

```
Client → Kong (JWT検証) → Backend Service
```

### Kong JWT プラグイン設定

```yaml
plugins:
  - name: jwt
    config:
      key_claim_name: kid
      claims_to_verify:
        - exp
      maximum_expiration: 900           # 15分（Access Token のライフタイム）
      header_names:
        - Authorization
```

### JWKS 連携

Kong は Keycloak の JWKS エンドポイントから公開鍵を取得して JWT を検証する。

```yaml
# Kong Consumer + JWT Credential
consumers:
  - username: keycloak
    jwt_secrets:
      - algorithm: RS256
        key: "https://auth.k1s0.internal.example.com/realms/k1s0"
        rsa_public_key: |
          # JWKS エンドポイントから自動取得
```

### ヘッダー転送

JWT 検証後、Kong はユーザー情報をヘッダーとしてバックエンドに転送する。

```yaml
plugins:
  - name: post-function
    config:
      header_filter:
        - |
          local jwt = kong.ctx.shared.authenticated_jwt_token
          if jwt then
            kong.service.request.set_header("X-User-Id", jwt.claims.sub)
            kong.service.request.set_header("X-User-Roles", table.concat(jwt.claims.realm_access.roles, ","))
            kong.service.request.set_header("X-User-Email", jwt.claims.email or "")
          end
```

| 転送ヘッダー     | 値                                | 説明               |
| ---------------- | --------------------------------- | ------------------ |
| `X-User-Id`     | JWT の `sub` Claim                | ユーザー UUID      |
| `X-User-Roles`  | JWT の `realm_access.roles`       | カンマ区切りロール |
| `X-User-Email`  | JWT の `email` Claim              | メールアドレス     |

### CORS 設定

```yaml
plugins:
  - name: cors
    config:
      origins:
        - "https://*.k1s0.internal.example.com"
      methods:
        - GET
        - POST
        - PUT
        - PATCH
        - DELETE
        - OPTIONS
      headers:
        - Authorization
        - Content-Type
        - X-Request-ID
      credentials: true
      max_age: 3600
```

### ルーティング設計

Kong のルーティングは Tier × バージョンで整理する。

```yaml
services:
  # system 層
  - name: auth-service
    url: http://auth-server.k1s0-system.svc.cluster.local:80
    routes:
      - name: auth-routes
        paths:
          - /api/v1/auth
        strip_path: false

  # business 層
  - name: accounting-ledger
    url: http://ledger-server.k1s0-business.svc.cluster.local:80
    routes:
      - name: ledger-routes
        paths:
          - /api/v1/accounting/ledger
        strip_path: false

  # service 層
  - name: order-service
    url: http://order-server.k1s0-service.svc.cluster.local:80
    routes:
      - name: order-routes
        paths:
          - /api/v1/orders
        strip_path: false
```

---

## D-005: アプリケーションレベル RBAC

### Role → Permission → Resource モデル

```
User ──(has)──▶ Role ──(grants)──▶ Permission ──(on)──▶ Resource
```

- **Role**: ユーザーに割り当てる役割
- **Permission**: 操作の種類（`read`, `write`, `delete`, `admin`）
- **Resource**: 操作対象のリソース（`orders`, `ledger`, `users`）

### Tier 別ロール定義

#### system Tier ロール

| ロール              | 説明                           | Permission                          |
| ------------------- | ------------------------------ | ----------------------------------- |
| `sys_admin`         | システム全体の管理者           | すべてのリソースに対する全権限      |
| `sys_operator`      | システム運用担当               | 監視・ログ閲覧・設定変更           |
| `sys_auditor`       | 監査担当                       | 全リソースの読み取り専用           |

#### business Tier ロール

| ロール                 | 説明                          | Permission                          |
| ---------------------- | ----------------------------- | ----------------------------------- |
| `biz_{domain}_admin`   | 領域管理者                    | 領域内の全リソースに対する全権限    |
| `biz_{domain}_manager` | 領域マネージャー              | 領域内リソースの読み書き           |
| `biz_{domain}_viewer`  | 領域閲覧者                    | 領域内リソースの読み取り専用       |

#### service Tier ロール

| ロール                 | 説明                          | Permission                          |
| ---------------------- | ----------------------------- | ----------------------------------- |
| `svc_{service}_admin`  | サービス管理者                | サービス内の全リソースに対する全権限 |
| `svc_{service}_user`   | サービス利用者                | サービスの通常操作                  |
| `svc_{service}_viewer` | サービス閲覧者                | サービスリソースの読み取り専用      |

### パーミッションマトリクス（D-005）

以下に Tier ごとのロール × リソース × パーミッションの具体的なマトリクスを定義する。

#### system Tier パーミッションマトリクス

| ロール           | users | auth_config | audit_logs | api_gateway | vault_secrets | monitoring |
| ---------------- | ----- | ----------- | ---------- | ----------- | ------------- | ---------- |
| `sys_admin`      | CRUD  | CRUD        | R          | CRUD        | CRUD          | CRUD       |
| `sys_operator`   | R     | RU          | R          | R           | R             | RU         |
| `sys_auditor`    | R     | R           | R          | R           | —             | R          |

#### business Tier パーミッションマトリクス（例: accounting 領域）

| ロール                      | ledger | journal_entries | reports | master_data | approvals |
| --------------------------- | ------ | --------------- | ------- | ----------- | --------- |
| `biz_accounting_admin`      | CRUD   | CRUD            | CRUD    | CRUD        | CRUD      |
| `biz_accounting_manager`    | RU     | CRU             | CR      | RU          | CRU       |
| `biz_accounting_viewer`     | R      | R               | R       | R           | R         |

#### service Tier パーミッションマトリクス（例: order サービス）

| ロール                | orders | order_items | shipments | payments |
| --------------------- | ------ | ----------- | --------- | -------- |
| `svc_order_admin`     | CRUD   | CRUD        | CRUD      | CRUD     |
| `svc_order_user`      | CRU    | CRU         | R         | CR       |
| `svc_order_viewer`    | R      | R           | R         | R        |

**凡例**: C = Create, R = Read, U = Update, D = Delete, — = アクセス不可

#### パーミッション解決ルール

1. **ロールは Keycloak の `realm_access.roles` と `resource_access` から取得する**
2. 複数ロールを持つユーザーは、各ロールのパーミッションの **和集合** が適用される
3. 明示的に付与されていないパーミッションは **拒否（deny by default）**
4. `sys_admin` は全 Tier の全リソースにアクセス可能（スーパーユーザー）
5. Tier をまたぐアクセスは `tier_access` Claim で制御する

#### `tier_access` Claim の検証

`tier_access` Claim はユーザーがアクセス可能な Tier の一覧を定義する。二重検証により防御を多層化する。

**Mesh レベル検証（Istio AuthorizationPolicy）**

Istio の AuthorizationPolicy で JWT Claims の `tier_access` を検証し、Mesh レベルで不正アクセスを遮断する。

```yaml
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: require-tier-access
  namespace: k1s0-business
spec:
  action: ALLOW
  rules:
    - when:
        - key: request.auth.claims[tier_access]
          values: ["business"]
```

**アプリケーションレベル検証（ミドルウェア）**

各サービスのミドルウェアでも `tier_access` を二重検証する。Istio の検証をバイパスされた場合の防御層として機能する。

検証ロジック:
1. JWT の `tier_access` 配列を取得する
2. リクエスト先サービスが所属する Tier を特定する（サービス設定で定義）
3. サービスの Tier が `tier_access` 配列に含まれるかチェックする
4. 含まれていない場合は `403 Forbidden` を返却する

| 検証レイヤー           | 実装箇所                | 目的                             |
| ---------------------- | ----------------------- | -------------------------------- |
| Mesh レベル            | Istio AuthorizationPolicy | インフラレベルでの一次防御       |
| アプリケーションレベル | 各サービスのミドルウェア  | アプリケーションレベルでの二次防御 |

#### 新規サービス追加時のルール

新しいサービスを追加する際は、以下の3ロールを必ず定義する。

- `svc_{service}_admin` — サービス内の全リソースに対する全権限
- `svc_{service}_user` — 通常業務に必要な操作権限
- `svc_{service}_viewer` — 読み取り専用

リソースごとのパーミッションは上記マトリクスのフォーマットに従い、サービスの設計ドキュメントに記載する。

### `has_permission` パーミッション解決ロジック

パーミッション解決は **JWT Claims ベースの静的解決** を基本とし、DB ルックアップを不要とすることで低レイテンシの認可判定を実現する。

#### 解決フロー

```
1. JWT の realm_access.roles と resource_access.{client}.roles からロールを取得
2. ロール → パーミッション変換テーブルをインメモリキャッシュから参照
3. 要求されたパーミッション（permission + resource）がロールに含まれるかチェック
4. 含まれていれば許可、含まれていなければ拒否（deny by default）
```

#### ロール → パーミッション変換テーブルのキャッシュ

| 項目               | 値                                                     |
| ------------------ | ------------------------------------------------------ |
| データソース       | Keycloak Admin API（ロール定義 + パーミッション定義） |
| キャッシュ方式     | アプリケーション起動時にフェッチし、インメモリに保持   |
| キャッシュ TTL     | 5 分                                                   |
| 更新方式           | TTL 満了後のリクエスト時にバックグラウンドで再フェッチ |
| フォールバック     | キャッシュ更新失敗時は既存キャッシュを継続使用         |

- **インメモリ判定**: パーミッション判定は毎回 DB ルックアップを行わず、メモリ上のロール → パーミッション変換テーブルで即座に解決する
- **JWT Claims 信頼**: Kong で JWT 署名検証済みであることを前提とし、Claims 内のロール情報を信頼する
- **Keycloak Admin API**: 起動時および 5 分間隔で `GET /admin/realms/k1s0/roles` と各ロールのコンポジットロール情報を取得し、変換テーブルを構築する

### Go ミドルウェア実装例

```go
// internal/adapter/middleware/rbac.go

type RBACMiddleware struct {
    requiredPermission string
    requiredResource   string
}

func RequirePermission(permission, resource string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Kong から転送されたヘッダーからロール情報を取得
            roles := strings.Split(r.Header.Get("X-User-Roles"), ",")
            userID := r.Header.Get("X-User-Id")

            if userID == "" {
                WriteError(w, r, http.StatusUnauthorized, "SYS_AUTH_UNAUTHENTICATED", "認証が必要です")
                return
            }

            if !hasPermission(roles, permission, resource) {
                WriteError(w, r, http.StatusForbidden, "SYS_AUTH_FORBIDDEN", "この操作を実行する権限がありません")
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}

// ルーティング例
mux.Handle("GET /api/v1/orders",
    RequirePermission("read", "orders")(orderHandler.List))
mux.Handle("POST /api/v1/orders",
    RequirePermission("write", "orders")(orderHandler.Create))
mux.Handle("DELETE /api/v1/orders/{id}",
    RequirePermission("delete", "orders")(orderHandler.Delete))
```

### Rust ミドルウェア実装例

```rust
// src/adapter/middleware/rbac.rs

use axum::{extract::Request, middleware::Next, response::Response};

pub async fn require_permission(
    permission: &str,
    resource: &str,
    req: Request,
    next: Next,
) -> Result<Response, ErrorResponse> {
    let user_id = req.headers()
        .get("X-User-Id")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| ErrorResponse::unauthenticated("認証が必要です"))?;

    let roles: Vec<&str> = req.headers()
        .get("X-User-Roles")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("")
        .split(',')
        .collect();

    if !has_permission(&roles, permission, resource) {
        return Err(ErrorResponse::forbidden("この操作を実行する権限がありません"));
    }

    Ok(next.run(req).await)
}
```

### クライアントのトークン管理

### SPA トークン保存方式（D-013）

#### 決定: BFF プロキシ + HttpOnly Cookie 方式

SPA（React）ではトークンを **ブラウザの JavaScript から直接保持しない**。BFF（Backend for Frontend）がトークン管理を担い、ブラウザへは **HttpOnly Cookie** でセッションを維持する。

```
Browser → [HttpOnly Cookie] → BFF Proxy → [Bearer Token] → Kong → Backend
```

#### 選定理由

| 方式                    | XSS 耐性 | CSRF 耐性    | 実装コスト | 採用  |
| ----------------------- | --------- | ------------ | ---------- | ----- |
| localStorage            | 脆弱      | 不要         | 低         | 不採用 |
| sessionStorage          | 脆弱      | 不要         | 低         | 不採用 |
| メモリ（変数）          | 安全      | 不要         | 中         | 不採用 |
| HttpOnly Cookie（BFF）  | 安全      | 対策必要     | 中         | **採用** |

- **localStorage / sessionStorage**: XSS 攻撃でトークンが窃取されるリスクがある
- **メモリ保持**: ページリロードでトークンが失われ、UX が悪化する
- **HttpOnly Cookie + BFF**: JavaScript からトークンにアクセスできず、XSS 耐性が最も高い

#### CSRF 対策

HttpOnly Cookie 方式では CSRF 対策が必須となる。以下の多層防御を適用する。

| 対策                    | 実装方法                                           |
| ----------------------- | -------------------------------------------------- |
| SameSite 属性           | `SameSite=Strict`（同一サイトからのリクエストのみ） |
| CSRF トークン           | BFF が発行し、リクエストヘッダー `X-CSRF-Token` で送信 |
| Origin チェック          | BFF が `Origin` / `Referer` ヘッダーを検証         |

#### Cookie 設定

```
Set-Cookie: session={encrypted_session_id};
  HttpOnly;
  Secure;
  SameSite=Strict;
  Path=/;
  Max-Age=604800;
  Domain=.k1s0.internal.example.com
```

| 属性         | 値                               | 理由                               |
| ------------ | -------------------------------- | ---------------------------------- |
| `HttpOnly`   | true                             | JavaScript からのアクセスを遮断    |
| `Secure`     | true                             | HTTPS 通信のみで送信               |
| `SameSite`   | `Strict`                         | クロスサイトリクエストを遮断       |
| `Max-Age`    | 604800（7日）                    | Refresh Token のライフタイムと同期 |
| `Domain`     | `.k1s0.internal.example.com`    | サブドメイン間で共有               |

#### BFF Proxy 実装

BFF Proxy は **Go** で実装する。

| 項目       | 内容                                                                 |
| ---------- | -------------------------------------------------------------------- |
| 言語       | Go                                                                   |
| 選定理由   | 標準ライブラリの `net/http` が充実しており、リバースプロキシの実装が容易 |
|            | ミドルウェアのエコシステムが豊富（CORS、セッション管理、ロギング等） |
|            | チームの Go スキルを活用できる                                       |

#### BFF Redis セッションストア

BFF のセッション管理には **専用の Redis インスタンス** を使用する。セッション管理はセキュリティ要件が高いため、他用途（キャッシュ等）の Redis とは共用しない。

| 項目                 | 値                                          |
| -------------------- | ------------------------------------------- |
| 構成                 | Redis Sentinel                              |
| prod 構成            | Master 1 + Replica 2 + Sentinel 3           |
| セッション TTL       | 30 分（スライディングウィンドウ）           |
| TLS                  | 有効（暗号化通信必須）                      |
| AUTH                 | パスワード必須（Vault パス: `secret/data/k1s0/system/bff/redis` キー: `password`） |

- **スライディングウィンドウ**: ユーザーがアクティブな間はセッション TTL が延長される。30 分間操作がない場合にセッションが失効する
- **Redis Sentinel**: Master 障害時に自動フェイルオーバーを実行し、セッションの可用性を確保する
- **専用インスタンス**: セッションデータの分離により、他ワークロードの影響を受けずにセキュリティ・パフォーマンスを保証する

#### BFF のトークン管理フロー

```
1. Browser → BFF: GET /auth/login（PKCE フロー開始）
2. BFF → Keycloak: Authorization Code + PKCE
3. Keycloak → BFF: access_token + refresh_token
4. BFF: トークンをサーバーサイドセッション（Redis）に保存
5. BFF → Browser: Set-Cookie: session={session_id}（HttpOnly）
6. Browser → BFF: API リクエスト（Cookie 自動送信）
7. BFF: セッションから access_token を取得し、Authorization ヘッダーに付与
8. BFF → Kong → Backend: Bearer {access_token}
```

#### トークンリフレッシュ

BFF がサーバーサイドでリフレッシュを管理する。

- Access Token の有効期限の **2 分前** にバックグラウンドリフレッシュを実行
- リフレッシュ成功時、新しい Access Token と Refresh Token をセッションに上書き保存
- Refresh Token は **ワンタイム使用**（使用済みトークンでのリフレッシュ試行は全セッション無効化）

#### React（SPA）実装例

```typescript
// src/lib/api.ts
// BFF 経由のため、トークンを直接扱わない

const apiClient = axios.create({
  baseURL: '/api',           // BFF のプロキシエンドポイント
  withCredentials: true,      // Cookie を自動送信
});

// CSRF トークンをリクエストヘッダーに付与
apiClient.interceptors.request.use((config) => {
  const csrfToken = document.querySelector<HTMLMetaElement>(
    'meta[name="csrf-token"]'
  )?.content;
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});

// 401 レスポンス時はログインページにリダイレクト
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      window.location.href = '/auth/login';
    }
    return Promise.reject(error);
  }
);
```
```

#### Flutter（Mobile）

```dart
// lib/features/auth/data/auth_repository.dart

class AuthRepository {
  final FlutterAppAuth _appAuth = const FlutterAppAuth();

  Future<TokenResponse> login() async {
    final result = await _appAuth.authorizeAndExchangeCode(
      AuthorizationTokenRequest(
        'flutter-mobile',                             // client_id
        'com.example.k1s0://callback',                // redirect_url
        issuer: 'https://auth.k1s0.internal.example.com/realms/k1s0',
        scopes: ['openid', 'profile', 'email'],
      ),
    );
    // Access Token はセキュアストレージに保存
    await _secureStorage.write(key: 'access_token', value: result.accessToken);
    await _secureStorage.write(key: 'refresh_token', value: result.refreshToken);
    return result;
  }
}
```

#### CLI

```rust
// CLI/src/commands/login.rs

pub async fn login() -> Result<()> {
    let client = reqwest::Client::new();

    // 1. Device Authorization Request
    let device_resp: DeviceAuthResponse = client
        .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/auth/device")
        .form(&[
            ("client_id", "k1s0-cli"),
            ("scope", "openid profile email"),
        ])
        .send()
        .await?
        .json()
        .await?;

    println!("ブラウザで {} にアクセスし、コード {} を入力してください",
        device_resp.verification_uri_complete,
        device_resp.user_code);

    // 2. Token Polling
    loop {
        tokio::time::sleep(Duration::from_secs(device_resp.interval as u64)).await;

        let token_resp = client
            .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/token")
            .form(&[
                ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
                ("client_id", "k1s0-cli"),
                ("device_code", &device_resp.device_code),
            ])
            .send()
            .await?;

        match token_resp.status() {
            StatusCode::OK => {
                let tokens: TokenResponse = token_resp.json().await?;
                save_tokens(&tokens)?;
                println!("ログインに成功しました");
                return Ok(());
            }
            _ => {
                let err: ErrorResponse = token_resp.json().await?;
                if err.error != "authorization_pending" {
                    return Err(anyhow!("認証エラー: {}", err.error_description));
                }
            }
        }
    }
}
```

---

## D-006: Vault 戦略

### 認証方式

| 認証方式         | 用途                                    |
| ---------------- | --------------------------------------- |
| Kubernetes Auth  | Kubernetes Pod からのアクセス           |
| AppRole          | CI/CD パイプラインからのアクセス        |
| LDAP             | 人間のオペレーターによる管理アクセス    |

### シークレットエンジン

| エンジン    | マウントパス       | 用途                                          |
| ----------- | ------------------ | --------------------------------------------- |
| KV v2       | `secret/`          | 静的シークレット（API キー、設定値等）        |
| Database    | `database/`        | データベースクレデンシャルの動的生成           |
| PKI         | `pki/`             | 内部 TLS 証明書の発行                         |

### シークレットパス体系

Vault に格納するシークレットのパス命名規則を定義する。全ドキュメントでこの規則に従うこと。

#### KV v2 パス命名規則

```
secret/data/k1s0/{tier}/{service}/{secret-type}
```

| 要素            | 説明                                | 例                              |
| --------------- | ----------------------------------- | ------------------------------- |
| `k1s0`          | プロジェクトプレフィックス（固定）  | —                               |
| `tier`          | Tier 名                             | `system`, `business`, `service` |
| `service`       | サービス名（ハイフン区切り）        | `auth`, `order`, `bff`          |
| `secret-type`   | シークレットの種別                  | `database`, `api-key`, `oidc`, `redis` |

#### Database シークレットエンジン命名規則

```
database/creds/{tier}-{service}-{permission}
```

| 要素            | 説明                          | 例                           |
| --------------- | ----------------------------- | ---------------------------- |
| `tier`          | Tier 名                       | `system`, `business`, `service` |
| `service`       | サービス名                    | `order`, `ledger`, `auth`    |
| `permission`    | 権限レベル                    | `rw`（読み書き）, `ro`（読み取り専用） |

#### PKI 証明書パス命名規則

```
pki/issue/{tier}
```

#### シークレットパス一覧

以下にプロジェクト内で使用する全シークレットとその Vault パスを定義する。

**system Tier**

- `secret/data/k1s0/system/auth/oidc` — Keycloak OIDC Client Secret（キー: `client_secret`）
- `secret/data/k1s0/system/auth/database` — 認証サービス DB パスワード（キー: `password`）
- `secret/data/k1s0/system/bff/redis` — BFF セッション Redis AUTH パスワード（キー: `password`）
- `secret/data/k1s0/system/bff/oidc` — BFF OIDC Client Secret（キー: `client_secret`）
- `database/creds/system-auth-rw` — 認証サービス DB 動的クレデンシャル（読み書き）
- `database/creds/system-auth-ro` — 認証サービス DB 動的クレデンシャル（読み取り専用）

**business Tier**

- `secret/data/k1s0/business/{domain}/database` — 各ドメイン DB パスワード（キー: `password`）
- `secret/data/k1s0/business/{domain}/api-key` — 各ドメイン API キー（キー: `key`）
- `database/creds/business-{domain}-rw` — 各ドメイン DB 動的クレデンシャル（読み書き）
- `database/creds/business-{domain}-ro` — 各ドメイン DB 動的クレデンシャル（読み取り専用）

**service Tier**

- `secret/data/k1s0/service/{service}/database` — 各サービス DB パスワード（キー: `password`）
- `secret/data/k1s0/service/{service}/api-key` — 各サービス API キー（キー: `key`）
- `secret/data/k1s0/service/{service}/redis` — 各サービス Redis AUTH パスワード（キー: `password`）
- `database/creds/service-{service}-rw` — 各サービス DB 動的クレデンシャル（読み書き）
- `database/creds/service-{service}-ro` — 各サービス DB 動的クレデンシャル（読み取り専用）

**共通（Kafka）**

- `secret/data/k1s0/system/kafka/sasl` — Kafka SASL クレデンシャル（キー: `username`, `password`）

#### KV v2 シークレットのキー命名規則

各パスに格納するシークレットのキー名は以下の規則に従う。

| シークレット種別     | キー名            | 値の形式                |
| -------------------- | ----------------- | ----------------------- |
| DB パスワード        | `password`        | 文字列                  |
| API キー             | `key`             | 文字列                  |
| OIDC Client Secret   | `client_secret`   | 文字列                  |
| Redis AUTH パスワード | `password`       | 文字列                  |
| SASL ユーザー名      | `username`        | 文字列                  |
| SASL パスワード      | `password`        | 文字列                  |

#### Vault Agent Injector ファイルマウントパス規則

Pod にシークレットをファイルとして注入する際のマウントパスは以下の規則に従う。

```
/vault/secrets/{secret-type}
```

| マウントパス                    | 用途                          |
| ------------------------------- | ----------------------------- |
| `/vault/secrets/db-password`    | DB パスワード                 |
| `/vault/secrets/db-creds`       | DB 動的クレデンシャル         |
| `/vault/secrets/api-key`        | API キー                      |
| `/vault/secrets/redis-password` | Redis AUTH パスワード         |
| `/vault/secrets/oidc`           | OIDC Client Secret            |
| `/vault/secrets/kafka-sasl`     | Kafka SASL クレデンシャル     |

### Tier 別アクセスポリシー

各 Tier のサービスがアクセスできる Vault パスを制限する。

```hcl
# policy/system.hcl — system 層のポリシー
path "secret/data/k1s0/system/*" {
  capabilities = ["read", "list"]
}
path "database/creds/system-*" {
  capabilities = ["read"]
}
path "pki/issue/system" {
  capabilities = ["create", "update"]
}

# policy/business.hcl — business 層のポリシー
path "secret/data/k1s0/business/*" {
  capabilities = ["read", "list"]
}
path "database/creds/business-*" {
  capabilities = ["read"]
}

# policy/service.hcl — service 層のポリシー
path "secret/data/k1s0/service/*" {
  capabilities = ["read", "list"]
}
path "database/creds/service-*" {
  capabilities = ["read"]
}
```

### Kubernetes Auth 設定

```hcl
# Kubernetes Auth Backend の設定
resource "vault_auth_backend" "kubernetes" {
  type = "kubernetes"
}

resource "vault_kubernetes_auth_backend_config" "k8s" {
  backend            = vault_auth_backend.kubernetes.path
  kubernetes_host    = "https://kubernetes.default.svc"
  kubernetes_ca_cert = file("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
}

# system 層のロール
resource "vault_kubernetes_auth_backend_role" "system" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "system"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-system"]
  token_policies                   = ["system"]
  token_ttl                        = 3600
}

# business 層のロール
resource "vault_kubernetes_auth_backend_role" "business" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "business"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-business"]
  token_policies                   = ["business"]
  token_ttl                        = 3600
}

# service 層のロール
resource "vault_kubernetes_auth_backend_role" "service" {
  backend                          = vault_auth_backend.kubernetes.path
  role_name                        = "service"
  bound_service_account_names      = ["*"]
  bound_service_account_namespaces = ["k1s0-service"]
  token_policies                   = ["service"]
  token_ttl                        = 3600
}
```

上記の Terraform 設定は [terraform設計.md](terraform設計.md) の `modules/vault/` に配置する。

### Database シークレットエンジン

データベースクレデンシャルは Vault が動的に生成・ローテーションする。

```hcl
# modules/vault/database.tf

resource "vault_database_secret_backend" "db" {
  path = "database"
}

resource "vault_database_secret_backend_connection" "order_db" {
  backend       = vault_database_secret_backend.db.path
  name          = "service-order"
  allowed_roles = ["service-order-rw", "service-order-ro"]

  postgresql {
    connection_url = "postgresql://{{username}}:{{password}}@postgres.k1s0-service.svc.cluster.local:5432/order_db"
  }
}

resource "vault_database_secret_backend_role" "order_rw" {
  backend             = vault_database_secret_backend.db.path
  name                = "service-order-rw"
  db_name             = vault_database_secret_backend_connection.order_db.name
  creation_statements = ["CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT ALL ON ALL TABLES IN SCHEMA public TO \"{{name}}\";"]
  default_ttl         = 86400     # 24 時間
  max_ttl             = 172800    # 48 時間
}
```

### 監査ログ設定

```hcl
# modules/vault/audit.tf

resource "vault_audit" "file" {
  type = "file"
  options = {
    file_path = "/vault/logs/audit.log"
    log_raw   = false              # シークレット値をマスク
  }
}
```

監査ログの内容:
- すべての認証試行（成功・失敗）
- すべてのシークレット読み取り操作
- ポリシー変更
- 設定変更

### クレデンシャルローテーション

| クレデンシャル種別     | ローテーション間隔 | 方式                        |
| ---------------------- | ------------------ | --------------------------- |
| DB パスワード          | 24 時間            | Vault Database エンジン自動 |
| API キー               | 90 日              | Vault KV v2 + 手動更新     |
| TLS 証明書             | 90 日              | Vault PKI エンジン自動     |
| JWT 署名鍵             | 90 日              | Keycloak の鍵ローテーション |

### Vault Agent Injector パターン

[helm設計.md](helm設計.md) の Vault Agent Injector と連携して Pod にシークレットを注入する。

```yaml
# Deployment の annotations
spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "service"
        # 静的シークレット（KV v2）
        vault.hashicorp.com/agent-inject-secret-api-key: "secret/data/k1s0/service/order/api-key"
        # 動的シークレット（Database）
        vault.hashicorp.com/agent-inject-secret-db-creds: "database/creds/service-order-rw"
        vault.hashicorp.com/agent-inject-template-db-creds: |
          {{- with secret "database/creds/service-order-rw" -}}
          host=postgres.k1s0-service.svc.cluster.local
          port=5432
          dbname=order_db
          user={{ .Data.username }}
          password={{ .Data.password }}
          {{- end -}}
```

---

## 関連ドキュメント

- [tier-architecture.md](tier-architecture.md) — Tier アーキテクチャの詳細
- [config設計.md](config設計.md) — config.yaml スキーマと環境別管理
- [kubernetes設計.md](kubernetes設計.md) — Namespace・NetworkPolicy 設計
- [helm設計.md](helm設計.md) — Helm Chart・Vault Agent Injector
- [terraform設計.md](terraform設計.md) — Terraform モジュール（vault/ モジュール）
- [インフラ設計.md](インフラ設計.md) — オンプレミスインフラ全体構成
- [API設計.md](API設計.md) — REST API・gRPC・GraphQL・レート制限
