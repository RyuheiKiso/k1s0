# テンプレート仕様 — ライブラリ

## 1. 概要

ライブラリテンプレートは、k1s0 プロジェクトにおいて **他のサーバー・クライアントから依存される共有コード** のひな形を生成するためのテンプレートである。

### 対象言語

| 言語 | 主な用途 |
| --- | --- |
| Go | サーバー間で共有するロジック・型定義 |
| Rust | サーバー間で共有するロジック・型定義 |
| TypeScript | React クライアント間で共有するロジック・型定義 |
| Dart | Flutter クライアント間で共有するロジック・型定義 |
| C# | .NET サーバー間で共有するロジック・型定義 |

### 配置 Tier

ライブラリは **system** と **business** の2階層にのみ配置する。**service 層にはライブラリを置かない**。

- service は独立してデプロイ・稼働する最小単位であり、サービス間でコードを直接共有しない
- 複数サービスで共通化すべきコードが発生した場合は、上位層（business または system）の library に昇格させる

## 2. Tier 別配置パス

| Tier | パス |
| --- | --- |
| system | `regions/system/library/{lang}/{{ service_name }}/` |
| business | `regions/business/{domain}/library/{lang}/{{ service_name }}/` |

`{lang}` は言語識別子（`go` / `rust` / `ts` / `dart` / `csharp`）、`{domain}` は業務領域名（例: `accounting`, `fa`）を表す。

## 3. Go ライブラリテンプレート

### 3.1 go.mod

```go
module {{ go_module }}

go 1.23
```

ライブラリは必要最小限の依存にとどめる。外部モジュールへの依存は利用側が管理できるよう慎重に追加すること。

### 3.2 {{ service_name }}.go（公開パッケージ）

```go
// Package {{ service_name | snake_case }} は {{ service_name }} ライブラリの公開 API を提供する。
package {{ service_name | snake_case }}

// TODO: 公開 API の型定義・関数シグネチャを実装する
```

パッケージ宣言と公開 API のスケルトン（型定義、関数シグネチャ）を配置する。

### 3.3 internal/internal.go

```go
// Package internal は {{ service_name }} ライブラリの非公開実装を提供する。
package internal

// TODO: 非公開の実装を記述する
```

Go の `internal` パッケージにより、外部からのアクセスをコンパイル時に禁止する。

### 3.4 ディレクトリ構成

```
{{ service_name }}/
├── go.mod
├── {{ service_name }}.go         # 公開API
├── {{ service_name }}_test.go    # ユニットテスト（Go慣習: 同一パッケージ）
├── internal/
│   └── internal.go               # 非公開実装
├── tests/
│   └── integration_test.go       # 統合テスト
└── README.md
```

- ユニットテストは Go の慣習に従い、同一パッケージ内に `_test.go` ファイルとして配置する
- 統合テストは `tests/` ディレクトリに分離する
- テストには [testify](https://github.com/stretchr/testify) と [gomock](https://github.com/uber-go/mock) を使用する

## 4. Rust ライブラリテンプレート

### 4.1 Cargo.toml

```toml
[package]
name = "{{ service_name }}"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1", features = ["derive"] }
thiserror = "2"

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }
```

- `serde`: シリアライズ / デシリアライズ（ライブラリの型を外部に公開する際に必要）
- `thiserror`: エラー型の定義
- `mockall`: モックの自動生成（テスト用）
- `tokio`: 非同期テストランタイム（テスト用）

### 4.2 src/lib.rs

```rust
//! {{ service_name }} ライブラリ

pub mod {{ service_name | snake_case }};

// TODO: 公開 API を定義する
```

`pub mod` 宣言によりモジュールを公開する。ライブラリのエントリポイントとして機能する。

### 4.3 src/{{ service_name | snake_case }}.rs

```rust
//! {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_placeholder() {
        // TODO: ユニットテストを実装する
    }
}
```

モジュール実装のスケルトン。Rust の慣習に従い、`#[cfg(test)]` でユニットテストを同一ファイル内に記述する。

### 4.4 ディレクトリ構成

```
{{ service_name }}/
├── Cargo.toml
├── src/
│   ├── lib.rs                        # pub mod + 公開API
│   └── {{ service_name | snake_case }}.rs  # モジュール実装 + #[cfg(test)] ユニットテスト
├── tests/
│   └── integration_test.rs           # 統合テスト
└── README.md
```

- ユニットテストは `#[cfg(test)]` でモジュール内に記述する
- 統合テストは `tests/` ディレクトリに配置する（Cargo の規約に準拠）
- Linter / Formatter は `rustfmt` + `clippy` を使用する

## 5. TypeScript ライブラリテンプレート

### 5.1 package.json

```json
{
  "name": "{{ service_name }}",
  "version": "0.1.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src/",
    "format": "prettier --write src/"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vitest": "^3.0.0",
    "eslint": "^9.0.0",
    "prettier": "^3.0.0"
  }
}
```

- ライブラリとして `main` と `types` を明示し、型定義を公開する
- テストには Vitest を使用する
- Linter / Formatter は ESLint + Prettier を使用する

### 5.2 tsconfig.json

```json
{
  "compilerOptions": {
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "target": "ES2022",
    "paths": {}
  },
  "include": ["src"]
}
```

- `strict: true` で型安全性を担保する
- `declaration: true` で `.d.ts` ファイルを自動生成し、利用側に型情報を提供する

### 5.3 src/index.ts

```typescript
/**
 * {{ service_name }} ライブラリのエントリポイント
 */

// TODO: 公開 API をエクスポートする
// export { SomeType } from './some-module';
```

エクスポートのエントリポイント。利用側は `import { ... } from '{{ service_name }}'` でアクセスする。

### 5.4 ディレクトリ構成

```
{{ service_name }}/
├── package.json
├── tsconfig.json
├── src/
│   └── index.ts              # エクスポートエントリポイント
├── tests/
│   └── index.test.ts         # テスト
└── README.md
```

- テストは `tests/` ディレクトリに配置する
- テストには Vitest を使用する

## 6. Dart ライブラリテンプレート

### 6.1 pubspec.yaml

```yaml
name: {{ service_name | snake_case }}
version: 0.1.0
description: {{ service_name }} ライブラリ

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies: {}

dev_dependencies:
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.0
```

- `name` は Dart の慣習に従い snake_case とする
- テストには `flutter_test` と `mocktail` を使用する

### 6.2 lib/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name }} ライブラリのエントリポイント
library {{ service_name | snake_case }};

// TODO: 公開 API をエクスポートする
// export 'src/some_module.dart';
```

ライブラリエントリポイント。`export` 宣言で公開 API を明示する。

### 6.3 lib/src/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する
```

`lib/src/` 配下に実装を隠蔽する。利用側はエントリポイント経由でのみアクセスする。

### 6.4 ディレクトリ構成

```
{{ service_name }}/
├── pubspec.yaml
├── analysis_options.yaml
├── lib/
│   ├── {{ service_name | snake_case }}.dart   # エクスポートエントリポイント
│   └── src/
│       └── {{ service_name | snake_case }}.dart  # モジュール実装
├── test/                                       # Flutter/Dart 慣習: test/（tests/ ではない）
│   └── {{ service_name | snake_case }}_test.dart
└── README.md
```

- テストディレクトリは Flutter / Dart の慣習に従い `test/`（`tests/` ではない）を使用する
- Linter / Formatter は `dart analyze` + `dart format` を使用する

## 7. C# ライブラリテンプレート

### 7.1 {{ service_name }}.csproj（ライブラリ用）

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <RootNamespace>K1s0.System.{{ service_name | pascal_case }}</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.2.*">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>
</Project>
```

- `RootNamespace` は `K1s0.System.{{ service_name | pascal_case }}` とする
- `StyleCop.Analyzers` をプライベートアセットとして追加し、コード規約を強制する

### 7.2 {{ service_name }}.Tests.csproj（テスト用）

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <RootNamespace>K1s0.System.{{ service_name | pascal_case }}.Tests</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.*" />
    <PackageReference Include="xunit" Version="2.*" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.*" />
    <PackageReference Include="NSubstitute" Version="5.*" />
    <PackageReference Include="WireMock.Net" Version="1.*" />
    <PackageReference Include="Testcontainers" Version="4.*" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\src\{{ service_name }}.csproj" />
  </ItemGroup>
</Project>
```

- テストフレームワークは xUnit を使用する
- モックは NSubstitute、API モックは WireMock.Net、統合テストは Testcontainers を使用する

### 7.3 エラー型パターン

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

/// <summary>
/// {{ service_name }} ライブラリの公開例外型。
/// </summary>
public class {{ service_name | pascal_case }}Exception : Exception
{
    public string Code { get; }

    public {{ service_name | pascal_case }}Exception(string code, string message, Exception? innerException = null)
        : base(message, innerException)
    {
        Code = code;
    }
}
```

- `Exception` を継承し、`Code` プロパティでエラー種別を識別する

### 7.4 DI 拡張メソッドパターン

```csharp
using Microsoft.Extensions.DependencyInjection;

namespace K1s0.System.{{ service_name | pascal_case }};

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddK1s0{{ service_name | pascal_case }}(
        this IServiceCollection services)
    {
        // TODO: サービス登録を実装する
        return services;
    }
}
```

- `IServiceCollection` の拡張メソッドとして `AddK1s0{{ service_name | pascal_case }}` を提供する

### 7.5 ディレクトリ構成

```
{{ service_name }}/
├── {{ service_name }}.sln
├── src/
│   ├── {{ service_name }}.csproj
│   └── {{ service_name | pascal_case }}.cs       # 公開 API
├── tests/
│   ├── {{ service_name }}.Tests.csproj
│   ├── Unit/                                     # ユニットテスト
│   │   └── {{ service_name | pascal_case }}Tests.cs
│   └── Integration/                              # 統合テスト
│       └── {{ service_name | pascal_case }}IntegrationTests.cs
├── .editorconfig
└── README.md
```

- テストは `tests/` ディレクトリに配置し、`Unit/` と `Integration/` で分離する
- ファイル名は PascalCase.cs（C# 慣習）に従う
- Linter / Formatter は `StyleCop.Analyzers` + `dotnet format` を使用する

## 8. エラー型定義仕様

ライブラリの公開 API で返すエラーは、言語ごとの慣習に従ったエラー型を定義する。

### 7.1 Go: `AppError struct`

```go
package {{ service_name | snake_case }}

import "fmt"

// AppError はライブラリの公開エラー型。
type AppError struct {
	Code    string
	Message string
	Err     error
}

// Error は error interface を実装する。
func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap は内部エラーを返す。
func (e *AppError) Unwrap() error {
	return e.Err
}
```

- `error` interface を実装し、`errors.Is` / `errors.As` に対応する
- `Code` フィールドでエラーの種別を識別可能にする

### 7.2 Rust: `#[derive(thiserror::Error)] enum LibError`

```rust
use thiserror::Error;

/// ライブラリの公開エラー型。
#[derive(Debug, Error)]
pub enum LibError {
    #[error("not found: {0}")]
    NotFound(String),

    #[error("validation error: {0}")]
    Validation(String),

    #[error("internal error: {0}")]
    Internal(#[from] anyhow::Error),
}
```

- `thiserror` を使用してエラーの `Display` / `From` を自動導出する
- バリアントでエラーの種別を型安全に区別する

### 7.3 TypeScript: `class AppError extends Error`

```typescript
export class AppError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly cause?: Error,
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

- `Error` を継承し、`code` フィールドでエラー種別を識別する
- `cause` でラップ元のエラーを保持する

### 7.4 Dart: `class AppException implements Exception`

```dart
/// ライブラリの公開例外型。
class AppException implements Exception {
  final String code;
  final String message;
  final Object? cause;

  const AppException({
    required this.code,
    required this.message,
    this.cause,
  });

  @override
  String toString() => 'AppException($code): $message';
}
```

- `Exception` を実装し、`code` フィールドでエラー種別を識別する

### 7.5 C#: `class AppException : Exception`

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

/// <summary>
/// ライブラリの公開例外型。
/// </summary>
public class AppException : Exception
{
    public string Code { get; }

    public AppException(string code, string message, Exception? innerException = null)
        : base(message, innerException)
    {
        Code = code;
    }
}
```

- `Exception` を継承し、`Code` プロパティでエラー種別を識別する
- `innerException` でラップ元のエラーを保持する

## 8. Config.Validate() メソッド仕様

ライブラリが設定構造体を公開する場合、`Validate()` メソッドを提供して入力値の妥当性を検証する。

### 8.1 Go

```go
import "fmt"

type Config struct {
	Name    string `yaml:"name"`
	Version string `yaml:"version"`
}

// Validate は設定値を検証する。
func (c *Config) Validate() error {
	if c.Name == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "name is required"}
	}
	if c.Version == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "version is required"}
	}
	return nil
}
```

### 8.2 Rust

```rust
impl Config {
    /// 設定値を検証する。
    pub fn validate(&self) -> Result<(), LibError> {
        if self.name.is_empty() {
            return Err(LibError::Validation("name is required".to_string()));
        }
        if self.version.is_empty() {
            return Err(LibError::Validation("version is required".to_string()));
        }
        Ok(())
    }
}
```

### 8.3 TypeScript

```typescript
export interface Config {
  name: string;
  version: string;
}

export function validateConfig(config: Config): void {
  if (!config.name) {
    throw new AppError('INVALID_CONFIG', 'name is required');
  }
  if (!config.version) {
    throw new AppError('INVALID_CONFIG', 'version is required');
  }
}
```

### 8.4 Dart

```dart
class Config {
  final String name;
  final String version;

  const Config({required this.name, required this.version});

  /// 設定値を検証する。
  void validate() {
    if (name.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'name is required');
    }
    if (version.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'version is required');
    }
  }
}
```

### 8.5 C#

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

public class Config
{
    public string Name { get; init; } = string.Empty;
    public string Version { get; init; } = string.Empty;

    /// <summary>
    /// 設定値を検証する。
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrEmpty(Name))
            throw new AppException("INVALID_CONFIG", "name is required");
        if (string.IsNullOrEmpty(Version))
            throw new AppException("INVALID_CONFIG", "version is required");
    }
}
```

## 9. テストのエラーケース仕様

各言語のエラー型に対するテストパターンを定義する。

### 9.1 Go

```go
func TestAppError_Error(t *testing.T) {
	err := &AppError{Code: "NOT_FOUND", Message: "entity not found"}
	assert.Equal(t, "NOT_FOUND: entity not found", err.Error())
}

func TestAppError_Unwrap(t *testing.T) {
	inner := fmt.Errorf("db error")
	err := &AppError{Code: "INTERNAL", Message: "failed", Err: inner}
	assert.ErrorIs(t, err, inner)
}

func TestConfig_Validate_EmptyName(t *testing.T) {
	cfg := &Config{Name: "", Version: "0.1.0"}
	err := cfg.Validate()
	assert.Error(t, err)
}
```

### 9.2 Rust

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lib_error_not_found() {
        let err = LibError::NotFound("entity".to_string());
        assert_eq!(err.to_string(), "not found: entity");
    }

    #[test]
    fn test_config_validate_empty_name() {
        let cfg = Config { name: "".to_string(), version: "0.1.0".to_string() };
        assert!(cfg.validate().is_err());
    }
}
```

### 9.3 TypeScript

```typescript
import { describe, it, expect } from 'vitest';
import { AppError } from './error';
import { validateConfig } from './config';

describe('AppError', () => {
  it('should have correct code and message', () => {
    const err = new AppError('NOT_FOUND', 'entity not found');
    expect(err.code).toBe('NOT_FOUND');
    expect(err.message).toBe('entity not found');
  });
});

describe('validateConfig', () => {
  it('should throw on empty name', () => {
    expect(() => validateConfig({ name: '', version: '0.1.0' })).toThrow(AppError);
  });
});
```

### 9.4 Dart

```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  test('AppException toString', () {
    const err = AppException(code: 'NOT_FOUND', message: 'entity not found');
    expect(err.toString(), 'AppException(NOT_FOUND): entity not found');
  });

  test('Config.validate throws on empty name', () {
    const cfg = Config(name: '', version: '0.1.0');
    expect(() => cfg.validate(), throwsA(isA<AppException>()));
  });
}
```

### 9.5 C#

```csharp
using Xunit;

namespace K1s0.System.{{ service_name | pascal_case }}.Tests;

public class AppExceptionTests
{
    [Fact]
    public void Should_Have_Correct_Code_And_Message()
    {
        var ex = new AppException("NOT_FOUND", "entity not found");
        Assert.Equal("NOT_FOUND", ex.Code);
        Assert.Equal("entity not found", ex.Message);
    }
}

public class ConfigTests
{
    [Fact]
    public void Validate_Should_Throw_On_Empty_Name()
    {
        var cfg = new Config { Name = "", Version = "0.1.0" };
        Assert.Throws<AppException>(() => cfg.Validate());
    }
}
```

## 10. 共通ガイドライン

### 依存の最小化

ライブラリは他のサーバー・クライアントから依存されるため、依存モジュールを最小限に保つ。不要な依存は利用側のビルド時間・バイナリサイズに直接影響する。

### 公開 API の明示

- Go: パッケージレベルのエクスポート（大文字始まりの識別子）
- Rust: `pub` キーワードによるエクスポート
- TypeScript: `export` によるエクスポート + `index.ts` でのバレルエクスポート
- Dart: `export` 宣言によるエクスポート + `library` ディレクティブ
- C#: `public` アクセス修飾子によるエクスポート + 名前空間による整理

### 実装の隠蔽

| 言語 | 隠蔽手段 |
| --- | --- |
| Go | `internal/` パッケージ |
| Rust | `pub` なしのモジュール内アイテム |
| TypeScript | `src/` 内のモジュール（`index.ts` でエクスポートしないもの） |
| Dart | `lib/src/` 配下（`lib/` 直下のエントリポイントでエクスポートしないもの） |
| C# | `internal` アクセス修飾子によるアセンブリ外からのアクセス禁止 |

### バージョニング

ライブラリのバージョニングは **SemVer**（Semantic Versioning）に従う。

| バージョン | 変更内容 |
| --- | --- |
| MAJOR（x.0.0） | 後方互換性のない API 変更 |
| MINOR（0.x.0） | 後方互換性のある機能追加 |
| PATCH（0.0.x） | バグ修正 |

初期バージョンは `0.1.0` から開始し、安定版リリース時に `1.0.0` へ昇格する。

## 11. 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) --- 変数置換・条件分岐の仕様
- [テンプレート仕様-サーバー](テンプレート仕様-サーバー.md) --- サーバーテンプレート
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) --- クライアントテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) --- データベーステンプレート
- [CLIフロー](CLIフロー.md) --- CLI の対話フロー
- [ディレクトリ構成図](ディレクトリ構成図.md) --- 生成先ディレクトリ構成
- [コーディング規約](コーディング規約.md) --- Linter・テストツール
- [tier-architecture](tier-architecture.md) --- Tier 依存ルール
