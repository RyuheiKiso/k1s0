# テンプレート仕様 — ライブラリ

## 1. 概要

ライブラリテンプレートは、k1s0 プロジェクトにおいて **他のサーバー・クライアントから依存される共有コード** のひな形を生成するためのテンプレートである。

### 対象言語

| 言語 | 主な用途 |
| --- | --- |
| Go | サーバー間で共有するロジック・型定義 |
| Rust | サーバー間で共有するロジック・型定義 |
| TypeScript | React クライアント間で共有するロジック・型定義 |
| Dart | Flutter クライアント間で共有するロジック・型定義 |
| C# | .NET サーバー間で共有するロジック・型定義 |
| Swift | iOS / macOS ネイティブクライアントおよび Swift サーバーサイド間で共有するロジック・型定義 |

### 配置 Tier

ライブラリは **system** と **business** の2階層にのみ配置する。**service 層にはライブラリを置かない**。

- service は独立してデプロイ・稼働する最小単位であり、サービス間でコードを直接共有しない
- 複数サービスで共通化すべきコードが発生した場合は、上位層（business または system）の library に昇格させる

## 2. Tier 別配置パス

| Tier | パス |
| --- | --- |
| system | `regions/system/library/{lang}/{{ service_name }}/` |
| business | `regions/business/{domain}/library/{lang}/{{ service_name }}/` |

`{lang}` は言語識別子（`go` / `rust` / `ts` / `dart` / `csharp` / `swift`）、`{domain}` は業務領域名（例: `accounting`, `fa`）を表す。

## 3. Go ライブラリテンプレート

### 3.1 go.mod

```go
module {{ go_module }}

go 1.23
```

ライブラリは必要最小限の依存にとどめる。外部モジュールへの依存は利用側が管理できるよう慎重に追加すること。

### 3.2 {{ service_name }}.go（公開パッケージ）

```go
// Package {{ service_name | snake_case }} は {{ service_name }} ライブラリの公開 API を提供する。
package {{ service_name | snake_case }}

// TODO: 公開 API の型定義・関数シグネチャを実装する
```

パッケージ宣言と公開 API のスケルトン（型定義、関数シグネチャ）を配置する。

### 3.3 internal/internal.go

```go
// Package internal は {{ service_name }} ライブラリの非公開実装を提供する。
package internal

// TODO: 非公開の実装を記述する
```

Go の `internal` パッケージにより、外部からのアクセスをコンパイル時に禁止する。

### 3.4 ディレクトリ構成

```
{{ service_name }}/
├── go.mod
├── {{ service_name }}.go         # 公開API
├── {{ service_name }}_test.go    # ユニットテスト（Go慣習: 同一パッケージ）
├── internal/
│   └── internal.go               # 非公開実装
├── tests/
│   └── integration_test.go       # 統合テスト
└── README.md
```

- ユニットテストは Go の慣習に従い、同一パッケージ内に `_test.go` ファイルとして配置する
- 統合テストは `tests/` ディレクトリに分離する
- テストには [testify](https://github.com/stretchr/testify) と [gomock](https://github.com/uber-go/mock) を使用する

## 4. Rust ライブラリテンプレート

### 4.1 Cargo.toml

```toml
[package]
name = "{{ service_name }}"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1", features = ["derive"] }
thiserror = "2"

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }
```

- `serde`: シリアライズ / デシリアライズ（ライブラリの型を外部に公開する際に必要）
- `thiserror`: エラー型の定義
- `mockall`: モックの自動生成（テスト用）
- `tokio`: 非同期テストランタイム（テスト用）

### 4.2 src/lib.rs

```rust
//! {{ service_name }} ライブラリ

pub mod {{ service_name | snake_case }};

// TODO: 公開 API を定義する
```

`pub mod` 宣言によりモジュールを公開する。ライブラリのエントリポイントとして機能する。

### 4.3 src/{{ service_name | snake_case }}.rs

```rust
//! {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_placeholder() {
        // TODO: ユニットテストを実装する
    }
}
```

モジュール実装のスケルトン。Rust の慣習に従い、`#[cfg(test)]` でユニットテストを同一ファイル内に記述する。

### 4.4 ディレクトリ構成

```
{{ service_name }}/
├── Cargo.toml
├── src/
│   ├── lib.rs                        # pub mod + 公開API
│   └── {{ service_name | snake_case }}.rs  # モジュール実装 + #[cfg(test)] ユニットテスト
├── tests/
│   └── integration_test.rs           # 統合テスト
└── README.md
```

- ユニットテストは `#[cfg(test)]` でモジュール内に記述する
- 統合テストは `tests/` ディレクトリに配置する（Cargo の規約に準拠）
- Linter / Formatter は `rustfmt` + `clippy` を使用する

## 5. TypeScript ライブラリテンプレート

### 5.1 package.json

```json
{
  "name": "{{ service_name }}",
  "version": "0.1.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src/",
    "format": "prettier --write src/"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vitest": "^3.0.0",
    "eslint": "^9.0.0",
    "prettier": "^3.0.0"
  }
}
```

- ライブラリとして `main` と `types` を明示し、型定義を公開する
- テストには Vitest を使用する
- Linter / Formatter は ESLint + Prettier を使用する

### 5.2 tsconfig.json

```json
{
  "compilerOptions": {
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "target": "ES2022",
    "paths": {}
  },
  "include": ["src"]
}
```

- `strict: true` で型安全性を担保する
- `declaration: true` で `.d.ts` ファイルを自動生成し、利用側に型情報を提供する

### 5.3 src/index.ts

```typescript
/**
 * {{ service_name }} ライブラリのエントリポイント
 */

// TODO: 公開 API をエクスポートする
// export { SomeType } from './some-module';
```

エクスポートのエントリポイント。利用側は `import { ... } from '{{ service_name }}'` でアクセスする。

### 5.4 ディレクトリ構成

```
{{ service_name }}/
├── package.json
├── tsconfig.json
├── src/
│   └── index.ts              # エクスポートエントリポイント
├── tests/
│   └── index.test.ts         # テスト
└── README.md
```

- テストは `tests/` ディレクトリに配置する
- テストには Vitest を使用する

## 6. Dart ライブラリテンプレート

### 6.1 pubspec.yaml

```yaml
name: {{ service_name | snake_case }}
version: 0.1.0
description: {{ service_name }} ライブラリ

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies: {}

dev_dependencies:
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.0
```

- `name` は Dart の慣習に従い snake_case とする
- テストには `flutter_test` と `mocktail` を使用する

### 6.2 lib/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name }} ライブラリのエントリポイント
library {{ service_name | snake_case }};

// TODO: 公開 API をエクスポートする
// export 'src/some_module.dart';
```

ライブラリエントリポイント。`export` 宣言で公開 API を明示する。

### 6.3 lib/src/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する
```

`lib/src/` 配下に実装を隠蔽する。利用側はエントリポイント経由でのみアクセスする。

### 6.4 ディレクトリ構成

```
{{ service_name }}/
├── pubspec.yaml
├── analysis_options.yaml
├── lib/
│   ├── {{ service_name | snake_case }}.dart   # エクスポートエントリポイント
│   └── src/
│       └── {{ service_name | snake_case }}.dart  # モジュール実装
├── test/                                       # Flutter/Dart 慣習: test/（tests/ ではない）
│   └── {{ service_name | snake_case }}_test.dart
└── README.md
```

- テストディレクトリは Flutter / Dart の慣習に従い `test/`（`tests/` ではない）を使用する
- Linter / Formatter は `dart analyze` + `dart format` を使用する

## 7. C# ライブラリテンプレート

### 7.1 {{ service_name }}.csproj（ライブラリ用）

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <RootNamespace>K1s0.System.{{ service_name | pascal_case }}</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.2.*">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>
</Project>
```

- `RootNamespace` は `K1s0.System.{{ service_name | pascal_case }}` とする
- `StyleCop.Analyzers` をプライベートアセットとして追加し、コード規約を強制する

### 7.2 {{ service_name }}.Tests.csproj（テスト用）

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <RootNamespace>K1s0.System.{{ service_name | pascal_case }}.Tests</RootNamespace>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.*" />
    <PackageReference Include="xunit" Version="2.*" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.*" />
    <PackageReference Include="NSubstitute" Version="5.*" />
    <PackageReference Include="WireMock.Net" Version="1.*" />
    <PackageReference Include="Testcontainers" Version="4.*" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\src\{{ service_name }}.csproj" />
  </ItemGroup>
</Project>
```

- テストフレームワークは xUnit を使用する
- モックは NSubstitute、API モックは WireMock.Net、統合テストは Testcontainers を使用する

### 7.3 エラー型パターン

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

/// <summary>
/// {{ service_name }} ライブラリの公開例外型。
/// </summary>
public class {{ service_name | pascal_case }}Exception : Exception
{
    public string Code { get; }

    public {{ service_name | pascal_case }}Exception(string code, string message, Exception? innerException = null)
        : base(message, innerException)
    {
        Code = code;
    }
}
```

- `Exception` を継承し、`Code` プロパティでエラー種別を識別する

### 7.4 DI 拡張メソッドパターン

```csharp
using Microsoft.Extensions.DependencyInjection;

namespace K1s0.System.{{ service_name | pascal_case }};

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddK1s0{{ service_name | pascal_case }}(
        this IServiceCollection services)
    {
        // TODO: サービス登録を実装する
        return services;
    }
}
```

- `IServiceCollection` の拡張メソッドとして `AddK1s0{{ service_name | pascal_case }}` を提供する

### 7.5 ディレクトリ構成

```
{{ service_name }}/
├── {{ service_name }}.sln
├── src/
│   ├── {{ service_name }}.csproj
│   └── {{ service_name | pascal_case }}.cs       # 公開 API
├── tests/
│   ├── {{ service_name }}.Tests.csproj
│   ├── Unit/                                     # ユニットテスト
│   │   └── {{ service_name | pascal_case }}Tests.cs
│   └── Integration/                              # 統合テスト
│       └── {{ service_name | pascal_case }}IntegrationTests.cs
├── .editorconfig
└── README.md
```

- テストは `tests/` ディレクトリに配置し、`Unit/` と `Integration/` で分離する
- ファイル名は PascalCase.cs（C# 慣習）に従う
- Linter / Formatter は `StyleCop.Analyzers` + `dotnet format` を使用する

## 8. Swift ライブラリテンプレート

### 8.1 Package.swift

```swift
// swift-tools-version: 6.0
import PackageDescription

let package = Package(
    name: "{{ service_name }}",
    platforms: [
        .iOS(.v17),
        .macOS(.v14),
    ],
    products: [
        .library(
            name: "{{ service_name_pascal }}",
            targets: ["{{ service_name_pascal }}"]),
    ],
    dependencies: [],
    targets: [
        .target(
            name: "{{ service_name_pascal }}",
            dependencies: []),
        .testTarget(
            name: "{{ service_name_pascal }}Tests",
            dependencies: ["{{ service_name_pascal }}"]),
    ]
)
```

- Swift 6 Concurrency に対応するため `swift-tools-version: 6.0` を使用する
- iOS 17 / macOS 14 以降をサポートプラットフォームとして設定する
- ライブラリターゲットとテストターゲットをセットで定義する

### 8.2 Sources/{{ service_name_pascal }}/LibError.swift

```swift
/// {{ service_name }} ライブラリの公開エラー型。
public enum LibError: Error, Sendable {
    case notFound(String)
    case validation(String)
    case `internal`(String)
}

extension LibError: CustomStringConvertible {
    public var description: String {
        switch self {
        case .notFound(let msg): return "not found: \(msg)"
        case .validation(let msg): return "validation error: \(msg)"
        case .internal(let msg): return "internal error: \(msg)"
        }
    }
}
```

- `Error` プロトコル準拠の `enum` としてエラーを定義する
- `Sendable` 準拠により Swift Concurrency 環境での安全な受け渡しを保証する
- `switch` による網羅的ハンドリングを利用側に強制する

### 8.3 Sources/{{ service_name_pascal }}/Config.swift

```swift
/// {{ service_name }} ライブラリの設定型。
public struct Config: Sendable {
    public let name: String
    public let version: String

    public init(name: String, version: String) {
        self.name = name
        self.version = version
    }

    /// 設定値を検証する。
    public func validate() throws {
        guard !name.isEmpty else {
            throw LibError.validation("name is required")
        }
        guard !version.isEmpty else {
            throw LibError.validation("version is required")
        }
    }
}
```

- `Sendable` 準拠の `struct` で設定を表現する
- `validate()` は `throws` で `LibError` を返す

### 8.4 Sources/{{ service_name_pascal }}/Client.swift

```swift
/// {{ service_name }} クライアント。
public actor {{ service_name_pascal }}Client {
    private let config: Config

    public init(config: Config) throws {
        try config.validate()
        self.config = config
    }

    // TODO: 公開 API を実装する
}
```

- `actor` により内部状態のデータ競合を型システムで防止する
- 初期化時に `Config.validate()` を呼び出して設定値を検証する

### 8.5 Tests/{{ service_name_pascal }}Tests/ClientTests.swift

```swift
import Testing
@testable import {{ service_name_pascal }}

@Suite("{{ service_name_pascal }}Client Tests")
struct ClientTests {
    @Test("有効な設定で初期化が成功する")
    func initWithValidConfig() throws {
        let config = Config(name: "test", version: "0.1.0")
        let client = try {{ service_name_pascal }}Client(config: config)
        #expect(client != nil)
    }

    @Test("空の name で LibError.validation が throw される")
    func initWithEmptyNameThrows() throws {
        let config = Config(name: "", version: "0.1.0")
        #expect(throws: LibError.self) {
            try {{ service_name_pascal }}Client(config: config)
        }
    }
}
```

- Swift Testing フレームワーク（`@Suite`、`@Test`、`#expect`）を使用する
- `@testable import` でモジュール内部の型をテスト対象にする

### 8.6 ディレクトリ構成

```
{{ service_name }}/
├── Package.swift
├── Sources/
│   └── {{ service_name_pascal }}/
│       ├── LibError.swift        # エラー型
│       ├── Config.swift          # 設定型 + validate()
│       └── Client.swift          # actor クライアント
├── Tests/
│   └── {{ service_name_pascal }}Tests/
│       └── ClientTests.swift     # Swift Testing ユニットテスト
└── README.md
```

- Swift Package Manager（SPM）の標準ディレクトリ規約（`Sources/` / `Tests/`）に従う
- テストは Swift Testing フレームワークを使用し、`@Suite` / `@Test` / `#expect` で記述する
- Formatter は `swift-format` を使用する

## 9. Python ライブラリテンプレート

### 9.1 pyproject.toml

```toml
[project]
name = "k1s0-{{ service_name }}"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/k1s0_{{ module_name }}"]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
fail_under = 85
```

- `hatchling` をビルドバックエンドとして使用し、`src/` レイアウトで `k1s0_{{ module_name }}` パッケージを公開する
- Python 3.12 以降を最低要件とする
- テストランナーは `pytest`、静的解析は `ruff` + `mypy` を使用する

### 9.2 src/k1s0_{{ module_name }}/exceptions.py

```python
"""{{ service_name }} ライブラリの例外型定義"""
from __future__ import annotations


class {{ service_name_pascal }}Error(Exception):
    """{{ service_name }} ライブラリのエラー基底クラス。"""

    def __init__(
        self,
        code: str,
        message: str,
        cause: Exception | None = None,
    ) -> None:
        super().__init__(message)
        self.code = code
        if cause is not None:
            self.__cause__ = cause

    def __str__(self) -> str:
        return f"{self.code}: {super().__str__()}"
```

- `Exception` を継承した `{ServiceName}Error` クラスを定義する
- `code` フィールドで機械判定可能なエラーコードを保持する
- `cause` で元の例外を連鎖させ `__cause__` に設定する

### 9.3 src/k1s0_{{ module_name }}/{{ module_name }}.py

```python
"""{{ service_name }} ライブラリの実装"""
from __future__ import annotations

from .exceptions import {{ service_name_pascal }}Error


class Config:
    """ライブラリの設定クラス。"""

    def __init__(self, name: str) -> None:
        self.name = name

    def validate(self) -> None:
        """バリデーションを行う。"""
        if not self.name:
            raise {{ service_name_pascal }}Error(
                code="INVALID_CONFIG",
                message="name is required",
            )


class Client:
    """{{ service_name }} クライアント。"""

    def __init__(self, config: Config) -> None:
        self._config = config

    @property
    def name(self) -> str:
        """設定名を返す。"""
        return self._config.name
```

### 9.4 ディレクトリ構成

```
k1s0-{{ service_name }}/
├── pyproject.toml
├── README.md
├── src/
│   └── k1s0_{{ module_name }}/
│       ├── __init__.py        # パッケージ公開シンボル
│       ├── exceptions.py      # エラー型定義
│       └── {{ module_name }}.py  # 実装
└── tests/
    ├── __init__.py
    └── test_{{ module_name }}.py  # pytest ユニットテスト
```

- `src/` レイアウトにより偶発的なインポートを防ぐ
- テストランナー (`pytest`) と Linter (`ruff`、`mypy`) は `pyproject.toml` で設定する

## 10. エラー型定義仕様

ライブラリの公開 API で返すエラーは、言語ごとの慣習に従ったエラー型を定義する。

### 7.1 Go: `AppError struct`

```go
package {{ service_name | snake_case }}

import "fmt"

// AppError はライブラリの公開エラー型。
type AppError struct {
	Code    string
	Message string
	Err     error
}

// Error は error interface を実装する。
func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap は内部エラーを返す。
func (e *AppError) Unwrap() error {
	return e.Err
}
```

- `error` interface を実装し、`errors.Is` / `errors.As` に対応する
- `Code` フィールドでエラーの種別を識別可能にする

### 7.2 Rust: `#[derive(thiserror::Error)] enum LibError`

```rust
use thiserror::Error;

/// ライブラリの公開エラー型。
#[derive(Debug, Error)]
pub enum LibError {
    #[error("not found: {0}")]
    NotFound(String),

    #[error("validation error: {0}")]
    Validation(String),

    #[error("internal error: {0}")]
    Internal(#[from] anyhow::Error),
}
```

- `thiserror` を使用してエラーの `Display` / `From` を自動導出する
- バリアントでエラーの種別を型安全に区別する

### 7.3 TypeScript: `class AppError extends Error`

```typescript
export class AppError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly cause?: Error,
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

- `Error` を継承し、`code` フィールドでエラー種別を識別する
- `cause` でラップ元のエラーを保持する

### 7.4 Dart: `class AppException implements Exception`

```dart
/// ライブラリの公開例外型。
class AppException implements Exception {
  final String code;
  final String message;
  final Object? cause;

  const AppException({
    required this.code,
    required this.message,
    this.cause,
  });

  @override
  String toString() => 'AppException($code): $message';
}
```

- `Exception` を実装し、`code` フィールドでエラー種別を識別する

### 7.5 C#: `class AppException : Exception`

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

/// <summary>
/// ライブラリの公開例外型。
/// </summary>
public class AppException : Exception
{
    public string Code { get; }

    public AppException(string code, string message, Exception? innerException = null)
        : base(message, innerException)
    {
        Code = code;
    }
}
```

- `Exception` を継承し、`Code` プロパティでエラー種別を識別する
- `innerException` でラップ元のエラーを保持する

### 7.6 Swift: `enum LibError: Error, Sendable`

```swift
/// ライブラリの公開エラー型。
public enum LibError: Error, Sendable {
    case notFound(String)
    case validation(String)
    case `internal`(String)
}
```

- `Error` プロトコル準拠の `enum` でエラー種別を型安全に区別する
- `Sendable` 準拠により Swift Concurrency 環境での安全な受け渡しを保証する
- `switch` による網羅的ハンドリングを利用側に強制する

### 7.7 Python: `{ServiceName}Error(Exception)`

```python
class {{ service_name_pascal }}Error(Exception):
    """{{ service_name }} ライブラリのエラー基底クラス。"""

    def __init__(self, code: str, message: str, cause: Exception | None = None) -> None:
        super().__init__(message)
        self.code = code
        if cause is not None:
            self.__cause__ = cause

    def __str__(self) -> str:
        return f"{self.code}: {super().__str__()}"
```

- `Exception` を継承し `code` フィールドで機械判定可能なエラーコードを保持する
- `cause` で元の例外を連鎖させ Python の例外チェーン（`__cause__`）に設定する

## 11. Config.Validate() メソッド仕様

ライブラリが設定構造体を公開する場合、`Validate()` メソッドを提供して入力値の妥当性を検証する。

### 8.1 Go

```go
import "fmt"

type Config struct {
	Name    string `yaml:"name"`
	Version string `yaml:"version"`
}

// Validate は設定値を検証する。
func (c *Config) Validate() error {
	if c.Name == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "name is required"}
	}
	if c.Version == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "version is required"}
	}
	return nil
}
```

### 8.2 Rust

```rust
impl Config {
    /// 設定値を検証する。
    pub fn validate(&self) -> Result<(), LibError> {
        if self.name.is_empty() {
            return Err(LibError::Validation("name is required".to_string()));
        }
        if self.version.is_empty() {
            return Err(LibError::Validation("version is required".to_string()));
        }
        Ok(())
    }
}
```

### 8.3 TypeScript

```typescript
export interface Config {
  name: string;
  version: string;
}

export function validateConfig(config: Config): void {
  if (!config.name) {
    throw new AppError('INVALID_CONFIG', 'name is required');
  }
  if (!config.version) {
    throw new AppError('INVALID_CONFIG', 'version is required');
  }
}
```

### 8.4 Dart

```dart
class Config {
  final String name;
  final String version;

  const Config({required this.name, required this.version});

  /// 設定値を検証する。
  void validate() {
    if (name.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'name is required');
    }
    if (version.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'version is required');
    }
  }
}
```

### 8.5 C#

```csharp
namespace K1s0.System.{{ service_name | pascal_case }};

public class Config
{
    public string Name { get; init; } = string.Empty;
    public string Version { get; init; } = string.Empty;

    /// <summary>
    /// 設定値を検証する。
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrEmpty(Name))
            throw new AppException("INVALID_CONFIG", "name is required");
        if (string.IsNullOrEmpty(Version))
            throw new AppException("INVALID_CONFIG", "version is required");
    }
}
```

### 8.6 Swift

```swift
public struct Config: Sendable {
    public let name: String
    public let version: String

    public init(name: String, version: String) {
        self.name = name
        self.version = version
    }

    /// 設定値を検証する。
    public func validate() throws {
        guard !name.isEmpty else {
            throw LibError.validation("name is required")
        }
        guard !version.isEmpty else {
            throw LibError.validation("version is required")
        }
    }
}
```

### 8.7 Python

```python
class Config:
    """ライブラリの設定クラス。"""

    def __init__(self, name: str) -> None:
        self.name = name

    def validate(self) -> None:
        """バリデーションを行う。不正な値は {ServiceName}Error を送出する。"""
        if not self.name:
            raise {{ service_name_pascal }}Error(
                code="INVALID_CONFIG",
                message="name is required",
            )
```

- `validate()` は戻り値なし (`None`)、エラー時は `{ServiceName}Error` を送出する
- 呼び出し側は `try / except {ServiceName}Error` でキャッチする

## 12. テストのエラーケース仕様

各言語のエラー型に対するテストパターンを定義する。

### 9.1 Go

```go
func TestAppError_Error(t *testing.T) {
	err := &AppError{Code: "NOT_FOUND", Message: "entity not found"}
	assert.Equal(t, "NOT_FOUND: entity not found", err.Error())
}

func TestAppError_Unwrap(t *testing.T) {
	inner := fmt.Errorf("db error")
	err := &AppError{Code: "INTERNAL", Message: "failed", Err: inner}
	assert.ErrorIs(t, err, inner)
}

func TestConfig_Validate_EmptyName(t *testing.T) {
	cfg := &Config{Name: "", Version: "0.1.0"}
	err := cfg.Validate()
	assert.Error(t, err)
}
```

### 9.2 Rust

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lib_error_not_found() {
        let err = LibError::NotFound("entity".to_string());
        assert_eq!(err.to_string(), "not found: entity");
    }

    #[test]
    fn test_config_validate_empty_name() {
        let cfg = Config { name: "".to_string(), version: "0.1.0".to_string() };
        assert!(cfg.validate().is_err());
    }
}
```

### 9.3 TypeScript

```typescript
import { describe, it, expect } from 'vitest';
import { AppError } from './error';
import { validateConfig } from './config';

describe('AppError', () => {
  it('should have correct code and message', () => {
    const err = new AppError('NOT_FOUND', 'entity not found');
    expect(err.code).toBe('NOT_FOUND');
    expect(err.message).toBe('entity not found');
  });
});

describe('validateConfig', () => {
  it('should throw on empty name', () => {
    expect(() => validateConfig({ name: '', version: '0.1.0' })).toThrow(AppError);
  });
});
```

### 9.4 Dart

```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  test('AppException toString', () {
    const err = AppException(code: 'NOT_FOUND', message: 'entity not found');
    expect(err.toString(), 'AppException(NOT_FOUND): entity not found');
  });

  test('Config.validate throws on empty name', () {
    const cfg = Config(name: '', version: '0.1.0');
    expect(() => cfg.validate(), throwsA(isA<AppException>()));
  });
}
```

### 9.5 C#

```csharp
using Xunit;

namespace K1s0.System.{{ service_name | pascal_case }}.Tests;

public class AppExceptionTests
{
    [Fact]
    public void Should_Have_Correct_Code_And_Message()
    {
        var ex = new AppException("NOT_FOUND", "entity not found");
        Assert.Equal("NOT_FOUND", ex.Code);
        Assert.Equal("entity not found", ex.Message);
    }
}

public class ConfigTests
{
    [Fact]
    public void Validate_Should_Throw_On_Empty_Name()
    {
        var cfg = new Config { Name = "", Version = "0.1.0" };
        Assert.Throws<AppException>(() => cfg.Validate());
    }
}
```

### 9.6 Swift

```swift
import Testing
@testable import {{ service_name_pascal }}

@Suite("LibError Tests")
struct LibErrorTests {
    @Test("not found エラーのメッセージが正しい")
    func notFoundErrorDescription() {
        let error = LibError.notFound("entity")
        #expect(error.description == "not found: entity")
    }
}

@Suite("Config Tests")
struct ConfigTests {
    @Test("空の name で validation エラーが throw される")
    func validateEmptyNameThrows() throws {
        let config = Config(name: "", version: "0.1.0")
        #expect(throws: LibError.self) {
            try config.validate()
        }
    }
}
```

### 9.7 Python

```python
import pytest
from k1s0_{{ service_name | snake_case }} import Client, Config
from k1s0_{{ service_name | snake_case }}.exceptions import {{ service_name_pascal }}Error


def test_error_code_and_message() -> None:
    """エラーコードとメッセージが正しく設定される。"""
    error = {{ service_name_pascal }}Error(code="NOT_FOUND", message="entity not found")
    assert error.code == "NOT_FOUND"
    assert "NOT_FOUND" in str(error)
    assert "entity not found" in str(error)


def test_config_validate_raises_on_empty_name() -> None:
    """空の name で {ServiceName}Error が送出される。"""
    config = Config(name="")
    with pytest.raises({{ service_name_pascal }}Error) as exc_info:
        config.validate()
    assert exc_info.value.code == "INVALID_CONFIG"
```

## 13. 共通ガイドライン

### 依存の最小化

ライブラリは他のサーバー・クライアントから依存されるため、依存モジュールを最小限に保つ。不要な依存は利用側のビルド時間・バイナリサイズに直接影響する。

### 公開 API の明示

- Go: パッケージレベルのエクスポート（大文字始まりの識別子）
- Rust: `pub` キーワードによるエクスポート
- TypeScript: `export` によるエクスポート + `index.ts` でのバレルエクスポート
- Dart: `export` 宣言によるエクスポート + `library` ディレクティブ
- C#: `public` アクセス修飾子によるエクスポート + 名前空間による整理
- Swift: `public` アクセス修飾子によるエクスポート（SPM のターゲット境界で制御）
- Python: `src/` レイアウト + `__init__.py` でのバレルエクスポート

### 実装の隠蔽

| 言語 | 隠蔽手段 |
| --- | --- |
| Go | `internal/` パッケージ |
| Rust | `pub` なしのモジュール内アイテム |
| TypeScript | `src/` 内のモジュール（`index.ts` でエクスポートしないもの） |
| Dart | `lib/src/` 配下（`lib/` 直下のエントリポイントでエクスポートしないもの） |
| C# | `internal` アクセス修飾子によるアセンブリ外からのアクセス禁止 |
| Swift | `internal`（デフォルト）アクセス修飾子による SPM ターゲット外からのアクセス禁止 |

### バージョニング

ライブラリのバージョニングは **SemVer**（Semantic Versioning）に従う。

| バージョン | 変更内容 |
| --- | --- |
| MAJOR（x.0.0） | 後方互換性のない API 変更 |
| MINOR（0.x.0） | 後方互換性のある機能追加 |
| PATCH（0.0.x） | バグ修正 |

初期バージョンは `0.1.0` から開始し、安定版リリース時に `1.0.0` へ昇格する。

## 14. 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) --- 変数置換・条件分岐の仕様
- [テンプレート仕様-サーバー](テンプレート仕様-サーバー.md) --- サーバーテンプレート
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) --- クライアントテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) --- データベーステンプレート
- [CLIフロー](CLIフロー.md) --- CLI の対話フロー
- [ディレクトリ構成図](ディレクトリ構成図.md) --- 生成先ディレクトリ構成
- [コーディング規約](コーディング規約.md) --- Linter・テストツール
- [tier-architecture](tier-architecture.md) --- Tier 依存ルール
