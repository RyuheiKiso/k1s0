# テンプレート仕様 — ライブラリ

## 1. 概要

ライブラリテンプレートは、k1s0 プロジェクトにおいて **他のサーバー・クライアントから依存される共有コード** のひな形を生成するためのテンプレートである。

### 対象言語

| 言語 | 主な用途 |
| --- | --- |
| Go | サーバー間で共有するロジック・型定義 |
| Rust | サーバー間で共有するロジック・型定義 |
| TypeScript | React クライアント間で共有するロジック・型定義 |
| Dart | Flutter クライアント間で共有するロジック・型定義 |

### 配置 Tier

ライブラリは **system** と **business** の2階層にのみ配置する。**service 層にはライブラリを置かない**。

- service は独立してデプロイ・稼働する最小単位であり、サービス間でコードを直接共有しない
- 複数サービスで共通化すべきコードが発生した場合は、上位層（business または system）の library に昇格させる

## 2. Tier 別配置パス

| Tier | パス |
| --- | --- |
| system | `regions/system/library/{lang}/{{ service_name }}/` |
| business | `regions/business/{domain}/library/{lang}/{{ service_name }}/` |

`{lang}` は言語識別子（`go` / `rust` / `ts` / `dart` ）、`{domain}` は業務領域名（例: `accounting`, `fa`）を表す。

## 3. Go ライブラリテンプレート

### 3.1 go.mod

```go
module {{ go_module }}

go 1.23
```

ライブラリは必要最小限の依存にとどめる。外部モジュールへの依存は利用側が管理できるよう慎重に追加すること。

### 3.2 {{ service_name }}.go（公開パッケージ）

```go
// Package {{ service_name | snake_case }} は {{ service_name }} ライブラリの公開 API を提供する。
package {{ service_name | snake_case }}

// TODO: 公開 API の型定義・関数シグネチャを実装する
```

パッケージ宣言と公開 API のスケルトン（型定義、関数シグネチャ）を配置する。

### 3.3 internal/internal.go

```go
// Package internal は {{ service_name }} ライブラリの非公開実装を提供する。
package internal

// TODO: 非公開の実装を記述する
```

Go の `internal` パッケージにより、外部からのアクセスをコンパイル時に禁止する。

### 3.4 ディレクトリ構成

```
{{ service_name }}/
├── go.mod
├── {{ service_name }}.go         # 公開API
├── {{ service_name }}_test.go    # ユニットテスト（Go慣習: 同一パッケージ）
├── internal/
│   └── internal.go               # 非公開実装
├── tests/
│   └── integration_test.go       # 統合テスト
└── README.md
```

- ユニットテストは Go の慣習に従い、同一パッケージ内に `_test.go` ファイルとして配置する
- 統合テストは `tests/` ディレクトリに分離する
- テストには [testify](https://github.com/stretchr/testify) と [gomock](https://github.com/uber-go/mock) を使用する

## 4. Rust ライブラリテンプレート

### 4.1 Cargo.toml

```toml
[package]
name = "{{ service_name }}"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1", features = ["derive"] }
thiserror = "2"

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }
```

- `serde`: シリアライズ / デシリアライズ（ライブラリの型を外部に公開する際に必要）
- `thiserror`: エラー型の定義
- `mockall`: モックの自動生成（テスト用）
- `tokio`: 非同期テストランタイム（テスト用）

### 4.2 src/lib.rs

```rust
//! {{ service_name }} ライブラリ

pub mod {{ service_name | snake_case }};

// TODO: 公開 API を定義する
```

`pub mod` 宣言によりモジュールを公開する。ライブラリのエントリポイントとして機能する。

### 4.3 src/{{ service_name | snake_case }}.rs

```rust
//! {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_placeholder() {
        // TODO: ユニットテストを実装する
    }
}
```

モジュール実装のスケルトン。Rust の慣習に従い、`#[cfg(test)]` でユニットテストを同一ファイル内に記述する。

### 4.4 ディレクトリ構成

```
{{ service_name }}/
├── Cargo.toml
├── src/
│   ├── lib.rs                        # pub mod + 公開API
│   └── {{ service_name | snake_case }}.rs  # モジュール実装 + #[cfg(test)] ユニットテスト
├── tests/
│   └── integration_test.rs           # 統合テスト
└── README.md
```

- ユニットテストは `#[cfg(test)]` でモジュール内に記述する
- 統合テストは `tests/` ディレクトリに配置する（Cargo の規約に準拠）
- Linter / Formatter は `rustfmt` + `clippy` を使用する

## 5. TypeScript ライブラリテンプレート

### 5.1 package.json

```json
{
  "name": "{{ service_name }}",
  "version": "0.1.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src/",
    "format": "prettier --write src/"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vitest": "^3.0.0",
    "eslint": "^9.0.0",
    "prettier": "^3.0.0"
  }
}
```

- ライブラリとして `main` と `types` を明示し、型定義を公開する
- テストには Vitest を使用する
- Linter / Formatter は ESLint + Prettier を使用する

### 5.2 tsconfig.json

```json
{
  "compilerOptions": {
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "target": "ES2022",
    "paths": {}
  },
  "include": ["src"]
}
```

- `strict: true` で型安全性を担保する
- `declaration: true` で `.d.ts` ファイルを自動生成し、利用側に型情報を提供する

### 5.3 src/index.ts

```typescript
/**
 * {{ service_name }} ライブラリのエントリポイント
 */

// TODO: 公開 API をエクスポートする
// export { SomeType } from './some-module';
```

エクスポートのエントリポイント。利用側は `import { ... } from '{{ service_name }}'` でアクセスする。

### 5.4 ディレクトリ構成

```
{{ service_name }}/
├── package.json
├── tsconfig.json
├── src/
│   └── index.ts              # エクスポートエントリポイント
├── tests/
│   └── index.test.ts         # テスト
└── README.md
```

- テストは `tests/` ディレクトリに配置する
- テストには Vitest を使用する

## 6. Dart ライブラリテンプレート

### 6.1 pubspec.yaml

```yaml
name: {{ service_name | snake_case }}
version: 0.1.0
description: {{ service_name }} ライブラリ

environment:
  sdk: ">=3.0.0 <4.0.0"

dependencies: {}

dev_dependencies:
  flutter_test:
    sdk: flutter
  mocktail: ^1.0.0
```

- `name` は Dart の慣習に従い snake_case とする
- テストには `flutter_test` と `mocktail` を使用する

### 6.2 lib/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name }} ライブラリのエントリポイント
library {{ service_name | snake_case }};

// TODO: 公開 API をエクスポートする
// export 'src/some_module.dart';
```

ライブラリエントリポイント。`export` 宣言で公開 API を明示する。

### 6.3 lib/src/{{ service_name | snake_case }}.dart

```dart
/// {{ service_name | snake_case }} モジュールの実装

// TODO: モジュール実装を記述する
```

`lib/src/` 配下に実装を隠蔽する。利用側はエントリポイント経由でのみアクセスする。

### 6.4 ディレクトリ構成

```
{{ service_name }}/
├── pubspec.yaml
├── analysis_options.yaml
├── lib/
│   ├── {{ service_name | snake_case }}.dart   # エクスポートエントリポイント
│   └── src/
│       └── {{ service_name | snake_case }}.dart  # モジュール実装
├── test/                                       # Flutter/Dart 慣習: test/（tests/ ではない）
│   └── {{ service_name | snake_case }}_test.dart
└── README.md
```

- テストディレクトリは Flutter / Dart の慣習に従い `test/`（`tests/` ではない）を使用する
- Linter / Formatter は `dart analyze` + `dart format` を使用する

## 8. Python ライブラリテンプレート

### 9.1 pyproject.toml

```toml
[project]
name = "k1s0-{{ service_name }}"
version = "0.1.0"
requires-python = ">=3.12"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/k1s0_{{ module_name }}"]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.coverage.run]
source = ["src"]
branch = true

[tool.coverage.report]
fail_under = 85
```

- `hatchling` をビルドバックエンドとして使用し、`src/` レイアウトで `k1s0_{{ module_name }}` パッケージを公開する
- Python 3.12 以降を最低要件とする
- テストランナーは `pytest`、静的解析は `ruff` + `mypy` を使用する

### 9.2 src/k1s0_{{ module_name }}/exceptions.py

```python
"""{{ service_name }} ライブラリの例外型定義"""
from __future__ import annotations


class {{ service_name_pascal }}Error(Exception):
    """{{ service_name }} ライブラリのエラー基底クラス。"""

    def __init__(
        self,
        code: str,
        message: str,
        cause: Exception | None = None,
    ) -> None:
        super().__init__(message)
        self.code = code
        if cause is not None:
            self.__cause__ = cause

    def __str__(self) -> str:
        return f"{self.code}: {super().__str__()}"
```

- `Exception` を継承した `{ServiceName}Error` クラスを定義する
- `code` フィールドで機械判定可能なエラーコードを保持する
- `cause` で元の例外を連鎖させ `__cause__` に設定する

### 9.3 src/k1s0_{{ module_name }}/{{ module_name }}.py

```python
"""{{ service_name }} ライブラリの実装"""
from __future__ import annotations

from .exceptions import {{ service_name_pascal }}Error


class Config:
    """ライブラリの設定クラス。"""

    def __init__(self, name: str) -> None:
        self.name = name

    def validate(self) -> None:
        """バリデーションを行う。"""
        if not self.name:
            raise {{ service_name_pascal }}Error(
                code="INVALID_CONFIG",
                message="name is required",
            )


class Client:
    """{{ service_name }} クライアント。"""

    def __init__(self, config: Config) -> None:
        self._config = config

    @property
    def name(self) -> str:
        """設定名を返す。"""
        return self._config.name
```

### 9.4 ディレクトリ構成

```
k1s0-{{ service_name }}/
├── pyproject.toml
├── README.md
├── src/
│   └── k1s0_{{ module_name }}/
│       ├── __init__.py        # パッケージ公開シンボル
│       ├── exceptions.py      # エラー型定義
│       └── {{ module_name }}.py  # 実装
└── tests/
    ├── __init__.py
    └── test_{{ module_name }}.py  # pytest ユニットテスト
```

- `src/` レイアウトにより偶発的なインポートを防ぐ
- テストランナー (`pytest`) と Linter (`ruff`、`mypy`) は `pyproject.toml` で設定する

## 9. エラー型定義仕様

ライブラリの公開 API で返すエラーは、言語ごとの慣習に従ったエラー型を定義する。

### 7.1 Go: `AppError struct`

```go
package {{ service_name | snake_case }}

import "fmt"

// AppError はライブラリの公開エラー型。
type AppError struct {
	Code    string
	Message string
	Err     error
}

// Error は error interface を実装する。
func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap は内部エラーを返す。
func (e *AppError) Unwrap() error {
	return e.Err
}
```

- `error` interface を実装し、`errors.Is` / `errors.As` に対応する
- `Code` フィールドでエラーの種別を識別可能にする

### 7.2 Rust: `#[derive(thiserror::Error)] enum LibError`

```rust
use thiserror::Error;

/// ライブラリの公開エラー型。
#[derive(Debug, Error)]
pub enum LibError {
    #[error("not found: {0}")]
    NotFound(String),

    #[error("validation error: {0}")]
    Validation(String),

    #[error("internal error: {0}")]
    Internal(#[from] anyhow::Error),
}
```

- `thiserror` を使用してエラーの `Display` / `From` を自動導出する
- バリアントでエラーの種別を型安全に区別する

### 7.3 TypeScript: `class AppError extends Error`

```typescript
export class AppError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly cause?: Error,
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

- `Error` を継承し、`code` フィールドでエラー種別を識別する
- `cause` でラップ元のエラーを保持する

### 7.4 Dart: `class AppException implements Exception`

```dart
/// ライブラリの公開例外型。
class AppException implements Exception {
  final String code;
  final String message;
  final Object? cause;

  const AppException({
    required this.code,
    required this.message,
    this.cause,
  });

  @override
  String toString() => 'AppException($code): $message';
}
```

- `Exception` を実装し、`code` フィールドでエラー種別を識別する

### 7.6 Python: `{ServiceName}Error(Exception)`

```python
class {{ service_name_pascal }}Error(Exception):
    """{{ service_name }} ライブラリのエラー基底クラス。"""

    def __init__(self, code: str, message: str, cause: Exception | None = None) -> None:
        super().__init__(message)
        self.code = code
        if cause is not None:
            self.__cause__ = cause

    def __str__(self) -> str:
        return f"{self.code}: {super().__str__()}"
```

- `Exception` を継承し `code` フィールドで機械判定可能なエラーコードを保持する
- `cause` で元の例外を連鎖させ Python の例外チェーン（`__cause__`）に設定する

## 10. Config.Validate() メソッド仕様

ライブラリが設定構造体を公開する場合、`Validate()` メソッドを提供して入力値の妥当性を検証する。

### 8.1 Go

```go
import "fmt"

type Config struct {
	Name    string `yaml:"name"`
	Version string `yaml:"version"`
}

// Validate は設定値を検証する。
func (c *Config) Validate() error {
	if c.Name == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "name is required"}
	}
	if c.Version == "" {
		return &AppError{Code: "INVALID_CONFIG", Message: "version is required"}
	}
	return nil
}
```

### 8.2 Rust

```rust
impl Config {
    /// 設定値を検証する。
    pub fn validate(&self) -> Result<(), LibError> {
        if self.name.is_empty() {
            return Err(LibError::Validation("name is required".to_string()));
        }
        if self.version.is_empty() {
            return Err(LibError::Validation("version is required".to_string()));
        }
        Ok(())
    }
}
```

### 8.3 TypeScript

```typescript
export interface Config {
  name: string;
  version: string;
}

export function validateConfig(config: Config): void {
  if (!config.name) {
    throw new AppError('INVALID_CONFIG', 'name is required');
  }
  if (!config.version) {
    throw new AppError('INVALID_CONFIG', 'version is required');
  }
}
```

### 8.4 Dart

```dart
class Config {
  final String name;
  final String version;

  const Config({required this.name, required this.version});

  /// 設定値を検証する。
  void validate() {
    if (name.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'name is required');
    }
    if (version.isEmpty) {
      throw const AppException(code: 'INVALID_CONFIG', message: 'version is required');
    }
  }
}
```

### 8.6 Python

```python
class Config:
    """ライブラリの設定クラス。"""

    def __init__(self, name: str) -> None:
        self.name = name

    def validate(self) -> None:
        """バリデーションを行う。不正な値は {ServiceName}Error を送出する。"""
        if not self.name:
            raise {{ service_name_pascal }}Error(
                code="INVALID_CONFIG",
                message="name is required",
            )
```

- `validate()` は戻り値なし (`None`)、エラー時は `{ServiceName}Error` を送出する
- 呼び出し側は `try / except {ServiceName}Error` でキャッチする

## 11. テストのエラーケース仕様

各言語のエラー型に対するテストパターンを定義する。

### 9.1 Go

```go
func TestAppError_Error(t *testing.T) {
	err := &AppError{Code: "NOT_FOUND", Message: "entity not found"}
	assert.Equal(t, "NOT_FOUND: entity not found", err.Error())
}

func TestAppError_Unwrap(t *testing.T) {
	inner := fmt.Errorf("db error")
	err := &AppError{Code: "INTERNAL", Message: "failed", Err: inner}
	assert.ErrorIs(t, err, inner)
}

func TestConfig_Validate_EmptyName(t *testing.T) {
	cfg := &Config{Name: "", Version: "0.1.0"}
	err := cfg.Validate()
	assert.Error(t, err)
}
```

### 9.2 Rust

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lib_error_not_found() {
        let err = LibError::NotFound("entity".to_string());
        assert_eq!(err.to_string(), "not found: entity");
    }

    #[test]
    fn test_config_validate_empty_name() {
        let cfg = Config { name: "".to_string(), version: "0.1.0".to_string() };
        assert!(cfg.validate().is_err());
    }
}
```

### 9.3 TypeScript

```typescript
import { describe, it, expect } from 'vitest';
import { AppError } from './error';
import { validateConfig } from './config';

describe('AppError', () => {
  it('should have correct code and message', () => {
    const err = new AppError('NOT_FOUND', 'entity not found');
    expect(err.code).toBe('NOT_FOUND');
    expect(err.message).toBe('entity not found');
  });
});

describe('validateConfig', () => {
  it('should throw on empty name', () => {
    expect(() => validateConfig({ name: '', version: '0.1.0' })).toThrow(AppError);
  });
});
```

### 9.4 Dart

```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  test('AppException toString', () {
    const err = AppException(code: 'NOT_FOUND', message: 'entity not found');
    expect(err.toString(), 'AppException(NOT_FOUND): entity not found');
  });

  test('Config.validate throws on empty name', () {
    const cfg = Config(name: '', version: '0.1.0');
    expect(() => cfg.validate(), throwsA(isA<AppException>()));
  });
}
```

### 9.6 Python

```python
import pytest
from k1s0_{{ service_name | snake_case }} import Client, Config
from k1s0_{{ service_name | snake_case }}.exceptions import {{ service_name_pascal }}Error


def test_error_code_and_message() -> None:
    """エラーコードとメッセージが正しく設定される。"""
    error = {{ service_name_pascal }}Error(code="NOT_FOUND", message="entity not found")
    assert error.code == "NOT_FOUND"
    assert "NOT_FOUND" in str(error)
    assert "entity not found" in str(error)


def test_config_validate_raises_on_empty_name() -> None:
    """空の name で {ServiceName}Error が送出される。"""
    config = Config(name="")
    with pytest.raises({{ service_name_pascal }}Error) as exc_info:
        config.validate()
    assert exc_info.value.code == "INVALID_CONFIG"
```

## 12. 共通ガイドライン

### 依存の最小化

ライブラリは他のサーバー・クライアントから依存されるため、依存モジュールを最小限に保つ。不要な依存は利用側のビルド時間・バイナリサイズに直接影響する。

### 公開 API の明示

- Go: パッケージレベルのエクスポート（大文字始まりの識別子）
- Rust: `pub` キーワードによるエクスポート
- TypeScript: `export` によるエクスポート + `index.ts` でのバレルエクスポート
- Dart: `export` 宣言によるエクスポート + `library` ディレクティブ
- Python: `src/` レイアウト + `__init__.py` でのバレルエクスポート

### 実装の隠蔽

| 言語 | 隠蔽手段 |
| --- | --- |
| Go | `internal/` パッケージ |
| Rust | `pub` なしのモジュール内アイテム |
| TypeScript | `src/` 内のモジュール（`index.ts` でエクスポートしないもの） |
| Dart | `lib/src/` 配下（`lib/` 直下のエントリポイントでエクスポートしないもの） |

### バージョニング

ライブラリのバージョニングは **SemVer**（Semantic Versioning）に従う。

| バージョン | 変更内容 |
| --- | --- |
| MAJOR（x.0.0） | 後方互換性のない API 変更 |
| MINOR（0.x.0） | 後方互換性のある機能追加 |
| PATCH（0.0.x） | バグ修正 |

初期バージョンは `0.1.0` から開始し、安定版リリース時に `1.0.0` へ昇格する。

## 13. 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) --- 変数置換・条件分岐の仕様
- [テンプレート仕様-サーバー](テンプレート仕様-サーバー.md) --- サーバーテンプレート
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) --- クライアントテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) --- データベーステンプレート
- [CLIフロー](CLIフロー.md) --- CLI の対話フロー
- [ディレクトリ構成図](ディレクトリ構成図.md) --- 生成先ディレクトリ構成
- [コーディング規約](コーディング規約.md) --- Linter・テストツール
- [tier-architecture](tier-architecture.md) --- Tier 依存ルール
