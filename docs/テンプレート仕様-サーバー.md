# テンプレート仕様 — サーバー

## 概要

本ドキュメントは、k1s0 CLI の「ひな形生成」機能でサーバーを選択した際に生成される **全ファイルのスケルトンコード** を定義する。対象フレームワークは **Go (gin)** と **Rust (axum + tokio)** の2つ。

両言語ともクリーンアーキテクチャに基づく4レイヤー構成を採用する。

```
domain（エンティティ・リポジトリインターフェース）
  ↑
usecase（ビジネスロジック）
  ↑
adapter（ハンドラー・プレゼンター）
  ↑
infra（DB接続・メッセージング・設定ローダー）
```

## 条件付き生成表

CLI の対話フローで選択されたオプションに応じて、生成されるファイルが変わる。

| 条件                      | 選択肢                            | 影響を受けるファイル                                    |
| ------------------------- | --------------------------------- | ------------------------------------------------------- |
| API 方式 (`api_style`)    | `rest`                            | handler/rest, OpenAPI 定義, oapi-codegen 設定           |
|                           | `grpc`                            | handler/grpc, proto 定義, buf 設定                      |
|                           | `graphql`                         | handler/graphql, スキーマ定義                           |
| DB 有無 (`has_database`)  | `true`                            | persistence, config 内 database セクション, migrations/ |
|                           | `false`                           | 上記を生成しない                                        |
| DB 種別 (`database_type`) | `postgresql` / `mysql` / `sqlite` | sqlx ドライバ依存、接続文字列形式                       |
| Kafka 有無 (`has_kafka`)  | `true`                            | messaging, config 内 kafka セクション                   |
|                           | `false`                           | 上記を生成しない                                        |
| Redis 有無 (`has_redis`)  | `true`                            | config 内 redis セクション                              |
|                           | `false`                           | 上記を生成しない                                        |

## Tier 別配置パス

| Tier     | 配置パス                                                  |
| -------- | --------------------------------------------------------- |
| system   | `regions/system/server/{lang}/{service_name}/`            |
| business | `regions/business/{domain}/server/{lang}/{service_name}/` |
| service  | `regions/service/{service_name}/server/{lang}/`           |

Tera テンプレート内では `{{ module_path }}` で解決される。

---

## Go (gin) テンプレート

### go.mod

`go.mod.tera` — モジュール定義と依存関係。

```go
module {{ go_module }}

go 1.23

require (
	github.com/gin-gonic/gin v1.10.0
	go.opentelemetry.io/otel v1.31.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.31.0
	go.opentelemetry.io/otel/sdk v1.31.0
	go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin v0.56.0
	github.com/go-playground/validator/v10 v10.22.1
	gopkg.in/yaml.v3 v3.0.1
{% if api_style == "rest" %}
	github.com/oapi-codegen/oapi-codegen/v2 v2.4.1
	github.com/oapi-codegen/runtime v1.1.1
{% endif %}
{% if api_style == "grpc" %}
	google.golang.org/grpc v1.68.0
	google.golang.org/protobuf v1.35.2
{% endif %}
{% if api_style == "graphql" %}
	github.com/99designs/gqlgen v0.17.55
	github.com/vektah/gqlparser/v2 v2.5.19
{% endif %}
{% if has_database %}
	github.com/jmoiron/sqlx v1.4.0
{% endif %}
{% if has_database and database_type == "postgresql" %}
	github.com/lib/pq v1.10.9
{% endif %}
{% if has_database and database_type == "mysql" %}
	github.com/go-sql-driver/mysql v1.8.1
{% endif %}
{% if has_database and database_type == "sqlite" %}
	github.com/mattn/go-sqlite3 v1.14.24
{% endif %}
{% if has_kafka %}
	github.com/segmentio/kafka-go v0.4.47
{% endif %}
{% if has_redis %}
	github.com/redis/go-redis/v9 v9.7.0
{% endif %}
)
```

### cmd/main.go

`cmd/main.go.tera` — エントリポイント。gin ルーター初期化、ミドルウェア登録、graceful shutdown。

```go
package main

import (
	"context"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"

	"{{ go_module }}/internal/adapter/handler"
	"{{ go_module }}/internal/infra/config"
{% if has_database %}
	"{{ go_module }}/internal/infra/persistence"
{% endif %}
{% if has_kafka %}
	"{{ go_module }}/internal/infra/messaging"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

func main() {
	// --- Config ---
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		slog.Error("failed to load config", "error", err)
		os.Exit(1)
	}

	// --- Logger ---
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))
	slog.SetDefault(logger)

{% if has_database %}
	// --- Database ---
	db, err := persistence.NewDB(cfg.Database)
	if err != nil {
		slog.Error("failed to connect database", "error", err)
		os.Exit(1)
	}
	defer db.Close()
{% endif %}

{% if has_kafka %}
	// --- Kafka ---
	producer := messaging.NewProducer(cfg.Kafka)
	defer producer.Close()
{% endif %}

	// --- DI: Repository → UseCase → Handler ---
{% if has_database %}
	repo := persistence.NewRepository(db)
{% endif %}
	uc := usecase.New{{ service_name_pascal }}UseCase(
{% if has_database %}
		repo,
{% endif %}
	)
	h := handler.NewHandler(uc)

	// --- Router ---
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(otelgin.Middleware("{{ service_name }}"))

	// ヘルスチェック
	r.GET("/healthz", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})
	r.GET("/readyz", func(c *gin.Context) {
{% if has_database %}
		if err := db.PingContext(c.Request.Context()); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"status": "not ready", "error": err.Error()})
			return
		}
{% endif %}
		c.JSON(http.StatusOK, gin.H{"status": "ready"})
	})

	// API ルート登録
	h.RegisterRoutes(r)

	// --- Server ---
	srv := &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: r,
	}

	go func() {
		slog.Info("server starting", "port", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("server failed", "error", err)
			os.Exit(1)
		}
	}()

	// --- Graceful Shutdown ---
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	slog.Info("shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		slog.Error("server forced to shutdown", "error", err)
	}
	slog.Info("server exited")
}
```

### internal/domain/model/entity.go

`internal/domain/model/entity.go.tera` — ドメインエンティティ。

```go
package model

import "time"

// {{ service_name_pascal }}Entity はドメインエンティティを表す。
type {{ service_name_pascal }}Entity struct {
	ID          string    `json:"id" db:"id"`
	Name        string    `json:"name" db:"name" validate:"required,max=255"`
	Description string    `json:"description,omitempty" db:"description"`
	Status      string    `json:"status" db:"status"`
	CreatedAt   time.Time `json:"created_at" db:"created_at"`
	UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}
```

### internal/domain/repository/repository.go

`internal/domain/repository/repository.go.tera` — リポジトリインターフェース。

```go
package repository

//go:generate mockgen -source=repository.go -destination=mock_repository.go -package=repository

import (
	"context"

	"{{ go_module }}/internal/domain/model"
)

// {{ service_name_pascal }}Repository はデータアクセスの抽象化インターフェース。
type {{ service_name_pascal }}Repository interface {
	FindByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error)
	FindAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error)
	Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error
	Update(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error
	Delete(ctx context.Context, id string) error
}
```

### internal/usecase/usecase.go

`internal/usecase/usecase.go.tera` — ユースケース（DI パターン）。

```go
package usecase

import (
	"context"

	"{{ go_module }}/internal/domain/model"
{% if has_database %}
	"{{ go_module }}/internal/domain/repository"
{% endif %}
)

// {{ service_name_pascal }}UseCase はビジネスロジックを提供する。
type {{ service_name_pascal }}UseCase struct {
{% if has_database %}
	repo repository.{{ service_name_pascal }}Repository
{% endif %}
}

// New{{ service_name_pascal }}UseCase はユースケースを生成する。
func New{{ service_name_pascal }}UseCase(
{% if has_database %}
	repo repository.{{ service_name_pascal }}Repository,
{% endif %}
) *{{ service_name_pascal }}UseCase {
	return &{{ service_name_pascal }}UseCase{
{% if has_database %}
		repo: repo,
{% endif %}
	}
}

// GetByID は ID を指定してエンティティを取得する。
func (uc *{{ service_name_pascal }}UseCase) GetByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
{% if has_database %}
	return uc.repo.FindByID(ctx, id)
{% else %}
	// TODO: 実装
	return nil, nil
{% endif %}
}

// GetAll は全エンティティを取得する。
func (uc *{{ service_name_pascal }}UseCase) GetAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
{% if has_database %}
	return uc.repo.FindAll(ctx)
{% else %}
	// TODO: 実装
	return nil, nil
{% endif %}
}

// Create はエンティティを新規作成する。
func (uc *{{ service_name_pascal }}UseCase) Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
{% if has_database %}
	return uc.repo.Create(ctx, entity)
{% else %}
	// TODO: 実装
	return nil
{% endif %}
}
```

### internal/adapter/handler/ — REST (gin)

`internal/adapter/handler/rest_handler.go.tera` — {% if api_style == "rest" %} に該当。[API設計.md](API設計.md) D-007 エラーレスポンスパターンに従う。

```go
{% if api_style == "rest" %}
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"

	"{{ go_module }}/internal/usecase"
)

var validate = validator.New()

// Handler は REST API ハンドラーを提供する。
type Handler struct {
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewHandler はハンドラーを生成する。
func NewHandler(uc *usecase.{{ service_name_pascal }}UseCase) *Handler {
	return &Handler{uc: uc}
}

// RegisterRoutes は gin ルーターにルートを登録する。
func (h *Handler) RegisterRoutes(r *gin.Engine) {
	v1 := r.Group("/api/v1")
	{
		v1.GET("/{{ service_name }}", h.List)
		v1.GET("/{{ service_name }}/:id", h.GetByID)
		v1.POST("/{{ service_name }}", h.Create)
	}
}

// ErrorResponse は API設計.md D-007 準拠のエラーレスポンス。
type ErrorResponse struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// List は全件取得エンドポイント。
func (h *Handler) List(c *gin.Context) {
	entities, err := h.uc.GetAll(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{
			Code:    "INTERNAL_ERROR",
			Message: "Failed to retrieve resources",
		})
		return
	}
	c.JSON(http.StatusOK, entities)
}

// GetByID は ID 指定取得エンドポイント。
func (h *Handler) GetByID(c *gin.Context) {
	id := c.Param("id")
	entity, err := h.uc.GetByID(c.Request.Context(), id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{
			Code:    "INTERNAL_ERROR",
			Message: "Failed to retrieve resource",
		})
		return
	}
	if entity == nil {
		c.JSON(http.StatusNotFound, ErrorResponse{
			Code:    "NOT_FOUND",
			Message: "Resource not found",
		})
		return
	}
	c.JSON(http.StatusOK, entity)
}

// CreateRequest は作成リクエストボディ。
type CreateRequest struct {
	Name        string `json:"name" validate:"required,max=255"`
	Description string `json:"description"`
}

// Create は新規作成エンドポイント。
func (h *Handler) Create(c *gin.Context) {
	var req CreateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			Code:    "INVALID_REQUEST",
			Message: "Invalid request body",
		})
		return
	}
	if err := validate.Struct(req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			Code:    "VALIDATION_ERROR",
			Message: err.Error(),
		})
		return
	}
	// TODO: req → entity 変換、uc.Create 呼び出し
	c.JSON(http.StatusCreated, gin.H{"status": "created"})
}
{% endif %}
```

### internal/adapter/handler/ — gRPC

`internal/adapter/handler/grpc_handler.go.tera` — {% if api_style == "grpc" %} に該当。

```go
{% if api_style == "grpc" %}
package handler

import (
	"context"

	pb "{{ go_module }}/api/proto/gen"
	"{{ go_module }}/internal/usecase"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// GRPCHandler は gRPC サービス実装。
type GRPCHandler struct {
	pb.Unimplemented{{ service_name_pascal }}ServiceServer
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewGRPCHandler はハンドラーを生成する。
func NewGRPCHandler(uc *usecase.{{ service_name_pascal }}UseCase) *GRPCHandler {
	return &GRPCHandler{uc: uc}
}

// Get{{ service_name_pascal }} は ID 指定取得 RPC。
func (h *GRPCHandler) Get{{ service_name_pascal }}(ctx context.Context, req *pb.Get{{ service_name_pascal }}Request) (*pb.Get{{ service_name_pascal }}Response, error) {
	entity, err := h.uc.GetByID(ctx, req.GetId())
	if err != nil {
		return nil, status.Errorf(codes.Internal, "internal error: %v", err)
	}
	if entity == nil {
		return nil, status.Errorf(codes.NotFound, "resource not found: %s", req.GetId())
	}
	return &pb.Get{{ service_name_pascal }}Response{
		Id:   entity.ID,
		Name: entity.Name,
	}, nil
}
{% endif %}
```

### internal/adapter/handler/ — GraphQL

`internal/adapter/handler/graphql_resolver.go.tera` — {% if api_style == "graphql" %} に該当。gqlgen リゾルバー。

```go
{% if api_style == "graphql" %}
package handler

import (
	"context"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/usecase"
)

// Resolver は GraphQL リゾルバーのルート。
type Resolver struct {
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewResolver はリゾルバーを生成する。
func NewResolver(uc *usecase.{{ service_name_pascal }}UseCase) *Resolver {
	return &Resolver{uc: uc}
}

// Query はクエリリゾルバー。
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{r}
}

type queryResolver struct{ *Resolver }

func (r *queryResolver) {{ service_name_pascal }}(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
	return r.uc.GetByID(ctx, id)
}

func (r *queryResolver) {{ service_name_pascal }}List(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
	return r.uc.GetAll(ctx)
}
{% endif %}
```

### internal/infra/persistence/db.go

`internal/infra/persistence/db.go.tera` — {% if has_database %} に該当。sqlx による DB 接続初期化。

```go
{% if has_database %}
package persistence

import (
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
{% if database_type == "postgresql" %}
	_ "github.com/lib/pq"
{% elif database_type == "mysql" %}
	_ "github.com/go-sql-driver/mysql"
{% elif database_type == "sqlite" %}
	_ "github.com/mattn/go-sqlite3"
{% endif %}

	"{{ go_module }}/internal/infra/config"
)

// NewDB は DB 接続を初期化する。
func NewDB(cfg config.DatabaseConfig) (*sqlx.DB, error) {
	dsn := buildDSN(cfg)
{% if database_type == "postgresql" %}
	db, err := sqlx.Connect("postgres", dsn)
{% elif database_type == "mysql" %}
	db, err := sqlx.Connect("mysql", dsn)
{% elif database_type == "sqlite" %}
	db, err := sqlx.Connect("sqlite3", dsn)
{% endif %}
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	db.SetMaxOpenConns(cfg.Pool.MaxOpen)
	db.SetMaxIdleConns(cfg.Pool.MaxIdle)
	db.SetConnMaxLifetime(time.Duration(cfg.Pool.MaxLifetimeSec) * time.Second)

	return db, nil
}

func buildDSN(cfg config.DatabaseConfig) string {
{% if database_type == "postgresql" %}
	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name, cfg.SSLMode)
{% elif database_type == "mysql" %}
	return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&charset=utf8mb4",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.Name)
{% elif database_type == "sqlite" %}
	return cfg.Name
{% endif %}
}
{% endif %}
```

### internal/infra/persistence/repository.go

`internal/infra/persistence/repository.go.tera` — {% if has_database %} に該当。リポジトリ実装。

```go
{% if has_database %}
package persistence

import (
	"context"

	"github.com/jmoiron/sqlx"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/domain/repository"
)

type {{ service_name_camel }}Repository struct {
	db *sqlx.DB
}

// NewRepository はリポジトリ実装を生成する。
func NewRepository(db *sqlx.DB) repository.{{ service_name_pascal }}Repository {
	return &{{ service_name_camel }}Repository{db: db}
}

func (r *{{ service_name_camel }}Repository) FindByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
	var entity model.{{ service_name_pascal }}Entity
	err := r.db.GetContext(ctx, &entity, "SELECT * FROM examples WHERE id = $1", id)
	if err != nil {
		return nil, err
	}
	return &entity, nil
}

func (r *{{ service_name_camel }}Repository) FindAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
	var entities []*model.{{ service_name_pascal }}Entity
	err := r.db.SelectContext(ctx, &entities, "SELECT * FROM examples ORDER BY created_at DESC")
	return entities, err
}

func (r *{{ service_name_camel }}Repository) Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
	_, err := r.db.NamedExecContext(ctx,
		"INSERT INTO examples (id, name, description, status) VALUES (:id, :name, :description, :status)",
		entity)
	return err
}

func (r *{{ service_name_camel }}Repository) Update(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
	_, err := r.db.NamedExecContext(ctx,
		"UPDATE examples SET name = :name, description = :description, status = :status WHERE id = :id",
		entity)
	return err
}

func (r *{{ service_name_camel }}Repository) Delete(ctx context.Context, id string) error {
	_, err := r.db.ExecContext(ctx, "DELETE FROM examples WHERE id = $1", id)
	return err
}
{% endif %}
```

### internal/infra/messaging/kafka.go

`internal/infra/messaging/kafka.go.tera` — {% if has_kafka %} に該当。[メッセージング設計.md](メッセージング設計.md) D-119 トピック命名規則に従う。

```go
{% if has_kafka %}
package messaging

import (
	"context"
	"log/slog"

	"github.com/segmentio/kafka-go"

	"{{ go_module }}/internal/infra/config"
)

// Producer は Kafka プロデューサー。
type Producer struct {
	writer *kafka.Writer
}

// NewProducer はプロデューサーを生成する。
// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
func NewProducer(cfg config.KafkaConfig) *Producer {
	w := &kafka.Writer{
		Addr:     kafka.TCP(cfg.Brokers...),
		Balancer: &kafka.LeastBytes{},
	}
	return &Producer{writer: w}
}

// Publish はメッセージを送信する。
func (p *Producer) Publish(ctx context.Context, topic string, key, value []byte) error {
	return p.writer.WriteMessages(ctx, kafka.Message{
		Topic: topic,
		Key:   key,
		Value: value,
	})
}

// Close はプロデューサーを閉じる。
func (p *Producer) Close() {
	if err := p.writer.Close(); err != nil {
		slog.Error("failed to close kafka producer", "error", err)
	}
}

// Consumer は Kafka コンシューマー。
type Consumer struct {
	reader *kafka.Reader
}

// NewConsumer はコンシューマーを生成する。
// コンシューマーグループ命名規則: {service-name}.{purpose}
func NewConsumer(cfg config.KafkaConfig, topic, groupID string) *Consumer {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  cfg.Brokers,
		Topic:    topic,
		GroupID:  groupID,
		MinBytes: 10e3,
		MaxBytes: 10e6,
	})
	return &Consumer{reader: r}
}

// Consume はメッセージを受信する。
func (c *Consumer) Consume(ctx context.Context, handler func(kafka.Message) error) error {
	for {
		msg, err := c.reader.ReadMessage(ctx)
		if err != nil {
			return err
		}
		if err := handler(msg); err != nil {
			slog.Error("failed to handle message", "topic", msg.Topic, "error", err)
		}
	}
}

// Close はコンシューマーを閉じる。
func (c *Consumer) Close() {
	if err := c.reader.Close(); err != nil {
		slog.Error("failed to close kafka consumer", "error", err)
	}
}
{% endif %}
```

### internal/infra/config/config.go

`internal/infra/config/config.go.tera` — [config設計.md](config設計.md) 準拠の設定ローダー。

```go
package config

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// Config はアプリケーション設定の全体構造。
type Config struct {
	App    AppConfig    `yaml:"app"`
	Server ServerConfig `yaml:"server"`
{% if has_database %}
	Database DatabaseConfig `yaml:"database"`
{% endif %}
{% if has_kafka %}
	Kafka KafkaConfig `yaml:"kafka"`
{% endif %}
{% if has_redis %}
	Redis RedisConfig `yaml:"redis"`
{% endif %}
	Observability ObservabilityConfig `yaml:"observability"`
}

// AppConfig はアプリケーション基本情報。
type AppConfig struct {
	Name        string `yaml:"name"`
	Version     string `yaml:"version"`
	Environment string `yaml:"environment"`
}

// ServerConfig はサーバー設定。
type ServerConfig struct {
	Port            string `yaml:"port"`
	ReadTimeoutSec  int    `yaml:"read_timeout_sec"`
	WriteTimeoutSec int    `yaml:"write_timeout_sec"`
}

{% if has_database %}
// DatabaseConfig は DB 接続設定。
type DatabaseConfig struct {
	Host     string     `yaml:"host"`
	Port     int        `yaml:"port"`
	User     string     `yaml:"user"`
	Password string     `yaml:"password"`
	Name     string     `yaml:"name"`
	SSLMode  string     `yaml:"ssl_mode"`
	Pool     PoolConfig `yaml:"pool"`
}

// PoolConfig はコネクションプール設定。
type PoolConfig struct {
	MaxOpen        int `yaml:"max_open"`
	MaxIdle        int `yaml:"max_idle"`
	MaxLifetimeSec int `yaml:"max_lifetime_sec"`
}
{% endif %}

{% if has_kafka %}
// KafkaConfig は Kafka 接続設定。
type KafkaConfig struct {
	Brokers        []string `yaml:"brokers"`
	SchemaRegistry string   `yaml:"schema_registry"`
}
{% endif %}

{% if has_redis %}
// RedisConfig は Redis 接続設定。
type RedisConfig struct {
	Addr     string `yaml:"addr"`
	Password string `yaml:"password"`
	DB       int    `yaml:"db"`
}
{% endif %}

// ObservabilityConfig は可観測性設定。
type ObservabilityConfig struct {
	TraceEndpoint  string `yaml:"trace_endpoint"`
	MetricEndpoint string `yaml:"metric_endpoint"`
	LogLevel       string `yaml:"log_level"`
}

// Load は YAML ファイルから設定を読み込む。
func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}
	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}
	return &cfg, nil
}
```

### config/config.yaml

`config/config.yaml.tera` — [config設計.md](config設計.md) 準拠のアプリケーション設定ファイル。

```yaml
app:
  name: "{{ service_name }}"
  version: "0.1.0"
  environment: "development"

server:
  port: "8080"
  read_timeout_sec: 30
  write_timeout_sec: 30

{% if has_database %}
database:
  host: "localhost"
{% if database_type == "postgresql" %}
  port: 5432
{% elif database_type == "mysql" %}
  port: 3306
{% endif %}
  user: "{{ service_name_snake }}"
  password: ""
  name: "{{ service_name_snake }}"
{% if database_type == "postgresql" %}
  ssl_mode: "disable"
{% endif %}
  pool:
    max_open: 25
    max_idle: 5
    max_lifetime_sec: 300
{% endif %}

{% if has_kafka %}
kafka:
  brokers:
    - "localhost:9092"
  schema_registry: "http://localhost:8081"
{% endif %}

{% if has_redis %}
redis:
  addr: "localhost:6379"
  password: ""
  db: 0
{% endif %}

observability:
  trace_endpoint: "localhost:4317"
  metric_endpoint: "localhost:4317"
  log_level: "info"
```

### api/openapi/openapi.yaml

`api/openapi/openapi.yaml.tera` — {% if api_style == "rest" %} に該当。OpenAPI 3.0 定義。コード生成は [API設計.md](API設計.md) D-123 oapi-codegen に従う。

```yaml
{% if api_style == "rest" %}
openapi: "3.0.3"
info:
  title: "{{ service_name_pascal }} API"
  version: "1.0.0"
  description: "{{ service_name }} の REST API 定義"
servers:
  - url: "http://localhost:8080"
    description: "ローカル開発環境"
paths:
  /api/v1/{{ service_name }}:
    get:
      summary: "一覧取得"
      operationId: "list{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/{{ service_name_pascal }}"
    post:
      summary: "新規作成"
      operationId: "create{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Create{{ service_name_pascal }}Request"
      responses:
        "201":
          description: "作成成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "400":
          description: "バリデーションエラー"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /api/v1/{{ service_name }}/{id}:
    get:
      summary: "ID 指定取得"
      operationId: "get{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "404":
          description: "リソースが見つからない"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
components:
  schemas:
    {{ service_name_pascal }}:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        description:
          type: string
        status:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
    Create{{ service_name_pascal }}Request:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          maxLength: 255
        description:
          type: string
    ErrorResponse:
      type: object
      properties:
        code:
          type: string
        message:
          type: string
{% endif %}
```

### api/proto/service.proto

`api/proto/service.proto.tera` — {% if api_style == "grpc" %} に該当。[API設計.md](API設計.md) D-009 gRPC 定義パターンに従う。

```proto
{% if api_style == "grpc" %}
syntax = "proto3";

package {{ service_name_snake }}.v1;

option go_package = "{{ go_module }}/api/proto/gen";

// {{ service_name_pascal }}Service は {{ service_name }} の gRPC サービス定義。
service {{ service_name_pascal }}Service {
  rpc Get{{ service_name_pascal }} (Get{{ service_name_pascal }}Request) returns (Get{{ service_name_pascal }}Response);
  rpc List{{ service_name_pascal }} (List{{ service_name_pascal }}Request) returns (List{{ service_name_pascal }}Response);
  rpc Create{{ service_name_pascal }} (Create{{ service_name_pascal }}Request) returns (Create{{ service_name_pascal }}Response);
}

message Get{{ service_name_pascal }}Request {
  string id = 1;
}

message Get{{ service_name_pascal }}Response {
  string id = 1;
  string name = 2;
  string description = 3;
  string status = 4;
  string created_at = 5;
  string updated_at = 6;
}

message List{{ service_name_pascal }}Request {}

message List{{ service_name_pascal }}Response {
  repeated Get{{ service_name_pascal }}Response items = 1;
}

message Create{{ service_name_pascal }}Request {
  string name = 1;
  string description = 2;
}

message Create{{ service_name_pascal }}Response {
  string id = 1;
}
{% endif %}
```

### Dockerfile

`Dockerfile.tera` — [Dockerイメージ戦略.md](Dockerイメージ戦略.md) 準拠のマルチステージビルド。

```dockerfile
# === Build Stage ===
FROM golang:1.23-bookworm AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /app/server ./cmd/main.go

# === Runtime Stage ===
FROM gcr.io/distroless/static-debian12

COPY --from=builder /app/server /server
COPY --from=builder /app/config /config

EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/server"]
```

---

## Rust (axum + tokio) テンプレート

### Cargo.toml

`Cargo.toml.tera` — クレート定義と依存関係。

```toml
[package]
name = "{{ rust_crate }}"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_yaml = "0.9"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
opentelemetry = "0.24"
opentelemetry-otlp = "0.17"
opentelemetry_sdk = "0.24"
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace"] }
thiserror = "2"
{% if api_style == "rest" %}
utoipa = { version = "5", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "8", features = ["axum"] }
{% endif %}
{% if api_style == "grpc" %}
tonic = "0.12"
prost = "0.13"
{% endif %}
{% if api_style == "graphql" %}
async-graphql = "7"
async-graphql-axum = "7"
{% endif %}
{% if has_database %}
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "{{ database_type }}"] }
{% endif %}
{% if has_kafka %}
rdkafka = { version = "0.36", features = ["cmake-build"] }
{% endif %}
{% if has_redis %}
redis = { version = "0.27", features = ["tokio-comp"] }
{% endif %}

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }

{% if api_style == "grpc" %}
[build-dependencies]
tonic-build = "0.12"
{% endif %}
```

### src/main.rs

`src/main.rs.tera` — エントリポイント。axum Router、tower ミドルウェア、graceful shutdown。

```rust
use axum::{routing::get, Json, Router};
use serde_json::json;
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod adapter;
mod domain;
mod infra;
mod usecase;

use infra::config::Config;

#[tokio::main]
async fn main() {
    // --- Logger ---
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer().json())
        .init();

    // --- Config ---
    let config = Config::load("config/config.yaml")
        .expect("Failed to load config");

{% if has_database %}
    // --- Database ---
    let pool = infra::persistence::create_pool(&config.database)
        .await
        .expect("Failed to connect to database");
{% endif %}

{% if has_kafka %}
    // --- Kafka ---
    let producer = infra::messaging::Producer::new(&config.kafka);
{% endif %}

    // --- DI: Repository → UseCase → Handler ---
{% if has_database %}
    let repo = infra::persistence::Repository::new(pool.clone());
{% endif %}
    let uc = usecase::{{ service_name_pascal }}UseCase::new(
{% if has_database %}
        repo,
{% endif %}
    );
    let handler = adapter::handler::AppHandler::new(uc);

    // --- Router ---
    let app = Router::new()
        .route("/healthz", get(|| async { Json(json!({"status": "ok"})) }))
        .route("/readyz", get({
{% if has_database %}
            let pool = pool.clone();
{% endif %}
            move || async move {
{% if has_database %}
                match sqlx::query("SELECT 1").execute(&pool).await {
                    Ok(_) => Json(json!({"status": "ready"})),
                    Err(_) => Json(json!({"status": "not ready"})),
                }
{% else %}
                Json(json!({"status": "ready"}))
{% endif %}
            }
        }))
        .merge(handler.routes())
        .layer(TraceLayer::new_for_http())
        .layer(CorsLayer::permissive());

    // --- Server ---
    let addr: SocketAddr = format!("0.0.0.0:{}", config.server.port)
        .parse()
        .expect("Invalid address");
    tracing::info!("server starting on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr)
        .await
        .expect("Failed to bind");

    // --- Graceful Shutdown ---
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .expect("Server error");
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("Failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    tracing::info!("shutdown signal received");
}
```

### src/domain/mod.rs

`src/domain/mod.rs.tera` — ドメインモジュール宣言。

```rust
pub mod model;
pub mod repository;
```

### src/domain/model.rs

`src/domain/model.rs.tera` — エンティティ定義。

```rust
use serde::{Deserialize, Serialize};

/// {{ service_name_pascal }}Entity はドメインエンティティを表す。
#[derive(Debug, Clone, Serialize, Deserialize)]
{% if has_database %}
#[derive(sqlx::FromRow)]
{% endif %}
pub struct {{ service_name_pascal }}Entity {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub created_at: String,
    pub updated_at: String,
}
```

### src/domain/repository.rs

`src/domain/repository.rs.tera` — リポジトリ trait。

```rust
use async_trait::async_trait;

use super::model::{{ service_name_pascal }}Entity;

/// {{ service_name_pascal }}Repository はデータアクセスの抽象化 trait。
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait {{ service_name_pascal }}Repository: Send + Sync {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>>;
    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>>;
    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn delete(&self, id: &str) -> anyhow::Result<()>;
}
```

### src/usecase/mod.rs

`src/usecase/mod.rs.tera` — ユースケースモジュール。

```rust
pub mod service;

pub use service::{{ service_name_pascal }}UseCase;
```

### src/usecase/service.rs

`src/usecase/service.rs.tera` — ユースケース実装（DI パターン）。

```rust
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
{% if has_database %}
use crate::domain::repository::{{ service_name_pascal }}Repository;
{% endif %}

/// {{ service_name_pascal }}UseCase はビジネスロジックを提供する。
pub struct {{ service_name_pascal }}UseCase {
{% if has_database %}
    repo: Arc<dyn {{ service_name_pascal }}Repository>,
{% endif %}
}

impl {{ service_name_pascal }}UseCase {
    pub fn new(
{% if has_database %}
        repo: impl {{ service_name_pascal }}Repository + 'static,
{% endif %}
    ) -> Self {
        Self {
{% if has_database %}
            repo: Arc::new(repo),
{% endif %}
        }
    }

    pub async fn get_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_by_id(id).await
{% else %}
        // TODO: 実装
        Ok(None)
{% endif %}
    }

    pub async fn get_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_all().await
{% else %}
        // TODO: 実装
        Ok(vec![])
{% endif %}
    }

    pub async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
{% if has_database %}
        self.repo.create(entity).await
{% else %}
        // TODO: 実装
        Ok(())
{% endif %}
    }
}
```

### src/adapter/mod.rs

`src/adapter/mod.rs.tera` — アダプターモジュール宣言。

```rust
pub mod handler;
```

### src/adapter/handler/ — REST (axum + utoipa)

`src/adapter/handler/rest.rs.tera` — {% if api_style == "rest" %} に該当。

```rust
{% if api_style == "rest" %}
use axum::{
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

/// AppHandler は REST ハンドラーを提供する。
pub struct AppHandler {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl AppHandler {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }

    pub fn routes(&self) -> Router {
        let uc = self.uc.clone();
        Router::new()
            .route("/api/v1/{{ service_name }}", get(list).post(create))
            .route("/api/v1/{{ service_name }}/:id", get(get_by_id))
            .with_state(uc)
    }
}

/// ErrorResponse は API設計.md D-007 準拠のエラーレスポンス。
#[derive(Serialize)]
struct ErrorResponse {
    code: String,
    message: String,
}

async fn list(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
) -> Result<Json<Vec<crate::domain::model::{{ service_name_pascal }}Entity>>, StatusCode> {
    uc.get_all()
        .await
        .map(Json)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

async fn get_by_id(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Path(id): Path<String>,
) -> Result<Json<crate::domain::model::{{ service_name_pascal }}Entity>, StatusCode> {
    match uc.get_by_id(&id).await {
        Ok(Some(entity)) => Ok(Json(entity)),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

#[derive(Deserialize)]
struct CreateRequest {
    name: String,
    description: Option<String>,
}

async fn create(
    State(_uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Json(_req): Json<CreateRequest>,
) -> StatusCode {
    // TODO: req → entity 変換、uc.create 呼び出し
    StatusCode::CREATED
}
{% endif %}
```

### src/adapter/handler/ — gRPC (tonic)

`src/adapter/handler/grpc.rs.tera` — {% if api_style == "grpc" %} に該当。

```rust
{% if api_style == "grpc" %}
use tonic::{Request, Response, Status};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

pub mod proto {
    tonic::include_proto!("{{ service_name_snake }}.v1");
}

use proto::{{ service_name_snake }}_service_server::{{ service_name_pascal }}Service;
use proto::{
    Get{{ service_name_pascal }}Request, Get{{ service_name_pascal }}Response,
    List{{ service_name_pascal }}Request, List{{ service_name_pascal }}Response,
    Create{{ service_name_pascal }}Request, Create{{ service_name_pascal }}Response,
};

pub struct {{ service_name_pascal }}GrpcService {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl {{ service_name_pascal }}GrpcService {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }
}

#[tonic::async_trait]
impl {{ service_name_pascal }}Service for {{ service_name_pascal }}GrpcService {
    async fn get_{{ service_name_snake }}(
        &self,
        request: Request<Get{{ service_name_pascal }}Request>,
    ) -> Result<Response<Get{{ service_name_pascal }}Response>, Status> {
        let id = request.into_inner().id;
        match self.uc.get_by_id(&id).await {
            Ok(Some(entity)) => Ok(Response::new(Get{{ service_name_pascal }}Response {
                id: entity.id,
                name: entity.name,
                description: entity.description.unwrap_or_default(),
                status: entity.status,
                created_at: entity.created_at,
                updated_at: entity.updated_at,
            })),
            Ok(None) => Err(Status::not_found(format!("resource not found: {}", id))),
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn list_{{ service_name_snake }}(
        &self,
        _request: Request<List{{ service_name_pascal }}Request>,
    ) -> Result<Response<List{{ service_name_pascal }}Response>, Status> {
        match self.uc.get_all().await {
            Ok(entities) => {
                let items = entities.into_iter().map(|e| Get{{ service_name_pascal }}Response {
                    id: e.id,
                    name: e.name,
                    description: e.description.unwrap_or_default(),
                    status: e.status,
                    created_at: e.created_at,
                    updated_at: e.updated_at,
                }).collect();
                Ok(Response::new(List{{ service_name_pascal }}Response { items }))
            }
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn create_{{ service_name_snake }}(
        &self,
        _request: Request<Create{{ service_name_pascal }}Request>,
    ) -> Result<Response<Create{{ service_name_pascal }}Response>, Status> {
        // TODO: 実装
        Ok(Response::new(Create{{ service_name_pascal }}Response {
            id: "todo".to_string(),
        }))
    }
}
{% endif %}
```

### src/adapter/handler/ — GraphQL (async-graphql)

`src/adapter/handler/graphql.rs.tera` — {% if api_style == "graphql" %} に該当。

```rust
{% if api_style == "graphql" %}
use async_graphql::{Context, Object, Schema, EmptyMutation, EmptySubscription};
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::usecase::{{ service_name_pascal }}UseCase;

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn {{ service_name_snake }}(
        &self,
        ctx: &Context<'_>,
        id: String,
    ) -> async_graphql::Result<Option<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_by_id(&id).await?)
    }

    async fn {{ service_name_snake }}_list(
        &self,
        ctx: &Context<'_>,
    ) -> async_graphql::Result<Vec<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_all().await?)
    }
}

pub type {{ service_name_pascal }}Schema = Schema<QueryRoot, EmptyMutation, EmptySubscription>;

pub fn build_schema(uc: {{ service_name_pascal }}UseCase) -> {{ service_name_pascal }}Schema {
    Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
        .data(Arc::new(uc))
        .finish()
}
{% endif %}
```

### src/adapter/handler/mod.rs

`src/adapter/handler/mod.rs.tera` — ハンドラーモジュール宣言。

```rust
{% if api_style == "rest" %}
mod rest;
pub use rest::AppHandler;
{% elif api_style == "grpc" %}
mod grpc;
pub use grpc::{{ service_name_pascal }}GrpcService as AppHandler;
{% elif api_style == "graphql" %}
mod graphql;
pub use graphql::{build_schema, AppHandler};
{% endif %}
```

### src/infra/mod.rs

`src/infra/mod.rs.tera` — インフラモジュール宣言。

```rust
pub mod config;
{% if has_database %}
pub mod persistence;
{% endif %}
{% if has_kafka %}
pub mod messaging;
{% endif %}
```

### src/infra/persistence.rs

`src/infra/persistence.rs.tera` — {% if has_database %} に該当。sqlx 接続プール。

```rust
{% if has_database %}
use sqlx::{{ database_type }}::{{ database_type | title }}Pool;
use sqlx::{{ database_type }}::{{ database_type | title }}PoolOptions;
use async_trait::async_trait;
use std::time::Duration;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::domain::repository::{{ service_name_pascal }}Repository;
use crate::infra::config::DatabaseConfig;

pub type DbPool = {{ database_type | title }}Pool;

pub async fn create_pool(cfg: &DatabaseConfig) -> anyhow::Result<DbPool> {
    let pool = {{ database_type | title }}PoolOptions::new()
        .max_connections(cfg.pool.max_open)
        .idle_timeout(Duration::from_secs(cfg.pool.max_lifetime_sec))
        .connect(&cfg.connection_string())
        .await?;
    Ok(pool)
}

pub struct Repository {
    pool: DbPool,
}

impl Repository {
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl {{ service_name_pascal }}Repository for Repository {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
        let entity = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        Ok(entity)
    }

    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
        let entities = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;
        Ok(entities)
    }

    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "INSERT INTO examples (id, name, description, status) VALUES ($1, $2, $3, $4)"
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "UPDATE examples SET name = $1, description = $2, status = $3 WHERE id = $4"
        )
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .bind(&entity.id)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn delete(&self, id: &str) -> anyhow::Result<()> {
        sqlx::query("DELETE FROM examples WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}
{% endif %}
```

### src/infra/messaging.rs

`src/infra/messaging.rs.tera` — {% if has_kafka %} に該当。[メッセージング設計.md](メッセージング設計.md) D-119 準拠。

```rust
{% if has_kafka %}
use rdkafka::config::ClientConfig;
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{StreamConsumer, Consumer as _};
use rdkafka::Message;
use std::time::Duration;

use crate::infra::config::KafkaConfig;

/// Producer は Kafka プロデューサー。
/// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
pub struct Producer {
    producer: FutureProducer,
}

impl Producer {
    pub fn new(cfg: &KafkaConfig) -> Self {
        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .create()
            .expect("Failed to create Kafka producer");
        Self { producer }
    }

    pub async fn publish(&self, topic: &str, key: &str, payload: &[u8]) -> anyhow::Result<()> {
        self.producer
            .send(
                FutureRecord::to(topic)
                    .key(key)
                    .payload(payload),
                Duration::from_secs(5),
            )
            .await
            .map_err(|(e, _)| anyhow::anyhow!("Failed to publish: {}", e))?;
        Ok(())
    }
}

/// Consumer は Kafka コンシューマー。
/// コンシューマーグループ命名規則: {service-name}.{purpose}
pub struct KafkaConsumer {
    consumer: StreamConsumer,
}

impl KafkaConsumer {
    pub fn new(cfg: &KafkaConfig, group_id: &str, topics: &[&str]) -> Self {
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .set("group.id", group_id)
            .set("auto.offset.reset", "earliest")
            .create()
            .expect("Failed to create Kafka consumer");
        consumer.subscribe(topics).expect("Failed to subscribe");
        Self { consumer }
    }
}
{% endif %}
```

### src/infra/config.rs

`src/infra/config.rs.tera` — [config設計.md](config設計.md) 準拠の設定ローダー。

```rust
use serde::Deserialize;
use std::fs;

/// Config はアプリケーション設定の全体構造。
#[derive(Debug, Deserialize)]
pub struct Config {
    pub app: AppConfig,
    pub server: ServerConfig,
{% if has_database %}
    pub database: DatabaseConfig,
{% endif %}
{% if has_kafka %}
    pub kafka: KafkaConfig,
{% endif %}
{% if has_redis %}
    pub redis: RedisConfig,
{% endif %}
    pub observability: ObservabilityConfig,
}

#[derive(Debug, Deserialize)]
pub struct AppConfig {
    pub name: String,
    pub version: String,
    pub environment: String,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub port: String,
    pub read_timeout_sec: u64,
    pub write_timeout_sec: u64,
}

{% if has_database %}
#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub user: String,
    pub password: String,
    pub name: String,
{% if database_type == "postgresql" %}
    pub ssl_mode: String,
{% endif %}
    pub pool: PoolConfig,
}

#[derive(Debug, Deserialize)]
pub struct PoolConfig {
    pub max_open: u32,
    pub max_idle: u32,
    pub max_lifetime_sec: u64,
}

impl DatabaseConfig {
    pub fn connection_string(&self) -> String {
{% if database_type == "postgresql" %}
        format!(
            "postgres://{}:{}@{}:{}/{}?sslmode={}",
            self.user, self.password, self.host, self.port, self.name, self.ssl_mode
        )
{% elif database_type == "mysql" %}
        format!(
            "mysql://{}:{}@{}:{}/{}",
            self.user, self.password, self.host, self.port, self.name
        )
{% elif database_type == "sqlite" %}
        self.name.clone()
{% endif %}
    }
}
{% endif %}

{% if has_kafka %}
#[derive(Debug, Deserialize)]
pub struct KafkaConfig {
    pub brokers: Vec<String>,
    pub schema_registry: String,
}
{% endif %}

{% if has_redis %}
#[derive(Debug, Deserialize)]
pub struct RedisConfig {
    pub addr: String,
    pub password: String,
    pub db: u32,
}
{% endif %}

#[derive(Debug, Deserialize)]
pub struct ObservabilityConfig {
    pub trace_endpoint: String,
    pub metric_endpoint: String,
    pub log_level: String,
}

impl Config {
    pub fn load(path: &str) -> anyhow::Result<Self> {
        let content = fs::read_to_string(path)?;
        let config: Config = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

### Dockerfile (Rust)

`Dockerfile.tera` — [Dockerイメージ戦略.md](Dockerイメージ戦略.md) 準拠。

```dockerfile
# === Build Stage ===
FROM rust:1.82-bookworm AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY . .
RUN cargo build --release

# === Runtime Stage ===
FROM gcr.io/distroless/cc-debian12

COPY --from=builder /app/target/release/{{ rust_crate }} /app/server
COPY --from=builder /app/config /config

EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/app/server"]
```

---

## 既存ドキュメント参照マップ

各テンプレートファイルが準拠する既存ドキュメントの設計パターン。

| テンプレートファイル        | 参照ドキュメント                               | 該当セクション                                |
| --------------------------- | ---------------------------------------------- | --------------------------------------------- |
| config/config.yaml          | [config設計.md](config設計.md)                 | YAML スキーマ定義                             |
| adapter/handler (REST)      | [API設計.md](API設計.md)                       | D-007 エラーレスポンス、D-008 バージョニング  |
| adapter/handler (gRPC)      | [API設計.md](API設計.md)                       | D-009 gRPC 定義パターン、D-010 バージョニング |
| adapter/handler (GraphQL)   | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、D-124 実装技術選定        |
| api/openapi/                | [API設計.md](API設計.md)                       | D-123 oapi-codegen / utoipa                   |
| Dockerfile                  | [Dockerイメージ戦略.md](Dockerイメージ戦略.md) | ベースイメージ・マルチステージビルド          |
| infra/messaging             | [メッセージング設計.md](メッセージング設計.md) | D-119 Kafka トピック、D-120 イベント駆動      |
| OTel 初期化                 | [可観測性設計.md](可観測性設計.md)             | D-110 分散トレーシング                        |
| 構造化ログ (slog / tracing) | [可観測性設計.md](可観測性設計.md)             | D-109 構造化ログ                              |
| domain/repository           | [コーディング規約.md](コーディング規約.md)     | モック生成（gomock / mockall）                |

## 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) — 変数置換・条件分岐の仕様
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) — クライアントテンプレート
- [テンプレート仕様-ライブラリ](テンプレート仕様-ライブラリ.md) — ライブラリテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) — データベーステンプレート
- [CLIフロー](CLIフロー.md) — CLI の対話フローと操作手順
- [ディレクトリ構成図](ディレクトリ構成図.md) — 生成先ディレクトリ構成
- [API設計](API設計.md) — REST / gRPC / GraphQL 設計
- [config設計](config設計.md) — config.yaml スキーマと環境別管理
- [可観測性設計](可観測性設計.md) — 監視・トレーシング設計
- [Dockerイメージ戦略](Dockerイメージ戦略.md) — Docker ビルド戦略
- [メッセージング設計](メッセージング設計.md) — Kafka トピック・イベント駆動設計
- [コーディング規約](コーディング規約.md) — Linter・Formatter・テストツール
