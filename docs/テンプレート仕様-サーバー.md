# テンプレート仕様 — サーバー

## 概要

本ドキュメントは、k1s0 CLI の「ひな形生成」機能でサーバーを選択した際に生成される **全ファイルのスケルトンコード** を定義する。対象フレームワークは **Go (gin)** と **Rust (axum + tokio)** の2つ。

両言語ともクリーンアーキテクチャに基づく4レイヤー構成を採用する。

```
domain（エンティティ・リポジトリインターフェース）
  ↑
usecase（ビジネスロジック）
  ↑
adapter（ハンドラー・プレゼンター）
  ↑
infra（DB接続・メッセージング・設定ローダー）
```

## 条件付き生成表

CLI の対話フローで選択されたオプションに応じて、生成されるファイルが変わる。

| 条件                      | 選択肢                            | 影響を受けるファイル                                             |
| ------------------------- | --------------------------------- | ---------------------------------------------------------------- |
| API 方式 (`api_styles`)   | `rest`                            | handler/rest, OpenAPI 定義, oapi-codegen 設定                    |
|                           | `grpc`                            | handler/grpc, proto 定義, buf.yaml, buf.gen.yaml（Go のみ）     |
|                           | `graphql`                         | handler/graphql, schema.graphql, gqlgen.yml（Go のみ）           |
| DB 有無 (`has_database`)  | `true`                            | persistence, config 内 database セクション, migrations/          |
|                           | `false`                           | 上記を生成しない                                                 |
| DB 種別 (`database_type`) | `postgresql` / `mysql` / `sqlite` | sqlx ドライバ依存、接続文字列形式                                |
| Kafka 有無 (`has_kafka`)  | `true`                            | messaging, config 内 kafka セクション                            |
|                           | `false`                           | 上記を生成しない                                                 |
| Redis 有無 (`has_redis`)  | `true`                            | config 内 redis セクション                                       |
|                           | `false`                           | 上記を生成しない                                                 |
| BFF (`bff_language`)      | `Go` / `Rust`                     | bff/ ディレクトリ（GraphQL + HTTP のみ、DB/Kafka/Redis なし）            |
| 常に生成                  | —                                 | テストファイル（usecase_test, handler_test, repository_test 等）、README.md |

### 複数 API 方式の同時選択

`api_styles` は配列型であり、REST と gRPC を同時に選択可能。テンプレート内では `api_styles is containing("xxx")` パターンで条件分岐を行う。

```tera
{% if api_styles is containing("rest") %}
  {# REST 固有のファイル内容 #}
{% endif %}
{% if api_styles is containing("grpc") %}
  {# gRPC 固有のファイル内容 #}
{% endif %}
```

REST + gRPC 同時選択時の生成ファイル一覧（Go の例）:

| カテゴリ | 生成されるファイル |
|---|---|
| REST 固有 | `rest_handler.go`, `openapi.yaml`, `oapi-codegen.yaml` |
| gRPC 固有 | `grpc_handler.go`, `service.proto`, `buf.yaml`, `buf.gen.yaml` |
| 共通 | `go.mod`（両方の依存を含む）, `cmd/main.go`, ドメイン層, インフラ層 |

## Tier 別配置パス

| Tier     | 配置パス                                                  |
| -------- | --------------------------------------------------------- |
| system   | `regions/system/server/{lang}/{service_name}/`            |
| business | `regions/business/{domain}/server/{lang}/{service_name}/` |
| service  | `regions/service/{service_name}/server/{lang}/`           |

配置パスは CLI の `build_output_path()` で Tier・領域名・サービス名から動的に構築される。テンプレート内では `{{ go_module }}` / `{{ rust_crate }}` で言語固有のモジュールパスを参照する。

---

## Go (gin) テンプレート

### go.mod

`go.mod.tera` — モジュール定義と依存関係。

```go
module {{ go_module }}

go 1.23

require (
	github.com/gin-gonic/gin v1.10.0
	go.opentelemetry.io/otel v1.31.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.31.0
	go.opentelemetry.io/otel/sdk v1.31.0
	go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin v0.56.0
	github.com/go-playground/validator/v10 v10.22.1
	gopkg.in/yaml.v3 v3.0.1
{% if api_styles is containing("rest") %}
	github.com/oapi-codegen/oapi-codegen/v2 v2.4.1
	github.com/oapi-codegen/runtime v1.1.1
{% endif %}
{% if api_styles is containing("grpc") %}
	google.golang.org/grpc v1.68.0
	google.golang.org/protobuf v1.35.2
{% endif %}
{% if api_styles is containing("graphql") %}
	github.com/99designs/gqlgen v0.17.55
	github.com/vektah/gqlparser/v2 v2.5.19
{% endif %}
{% if has_database %}
	github.com/jmoiron/sqlx v1.4.0
{% endif %}
{% if has_database and database_type == "postgresql" %}
	github.com/lib/pq v1.10.9
{% endif %}
{% if has_database and database_type == "mysql" %}
	github.com/go-sql-driver/mysql v1.8.1
{% endif %}
{% if has_database and database_type == "sqlite" %}
	github.com/mattn/go-sqlite3 v1.14.24
{% endif %}
{% if has_kafka %}
	github.com/segmentio/kafka-go v0.4.47
{% endif %}
{% if has_redis %}
	github.com/redis/go-redis/v9 v9.7.0
{% endif %}
)
```

### cmd/main.go

`cmd/main.go.tera` — エントリポイント。gin ルーター初期化、ミドルウェア登録、graceful shutdown。

```go
package main

import (
	"context"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"

	"{{ go_module }}/internal/adapter/handler"
	"{{ go_module }}/internal/infra/config"
{% if has_database %}
	"{{ go_module }}/internal/infra/persistence"
{% endif %}
{% if has_kafka %}
	"{{ go_module }}/internal/infra/messaging"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

func main() {
	// --- Config ---
	cfg, err := config.Load("config/config.yaml")
	if err != nil {
		slog.Error("failed to load config", "error", err)
		os.Exit(1)
	}

	// --- Logger ---
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelInfo,
	}))
	slog.SetDefault(logger)

{% if has_database %}
	// --- Database ---
	db, err := persistence.NewDB(cfg.Database)
	if err != nil {
		slog.Error("failed to connect database", "error", err)
		os.Exit(1)
	}
	defer db.Close()
{% endif %}

{% if has_kafka %}
	// --- Kafka ---
	producer := messaging.NewProducer(cfg.Kafka)
	defer producer.Close()
{% endif %}

	// --- DI: Repository → UseCase → Handler ---
{% if has_database %}
	repo := persistence.NewRepository(db)
{% endif %}
	uc := usecase.New{{ service_name_pascal }}UseCase(
{% if has_database %}
		repo,
{% endif %}
	)
	h := handler.NewHandler(uc)

	// --- Router ---
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(otelgin.Middleware("{{ service_name }}"))

	// ヘルスチェック
	r.GET("/healthz", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})
	r.GET("/readyz", func(c *gin.Context) {
{% if has_database %}
		if err := db.PingContext(c.Request.Context()); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"status": "not ready", "error": err.Error()})
			return
		}
{% endif %}
		c.JSON(http.StatusOK, gin.H{"status": "ready"})
	})

	// API ルート登録
	h.RegisterRoutes(r)

	// --- Server ---
	srv := &http.Server{
		Addr:    ":" + cfg.Server.Port,
		Handler: r,
	}

	go func() {
		slog.Info("server starting", "port", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("server failed", "error", err)
			os.Exit(1)
		}
	}()

	// --- Graceful Shutdown ---
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	slog.Info("shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		slog.Error("server forced to shutdown", "error", err)
	}
	slog.Info("server exited")
}
```

### internal/domain/model/entity.go

`internal/domain/model/entity.go.tera` — ドメインエンティティ。

```go
package model

import "time"

// {{ service_name_pascal }}Entity はドメインエンティティを表す。
type {{ service_name_pascal }}Entity struct {
	ID          string    `json:"id" db:"id"`
	Name        string    `json:"name" db:"name" validate:"required,max=255"`
	Description string    `json:"description,omitempty" db:"description"`
	Status      string    `json:"status" db:"status"`
	CreatedAt   time.Time `json:"created_at" db:"created_at"`
	UpdatedAt   time.Time `json:"updated_at" db:"updated_at"`
}
```

### internal/domain/repository/repository.go

`internal/domain/repository/repository.go.tera` — リポジトリインターフェース。DDD の原則に従い、ドメイン層の契約として `has_database` の値に関わらず常に生成される。具体的な永続化実装（`internal/infra/persistence/`）は `has_database == true` の場合のみ生成される。

```go
package repository

//go:generate mockgen -source=repository.go -destination=mock_repository.go -package=repository

import (
	"context"

	"{{ go_module }}/internal/domain/model"
)

// {{ service_name_pascal }}Repository はデータアクセスの抽象化インターフェース。
type {{ service_name_pascal }}Repository interface {
	FindByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error)
	FindAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error)
	Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error
	Update(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error
	Delete(ctx context.Context, id string) error
}
```

### internal/usecase/usecase.go

`internal/usecase/usecase.go.tera` — ユースケース（DI パターン）。

```go
package usecase

import (
	"context"

	"{{ go_module }}/internal/domain/model"
{% if has_database %}
	"{{ go_module }}/internal/domain/repository"
{% endif %}
)

// {{ service_name_pascal }}UseCase はビジネスロジックを提供する。
type {{ service_name_pascal }}UseCase struct {
{% if has_database %}
	repo repository.{{ service_name_pascal }}Repository
{% endif %}
}

// New{{ service_name_pascal }}UseCase はユースケースを生成する。
func New{{ service_name_pascal }}UseCase(
{% if has_database %}
	repo repository.{{ service_name_pascal }}Repository,
{% endif %}
) *{{ service_name_pascal }}UseCase {
	return &{{ service_name_pascal }}UseCase{
{% if has_database %}
		repo: repo,
{% endif %}
	}
}

// GetByID は ID を指定してエンティティを取得する。
func (uc *{{ service_name_pascal }}UseCase) GetByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
{% if has_database %}
	return uc.repo.FindByID(ctx, id)
{% else %}
	// TODO: 実装
	return nil, nil
{% endif %}
}

// GetAll は全エンティティを取得する。
func (uc *{{ service_name_pascal }}UseCase) GetAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
{% if has_database %}
	return uc.repo.FindAll(ctx)
{% else %}
	// TODO: 実装
	return nil, nil
{% endif %}
}

// Create はエンティティを新規作成する。
func (uc *{{ service_name_pascal }}UseCase) Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
{% if has_database %}
	return uc.repo.Create(ctx, entity)
{% else %}
	// TODO: 実装
	return nil
{% endif %}
}
```

### internal/adapter/handler/ — REST (gin)

`internal/adapter/handler/rest_handler.go.tera` — {% if api_styles is containing("rest") %} に該当。[API設計.md](API設計.md) D-007 エラーレスポンスパターンに従う。

```go
{% if api_styles is containing("rest") %}
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"

	"{{ go_module }}/internal/usecase"
)

var validate = validator.New()

// Handler は REST API ハンドラーを提供する。
type Handler struct {
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewHandler はハンドラーを生成する。
func NewHandler(uc *usecase.{{ service_name_pascal }}UseCase) *Handler {
	return &Handler{uc: uc}
}

// RegisterRoutes は gin ルーターにルートを登録する。
func (h *Handler) RegisterRoutes(r *gin.Engine) {
	v1 := r.Group("/api/v1")
	{
		v1.GET("/{{ service_name }}", h.List)
		v1.GET("/{{ service_name }}/:id", h.GetByID)
		v1.POST("/{{ service_name }}", h.Create)
	}
}

// ErrorResponse は API設計.md D-007 準拠のエラーレスポンス。
type ErrorResponse struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// List は全件取得エンドポイント。
func (h *Handler) List(c *gin.Context) {
	entities, err := h.uc.GetAll(c.Request.Context())
	if err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{
			Code:    "INTERNAL_ERROR",
			Message: "Failed to retrieve resources",
		})
		return
	}
	c.JSON(http.StatusOK, entities)
}

// GetByID は ID 指定取得エンドポイント。
func (h *Handler) GetByID(c *gin.Context) {
	id := c.Param("id")
	entity, err := h.uc.GetByID(c.Request.Context(), id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{
			Code:    "INTERNAL_ERROR",
			Message: "Failed to retrieve resource",
		})
		return
	}
	if entity == nil {
		c.JSON(http.StatusNotFound, ErrorResponse{
			Code:    "NOT_FOUND",
			Message: "Resource not found",
		})
		return
	}
	c.JSON(http.StatusOK, entity)
}

// CreateRequest は作成リクエストボディ。
type CreateRequest struct {
	Name        string `json:"name" validate:"required,max=255"`
	Description string `json:"description"`
}

// Create は新規作成エンドポイント。
func (h *Handler) Create(c *gin.Context) {
	var req CreateRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			Code:    "INVALID_REQUEST",
			Message: "Invalid request body",
		})
		return
	}
	if err := validate.Struct(req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			Code:    "VALIDATION_ERROR",
			Message: err.Error(),
		})
		return
	}
	// TODO: req → entity 変換、uc.Create 呼び出し
	c.JSON(http.StatusCreated, gin.H{"status": "created"})
}
{% endif %}
```

### internal/adapter/handler/ — gRPC

`internal/adapter/handler/grpc_handler.go.tera` — {% if api_styles is containing("grpc") %} に該当。

```go
{% if api_styles is containing("grpc") %}
package handler

import (
	"context"

	pb "{{ go_module }}/api/proto/gen"
	"{{ go_module }}/internal/usecase"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// GRPCHandler は gRPC サービス実装。
type GRPCHandler struct {
	pb.Unimplemented{{ service_name_pascal }}ServiceServer
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewGRPCHandler はハンドラーを生成する。
func NewGRPCHandler(uc *usecase.{{ service_name_pascal }}UseCase) *GRPCHandler {
	return &GRPCHandler{uc: uc}
}

// Get{{ service_name_pascal }} は ID 指定取得 RPC。
func (h *GRPCHandler) Get{{ service_name_pascal }}(ctx context.Context, req *pb.Get{{ service_name_pascal }}Request) (*pb.Get{{ service_name_pascal }}Response, error) {
	entity, err := h.uc.GetByID(ctx, req.GetId())
	if err != nil {
		return nil, status.Errorf(codes.Internal, "internal error: %v", err)
	}
	if entity == nil {
		return nil, status.Errorf(codes.NotFound, "resource not found: %s", req.GetId())
	}
	return &pb.Get{{ service_name_pascal }}Response{
		Id:   entity.ID,
		Name: entity.Name,
	}, nil
}
{% endif %}
```

### internal/adapter/handler/ — GraphQL

`internal/adapter/handler/graphql_resolver.go.tera` — {% if api_styles is containing("graphql") %} に該当。gqlgen リゾルバー。

```go
{% if api_styles is containing("graphql") %}
package handler

import (
	"context"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/usecase"
)

// Resolver は GraphQL リゾルバーのルート。
type Resolver struct {
	uc *usecase.{{ service_name_pascal }}UseCase
}

// NewResolver はリゾルバーを生成する。
func NewResolver(uc *usecase.{{ service_name_pascal }}UseCase) *Resolver {
	return &Resolver{uc: uc}
}

// Query はクエリリゾルバー。
func (r *Resolver) Query() QueryResolver {
	return &queryResolver{r}
}

type queryResolver struct{ *Resolver }

func (r *queryResolver) {{ service_name_pascal }}(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
	return r.uc.GetByID(ctx, id)
}

func (r *queryResolver) {{ service_name_pascal }}List(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
	return r.uc.GetAll(ctx)
}
{% endif %}
```

### internal/infra/persistence/db.go

`internal/infra/persistence/db.go.tera` — {% if has_database %} に該当。sqlx による DB 接続初期化。

```go
{% if has_database %}
package persistence

import (
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
{% if database_type == "postgresql" %}
	_ "github.com/lib/pq"
{% elif database_type == "mysql" %}
	_ "github.com/go-sql-driver/mysql"
{% elif database_type == "sqlite" %}
	_ "github.com/mattn/go-sqlite3"
{% endif %}

	"{{ go_module }}/internal/infra/config"
)

// NewDB は DB 接続を初期化する。
func NewDB(cfg config.DatabaseConfig) (*sqlx.DB, error) {
	dsn := buildDSN(cfg)
{% if database_type == "postgresql" %}
	db, err := sqlx.Connect("postgres", dsn)
{% elif database_type == "mysql" %}
	db, err := sqlx.Connect("mysql", dsn)
{% elif database_type == "sqlite" %}
	db, err := sqlx.Connect("sqlite3", dsn)
{% endif %}
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	db.SetMaxOpenConns(cfg.Pool.MaxOpen)
	db.SetMaxIdleConns(cfg.Pool.MaxIdle)
	db.SetConnMaxLifetime(time.Duration(cfg.Pool.MaxLifetimeSec) * time.Second)

	return db, nil
}

func buildDSN(cfg config.DatabaseConfig) string {
{% if database_type == "postgresql" %}
	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name, cfg.SSLMode)
{% elif database_type == "mysql" %}
	return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&charset=utf8mb4",
		cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.Name)
{% elif database_type == "sqlite" %}
	return cfg.Name
{% endif %}
}
{% endif %}
```

### internal/infra/persistence/repository.go

`internal/infra/persistence/repository.go.tera` — {% if has_database %} に該当。リポジトリ実装。

```go
{% if has_database %}
package persistence

import (
	"context"

	"github.com/jmoiron/sqlx"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/domain/repository"
)

type {{ service_name_camel }}Repository struct {
	db *sqlx.DB
}

// NewRepository はリポジトリ実装を生成する。
func NewRepository(db *sqlx.DB) repository.{{ service_name_pascal }}Repository {
	return &{{ service_name_camel }}Repository{db: db}
}

func (r *{{ service_name_camel }}Repository) FindByID(ctx context.Context, id string) (*model.{{ service_name_pascal }}Entity, error) {
	var entity model.{{ service_name_pascal }}Entity
	err := r.db.GetContext(ctx, &entity, "SELECT * FROM examples WHERE id = $1", id)
	if err != nil {
		return nil, err
	}
	return &entity, nil
}

func (r *{{ service_name_camel }}Repository) FindAll(ctx context.Context) ([]*model.{{ service_name_pascal }}Entity, error) {
	var entities []*model.{{ service_name_pascal }}Entity
	err := r.db.SelectContext(ctx, &entities, "SELECT * FROM examples ORDER BY created_at DESC")
	return entities, err
}

func (r *{{ service_name_camel }}Repository) Create(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
	_, err := r.db.NamedExecContext(ctx,
		"INSERT INTO examples (id, name, description, status) VALUES (:id, :name, :description, :status)",
		entity)
	return err
}

func (r *{{ service_name_camel }}Repository) Update(ctx context.Context, entity *model.{{ service_name_pascal }}Entity) error {
	_, err := r.db.NamedExecContext(ctx,
		"UPDATE examples SET name = :name, description = :description, status = :status WHERE id = :id",
		entity)
	return err
}

func (r *{{ service_name_camel }}Repository) Delete(ctx context.Context, id string) error {
	_, err := r.db.ExecContext(ctx, "DELETE FROM examples WHERE id = $1", id)
	return err
}
{% endif %}
```

### internal/infra/messaging/kafka.go

`internal/infra/messaging/kafka.go.tera` — {% if has_kafka %} に該当。[メッセージング設計.md](メッセージング設計.md) D-119 トピック命名規則に従う。

```go
{% if has_kafka %}
package messaging

import (
	"context"
	"log/slog"

	"github.com/segmentio/kafka-go"

	"{{ go_module }}/internal/infra/config"
)

// Producer は Kafka プロデューサー。
type Producer struct {
	writer *kafka.Writer
}

// NewProducer はプロデューサーを生成する。
// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
func NewProducer(cfg config.KafkaConfig) *Producer {
	w := &kafka.Writer{
		Addr:     kafka.TCP(cfg.Brokers...),
		Balancer: &kafka.LeastBytes{},
	}
	return &Producer{writer: w}
}

// Publish はメッセージを送信する。
func (p *Producer) Publish(ctx context.Context, topic string, key, value []byte) error {
	return p.writer.WriteMessages(ctx, kafka.Message{
		Topic: topic,
		Key:   key,
		Value: value,
	})
}

// Close はプロデューサーを閉じる。
func (p *Producer) Close() {
	if err := p.writer.Close(); err != nil {
		slog.Error("failed to close kafka producer", "error", err)
	}
}

// Consumer は Kafka コンシューマー。
type Consumer struct {
	reader *kafka.Reader
}

// NewConsumer はコンシューマーを生成する。
// コンシューマーグループ命名規則: {service-name}.{purpose}
func NewConsumer(cfg config.KafkaConfig, topic, groupID string) *Consumer {
	r := kafka.NewReader(kafka.ReaderConfig{
		Brokers:  cfg.Brokers,
		Topic:    topic,
		GroupID:  groupID,
		MinBytes: 10e3,
		MaxBytes: 10e6,
	})
	return &Consumer{reader: r}
}

// Consume はメッセージを受信する。
func (c *Consumer) Consume(ctx context.Context, handler func(kafka.Message) error) error {
	for {
		msg, err := c.reader.ReadMessage(ctx)
		if err != nil {
			return err
		}
		if err := handler(msg); err != nil {
			slog.Error("failed to handle message", "topic", msg.Topic, "error", err)
		}
	}
}

// Close はコンシューマーを閉じる。
func (c *Consumer) Close() {
	if err := c.reader.Close(); err != nil {
		slog.Error("failed to close kafka consumer", "error", err)
	}
}
{% endif %}
```

### Redis クライアント

`has_redis = true` の場合に生成される Redis キャッシュクライアント。`redis_session`（BFF用セッション管理）とは独立した汎用キャッシュクライアントである。

#### Go: `internal/infra/cache/redis.go`

テンプレート: `CLI/templates/server/go/internal/infra/cache/redis.go.tera`

go-redis v9 のラッパーとして以下のメソッドを提供する:
- `NewRedisClient(cfg)` — クライアント初期化
- `Get(ctx, key)` — キャッシュ取得
- `Set(ctx, key, value, ttl)` — TTL付きキャッシュ保存
- `Delete(ctx, key)` — キャッシュ削除
- `Close()` — 接続クローズ
- `Ping(ctx)` — ヘルスチェック

#### Rust: `src/infra/redis_client.rs`

テンプレート: `CLI/templates/server/rust/src/infra/redis_client.rs.tera`

redis クレートのラッパーとして以下のメソッドを提供する:
- `RedisClient::new(cfg)` — クライアント初期化
- `get(key)` — キャッシュ取得
- `set(key, value, ttl_secs)` — TTL付きキャッシュ保存
- `delete(key)` — キャッシュ削除
- `ping()` — ヘルスチェック

### internal/infra/config/config.go

`internal/infra/config/config.go.tera` — [config設計.md](config設計.md) 準拠の設定ローダー。

```go
package config

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// Config はアプリケーション設定の全体構造。
type Config struct {
	App    AppConfig    `yaml:"app"`
	Server ServerConfig `yaml:"server"`
{% if has_database %}
	Database DatabaseConfig `yaml:"database"`
{% endif %}
{% if has_kafka %}
	Kafka KafkaConfig `yaml:"kafka"`
{% endif %}
{% if has_redis %}
	Redis RedisConfig `yaml:"redis"`
{% endif %}
	Observability ObservabilityConfig `yaml:"observability"`
}

// AppConfig はアプリケーション基本情報。
type AppConfig struct {
	Name        string `yaml:"name"`
	Version     string `yaml:"version"`
	Environment string `yaml:"environment"`
}

// ServerConfig はサーバー設定。
type ServerConfig struct {
	Port            string `yaml:"port"`
	ReadTimeoutSec  int    `yaml:"read_timeout_sec"`
	WriteTimeoutSec int    `yaml:"write_timeout_sec"`
}

{% if has_database %}
// DatabaseConfig は DB 接続設定。
type DatabaseConfig struct {
	Host     string     `yaml:"host"`
	Port     int        `yaml:"port"`
	User     string     `yaml:"user"`
	Password string     `yaml:"password"`
	Name     string     `yaml:"name"`
	SSLMode  string     `yaml:"ssl_mode"`
	Pool     PoolConfig `yaml:"pool"`
}

// PoolConfig はコネクションプール設定。
type PoolConfig struct {
	MaxOpen        int `yaml:"max_open"`
	MaxIdle        int `yaml:"max_idle"`
	MaxLifetimeSec int `yaml:"max_lifetime_sec"`
}
{% endif %}

{% if has_kafka %}
// KafkaConfig は Kafka 接続設定。
type KafkaConfig struct {
	Brokers        []string `yaml:"brokers"`
	SchemaRegistry string   `yaml:"schema_registry"`
}
{% endif %}

{% if has_redis %}
// RedisConfig は Redis 接続設定。
type RedisConfig struct {
	Addr     string `yaml:"addr"`
	Password string `yaml:"password"`
	DB       int    `yaml:"db"`
}
{% endif %}

// ObservabilityConfig は可観測性設定。
type ObservabilityConfig struct {
	TraceEndpoint  string `yaml:"trace_endpoint"`
	MetricEndpoint string `yaml:"metric_endpoint"`
	LogLevel       string `yaml:"log_level"`
}

// Load は YAML ファイルから設定を読み込む。
func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}
	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}
	return &cfg, nil
}
```

### config/config.yaml

`config/config.yaml.tera` — [config設計.md](config設計.md) 準拠のアプリケーション設定ファイル。

```yaml
app:
  name: "{{ service_name }}"
  version: "0.1.0"
  environment: "development"

server:
  port: "8080"
  read_timeout_sec: 30
  write_timeout_sec: 30

{% if has_database %}
database:
  host: "localhost"
{% if database_type == "postgresql" %}
  port: 5432
{% elif database_type == "mysql" %}
  port: 3306
{% endif %}
  user: "{{ service_name_snake }}"
  password: ""
  name: "{{ service_name_snake }}"
{% if database_type == "postgresql" %}
  ssl_mode: "disable"
{% endif %}
  pool:
    max_open: 25
    max_idle: 5
    max_lifetime_sec: 300
{% endif %}

{% if has_kafka %}
kafka:
  brokers:
    - "localhost:9092"
  schema_registry: "http://localhost:8081"
{% endif %}

{% if has_redis %}
redis:
  addr: "localhost:6379"
  password: ""
  db: 0
{% endif %}

observability:
  trace_endpoint: "localhost:4317"
  metric_endpoint: "localhost:4317"
  log_level: "info"
```

### api/openapi/openapi.yaml

`api/openapi/openapi.yaml.tera` — {% if api_styles is containing("rest") %} に該当。OpenAPI 3.0 定義。コード生成は [API設計.md](API設計.md) D-123 oapi-codegen に従う。

```yaml
{% if api_styles is containing("rest") %}
openapi: "3.0.3"
info:
  title: "{{ service_name_pascal }} API"
  version: "1.0.0"
  description: "{{ service_name }} の REST API 定義"
servers:
  - url: "http://localhost:8080"
    description: "ローカル開発環境"
paths:
  /api/v1/{{ service_name }}:
    get:
      summary: "一覧取得"
      operationId: "list{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/{{ service_name_pascal }}"
    post:
      summary: "新規作成"
      operationId: "create{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Create{{ service_name_pascal }}Request"
      responses:
        "201":
          description: "作成成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "400":
          description: "バリデーションエラー"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /api/v1/{{ service_name }}/{id}:
    get:
      summary: "ID 指定取得"
      operationId: "get{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "404":
          description: "リソースが見つからない"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
components:
  schemas:
    {{ service_name_pascal }}:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        description:
          type: string
        status:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
    Create{{ service_name_pascal }}Request:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          maxLength: 255
        description:
          type: string
    ErrorResponse:
      type: object
      properties:
        code:
          type: string
        message:
          type: string
{% endif %}
```

### oapi-codegen.yaml（Go REST 用）

`oapi-codegen.yaml.tera` — {% if api_styles is containing("rest") %} かつ Go の場合に生成。[API設計.md](API設計.md) D-123 oapi-codegen に従い、OpenAPI 定義からサーバーインターフェース・型定義を自動生成する。

```yaml
{% if api_styles is containing("rest") %}
# oapi-codegen 設定
# 実行: oapi-codegen --config oapi-codegen.yaml api/openapi/openapi.yaml
package: openapi
generate:
  gin-server: true
  models: true
  embedded-spec: true
output: internal/adapter/handler/openapi_gen.go
output-options:
  skip-prune: true
{% endif %}
```

> **補足**: oapi-codegen は後処理（`CLI/src/commands/generate/execute.rs`）で自動実行される。生成されたコードは `internal/adapter/handler/openapi_gen.go` に出力され、REST ハンドラーのインターフェースと型定義を提供する。手動実装の `rest_handler.go` でこのインターフェースを満たすことで、OpenAPI 定義とハンドラーの整合性を保証する。

### api/proto/service.proto

`api/proto/service.proto.tera` — {% if api_styles is containing("grpc") %} に該当。[API設計.md](API設計.md) D-009 gRPC 定義パターンに従う。

```proto
{% if api_styles is containing("grpc") %}
syntax = "proto3";

package {{ service_name_snake }}.v1;

option go_package = "{{ go_module }}/api/proto/gen";

// {{ service_name_pascal }}Service は {{ service_name }} の gRPC サービス定義。
service {{ service_name_pascal }}Service {
  rpc Get{{ service_name_pascal }} (Get{{ service_name_pascal }}Request) returns (Get{{ service_name_pascal }}Response);
  rpc List{{ service_name_pascal }} (List{{ service_name_pascal }}Request) returns (List{{ service_name_pascal }}Response);
  rpc Create{{ service_name_pascal }} (Create{{ service_name_pascal }}Request) returns (Create{{ service_name_pascal }}Response);
}

message Get{{ service_name_pascal }}Request {
  string id = 1;
}

message Get{{ service_name_pascal }}Response {
  string id = 1;
  string name = 2;
  string description = 3;
  string status = 4;
  string created_at = 5;
  string updated_at = 6;
}

message List{{ service_name_pascal }}Request {}

message List{{ service_name_pascal }}Response {
  repeated Get{{ service_name_pascal }}Response items = 1;
}

message Create{{ service_name_pascal }}Request {
  string name = 1;
  string description = 2;
}

message Create{{ service_name_pascal }}Response {
  string id = 1;
}
{% endif %}
```

### Dockerfile

`Dockerfile.tera` — [Dockerイメージ戦略.md](Dockerイメージ戦略.md) 準拠のマルチステージビルド。

```dockerfile
# === Build Stage ===
FROM golang:1.23-bookworm AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -trimpath -ldflags="-s -w" -o /app/server ./cmd/main.go

# === Runtime Stage ===
FROM gcr.io/distroless/static-debian12

COPY --from=builder /app/server /server
COPY --from=builder /app/config /config

EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/server"]
```

---

## Rust (axum + tokio) テンプレート

### Cargo.toml

`Cargo.toml.tera` — クレート定義と依存関係。

```toml
[package]
name = "{{ rust_crate }}"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_yaml = "0.9"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
opentelemetry = "0.24"
opentelemetry-otlp = "0.17"
opentelemetry_sdk = "0.24"
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace"] }
thiserror = "2"
{% if api_styles is containing("rest") %}
utoipa = { version = "5", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "8", features = ["axum"] }
{% endif %}
{% if api_styles is containing("grpc") %}
tonic = "0.12"
prost = "0.13"
{% endif %}
{% if api_styles is containing("graphql") %}
async-graphql = "7"
async-graphql-axum = "7"
{% endif %}
{% if has_database %}
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "{{ database_type }}"] }
{% endif %}
{% if has_kafka %}
rdkafka = { version = "0.36", features = ["cmake-build"] }
{% endif %}
{% if has_redis %}
redis = { version = "0.27", features = ["tokio-comp"] }
{% endif %}

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }

{% if api_styles is containing("grpc") %}
[build-dependencies]
tonic-build = "0.12"
{% endif %}
```

### src/main.rs

`src/main.rs.tera` — エントリポイント。axum Router、tower ミドルウェア、graceful shutdown。

```rust
use axum::{routing::get, Json, Router};
use serde_json::json;
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod adapter;
mod domain;
mod infra;
mod usecase;

use infra::config::Config;

#[tokio::main]
async fn main() {
    // --- Logger ---
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer().json())
        .init();

    // --- Config ---
    let config = Config::load("config/config.yaml")
        .expect("Failed to load config");

{% if has_database %}
    // --- Database ---
    let pool = infra::persistence::create_pool(&config.database)
        .await
        .expect("Failed to connect to database");
{% endif %}

{% if has_kafka %}
    // --- Kafka ---
    let producer = infra::messaging::Producer::new(&config.kafka);
{% endif %}

    // --- DI: Repository → UseCase → Handler ---
{% if has_database %}
    let repo = infra::persistence::Repository::new(pool.clone());
{% endif %}
    let uc = usecase::{{ service_name_pascal }}UseCase::new(
{% if has_database %}
        repo,
{% endif %}
    );
    let handler = adapter::handler::AppHandler::new(uc);

    // --- Router ---
    let app = Router::new()
        .route("/healthz", get(|| async { Json(json!({"status": "ok"})) }))
        .route("/readyz", get({
{% if has_database %}
            let pool = pool.clone();
{% endif %}
            move || async move {
{% if has_database %}
                match sqlx::query("SELECT 1").execute(&pool).await {
                    Ok(_) => Json(json!({"status": "ready"})),
                    Err(_) => Json(json!({"status": "not ready"})),
                }
{% else %}
                Json(json!({"status": "ready"}))
{% endif %}
            }
        }))
        .merge(handler.routes())
        .layer(TraceLayer::new_for_http())
        .layer(CorsLayer::permissive());

    // --- Server ---
    let addr: SocketAddr = format!("0.0.0.0:{}", config.server.port)
        .parse()
        .expect("Invalid address");
    tracing::info!("server starting on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr)
        .await
        .expect("Failed to bind");

    // --- Graceful Shutdown ---
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .expect("Server error");
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("Failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    tracing::info!("shutdown signal received");
}
```

### src/domain/mod.rs

`src/domain/mod.rs.tera` — ドメインモジュール宣言。

```rust
pub mod model;
pub mod repository;
```

### src/domain/model.rs

`src/domain/model.rs.tera` — エンティティ定義。

```rust
use serde::{Deserialize, Serialize};

/// {{ service_name_pascal }}Entity はドメインエンティティを表す。
#[derive(Debug, Clone, Serialize, Deserialize)]
{% if has_database %}
#[derive(sqlx::FromRow)]
{% endif %}
pub struct {{ service_name_pascal }}Entity {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub created_at: String,
    pub updated_at: String,
}
```

### src/domain/repository.rs

`src/domain/repository.rs.tera` — リポジトリ trait。

```rust
use async_trait::async_trait;

use super::model::{{ service_name_pascal }}Entity;

/// {{ service_name_pascal }}Repository はデータアクセスの抽象化 trait。
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait {{ service_name_pascal }}Repository: Send + Sync {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>>;
    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>>;
    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn delete(&self, id: &str) -> anyhow::Result<()>;
}
```

### src/usecase/mod.rs

`src/usecase/mod.rs.tera` — ユースケースモジュール。

```rust
pub mod service;

pub use service::{{ service_name_pascal }}UseCase;
```

### src/usecase/service.rs

`src/usecase/service.rs.tera` — ユースケース実装（DI パターン）。

```rust
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
{% if has_database %}
use crate::domain::repository::{{ service_name_pascal }}Repository;
{% endif %}

/// {{ service_name_pascal }}UseCase はビジネスロジックを提供する。
pub struct {{ service_name_pascal }}UseCase {
{% if has_database %}
    repo: Arc<dyn {{ service_name_pascal }}Repository>,
{% endif %}
}

impl {{ service_name_pascal }}UseCase {
    pub fn new(
{% if has_database %}
        repo: impl {{ service_name_pascal }}Repository + 'static,
{% endif %}
    ) -> Self {
        Self {
{% if has_database %}
            repo: Arc::new(repo),
{% endif %}
        }
    }

    pub async fn get_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_by_id(id).await
{% else %}
        // TODO: 実装
        Ok(None)
{% endif %}
    }

    pub async fn get_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_all().await
{% else %}
        // TODO: 実装
        Ok(vec![])
{% endif %}
    }

    pub async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
{% if has_database %}
        self.repo.create(entity).await
{% else %}
        // TODO: 実装
        Ok(())
{% endif %}
    }
}
```

### src/adapter/mod.rs

`src/adapter/mod.rs.tera` — アダプターモジュール宣言。

```rust
pub mod handler;
```

### src/adapter/handler/ — REST (axum + utoipa)

`src/adapter/handler/rest.rs.tera` — {% if api_styles is containing("rest") %} に該当。

```rust
{% if api_styles is containing("rest") %}
use axum::{
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

/// AppHandler は REST ハンドラーを提供する。
pub struct AppHandler {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl AppHandler {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }

    pub fn routes(&self) -> Router {
        let uc = self.uc.clone();
        Router::new()
            .route("/api/v1/{{ service_name }}", get(list).post(create))
            .route("/api/v1/{{ service_name }}/:id", get(get_by_id))
            .with_state(uc)
    }
}

/// ErrorResponse は API設計.md D-007 準拠のエラーレスポンス。
#[derive(Serialize)]
struct ErrorResponse {
    code: String,
    message: String,
}

async fn list(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
) -> Result<Json<Vec<crate::domain::model::{{ service_name_pascal }}Entity>>, StatusCode> {
    uc.get_all()
        .await
        .map(Json)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

async fn get_by_id(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Path(id): Path<String>,
) -> Result<Json<crate::domain::model::{{ service_name_pascal }}Entity>, StatusCode> {
    match uc.get_by_id(&id).await {
        Ok(Some(entity)) => Ok(Json(entity)),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

#[derive(Deserialize)]
struct CreateRequest {
    name: String,
    description: Option<String>,
}

async fn create(
    State(_uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Json(_req): Json<CreateRequest>,
) -> StatusCode {
    // TODO: req → entity 変換、uc.create 呼び出し
    StatusCode::CREATED
}
{% endif %}
```

### src/adapter/handler/ — gRPC (tonic)

`src/adapter/handler/grpc.rs.tera` — {% if api_styles is containing("grpc") %} に該当。

```rust
{% if api_styles is containing("grpc") %}
use tonic::{Request, Response, Status};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

pub mod proto {
    tonic::include_proto!("{{ service_name_snake }}.v1");
}

use proto::{{ service_name_snake }}_service_server::{{ service_name_pascal }}Service;
use proto::{
    Get{{ service_name_pascal }}Request, Get{{ service_name_pascal }}Response,
    List{{ service_name_pascal }}Request, List{{ service_name_pascal }}Response,
    Create{{ service_name_pascal }}Request, Create{{ service_name_pascal }}Response,
};

pub struct {{ service_name_pascal }}GrpcService {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl {{ service_name_pascal }}GrpcService {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }
}

#[tonic::async_trait]
impl {{ service_name_pascal }}Service for {{ service_name_pascal }}GrpcService {
    async fn get_{{ service_name_snake }}(
        &self,
        request: Request<Get{{ service_name_pascal }}Request>,
    ) -> Result<Response<Get{{ service_name_pascal }}Response>, Status> {
        let id = request.into_inner().id;
        match self.uc.get_by_id(&id).await {
            Ok(Some(entity)) => Ok(Response::new(Get{{ service_name_pascal }}Response {
                id: entity.id,
                name: entity.name,
                description: entity.description.unwrap_or_default(),
                status: entity.status,
                created_at: entity.created_at,
                updated_at: entity.updated_at,
            })),
            Ok(None) => Err(Status::not_found(format!("resource not found: {}", id))),
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn list_{{ service_name_snake }}(
        &self,
        _request: Request<List{{ service_name_pascal }}Request>,
    ) -> Result<Response<List{{ service_name_pascal }}Response>, Status> {
        match self.uc.get_all().await {
            Ok(entities) => {
                let items = entities.into_iter().map(|e| Get{{ service_name_pascal }}Response {
                    id: e.id,
                    name: e.name,
                    description: e.description.unwrap_or_default(),
                    status: e.status,
                    created_at: e.created_at,
                    updated_at: e.updated_at,
                }).collect();
                Ok(Response::new(List{{ service_name_pascal }}Response { items }))
            }
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn create_{{ service_name_snake }}(
        &self,
        _request: Request<Create{{ service_name_pascal }}Request>,
    ) -> Result<Response<Create{{ service_name_pascal }}Response>, Status> {
        // TODO: 実装
        Ok(Response::new(Create{{ service_name_pascal }}Response {
            id: "todo".to_string(),
        }))
    }
}
{% endif %}
```

### src/adapter/handler/ — GraphQL (async-graphql)

`src/adapter/handler/graphql.rs.tera` — {% if api_styles is containing("graphql") %} に該当。

```rust
{% if api_styles is containing("graphql") %}
use async_graphql::{Context, Object, Schema, EmptyMutation, EmptySubscription};
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::usecase::{{ service_name_pascal }}UseCase;

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn {{ service_name_snake }}(
        &self,
        ctx: &Context<'_>,
        id: String,
    ) -> async_graphql::Result<Option<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_by_id(&id).await?)
    }

    async fn {{ service_name_snake }}_list(
        &self,
        ctx: &Context<'_>,
    ) -> async_graphql::Result<Vec<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_all().await?)
    }
}

pub type {{ service_name_pascal }}Schema = Schema<QueryRoot, EmptyMutation, EmptySubscription>;

pub fn build_schema(uc: {{ service_name_pascal }}UseCase) -> {{ service_name_pascal }}Schema {
    Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
        .data(Arc::new(uc))
        .finish()
}
{% endif %}
```

### src/adapter/handler/mod.rs

`src/adapter/handler/mod.rs.tera` — ハンドラーモジュール宣言。

```rust
{% if api_styles is containing("rest") %}
mod rest;
pub use rest::AppHandler;
{% elif api_styles is containing("grpc") %}
mod grpc;
pub use grpc::{{ service_name_pascal }}GrpcService as AppHandler;
{% elif api_styles is containing("graphql") %}
mod graphql;
pub use graphql::{build_schema, {{ service_name_pascal }}Schema, QueryRoot};
{% endif %}
```

### src/infra/mod.rs

`src/infra/mod.rs.tera` — インフラモジュール宣言。

```rust
pub mod config;
{% if has_database %}
pub mod persistence;
{% endif %}
{% if has_kafka %}
pub mod messaging;
{% endif %}
```

### src/infra/persistence.rs

`src/infra/persistence.rs.tera` — {% if has_database %} に該当。sqlx 接続プール。

```rust
{% if has_database %}
use sqlx::{{ database_type }}::{{ database_type | title }}Pool;
use sqlx::{{ database_type }}::{{ database_type | title }}PoolOptions;
use async_trait::async_trait;
use std::time::Duration;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::domain::repository::{{ service_name_pascal }}Repository;
use crate::infra::config::DatabaseConfig;

pub type DbPool = {{ database_type | title }}Pool;

pub async fn create_pool(cfg: &DatabaseConfig) -> anyhow::Result<DbPool> {
    let pool = {{ database_type | title }}PoolOptions::new()
        .max_connections(cfg.pool.max_open)
        .idle_timeout(Duration::from_secs(cfg.pool.max_lifetime_sec))
        .connect(&cfg.connection_string())
        .await?;
    Ok(pool)
}

pub struct Repository {
    pool: DbPool,
}

impl Repository {
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl {{ service_name_pascal }}Repository for Repository {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
        let entity = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        Ok(entity)
    }

    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
        let entities = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;
        Ok(entities)
    }

    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "INSERT INTO examples (id, name, description, status) VALUES ($1, $2, $3, $4)"
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "UPDATE examples SET name = $1, description = $2, status = $3 WHERE id = $4"
        )
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .bind(&entity.id)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn delete(&self, id: &str) -> anyhow::Result<()> {
        sqlx::query("DELETE FROM examples WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}
{% endif %}
```

### src/infra/messaging.rs

`src/infra/messaging.rs.tera` — {% if has_kafka %} に該当。[メッセージング設計.md](メッセージング設計.md) D-119 準拠。

```rust
{% if has_kafka %}
use rdkafka::config::ClientConfig;
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{StreamConsumer, Consumer as _};
use rdkafka::Message;
use std::time::Duration;

use crate::infra::config::KafkaConfig;

/// Producer は Kafka プロデューサー。
/// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
pub struct Producer {
    producer: FutureProducer,
}

impl Producer {
    pub fn new(cfg: &KafkaConfig) -> Self {
        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .create()
            .expect("Failed to create Kafka producer");
        Self { producer }
    }

    pub async fn publish(&self, topic: &str, key: &str, payload: &[u8]) -> anyhow::Result<()> {
        self.producer
            .send(
                FutureRecord::to(topic)
                    .key(key)
                    .payload(payload),
                Duration::from_secs(5),
            )
            .await
            .map_err(|(e, _)| anyhow::anyhow!("Failed to publish: {}", e))?;
        Ok(())
    }
}

/// Consumer は Kafka コンシューマー。
/// コンシューマーグループ命名規則: {service-name}.{purpose}
pub struct KafkaConsumer {
    consumer: StreamConsumer,
}

impl KafkaConsumer {
    pub fn new(cfg: &KafkaConfig, group_id: &str, topics: &[&str]) -> Self {
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .set("group.id", group_id)
            .set("auto.offset.reset", "earliest")
            .create()
            .expect("Failed to create Kafka consumer");
        consumer.subscribe(topics).expect("Failed to subscribe");
        Self { consumer }
    }
}
{% endif %}
```

### src/infra/config.rs

`src/infra/config.rs.tera` — [config設計.md](config設計.md) 準拠の設定ローダー。

```rust
use serde::Deserialize;
use std::fs;

/// Config はアプリケーション設定の全体構造。
#[derive(Debug, Deserialize)]
pub struct Config {
    pub app: AppConfig,
    pub server: ServerConfig,
{% if has_database %}
    pub database: DatabaseConfig,
{% endif %}
{% if has_kafka %}
    pub kafka: KafkaConfig,
{% endif %}
{% if has_redis %}
    pub redis: RedisConfig,
{% endif %}
    pub observability: ObservabilityConfig,
}

#[derive(Debug, Deserialize)]
pub struct AppConfig {
    pub name: String,
    pub version: String,
    pub environment: String,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub port: String,
    pub read_timeout_sec: u64,
    pub write_timeout_sec: u64,
}

{% if has_database %}
#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub user: String,
    pub password: String,
    pub name: String,
{% if database_type == "postgresql" %}
    pub ssl_mode: String,
{% endif %}
    pub pool: PoolConfig,
}

#[derive(Debug, Deserialize)]
pub struct PoolConfig {
    pub max_open: u32,
    pub max_idle: u32,
    pub max_lifetime_sec: u64,
}

impl DatabaseConfig {
    pub fn connection_string(&self) -> String {
{% if database_type == "postgresql" %}
        format!(
            "postgres://{}:{}@{}:{}/{}?sslmode={}",
            self.user, self.password, self.host, self.port, self.name, self.ssl_mode
        )
{% elif database_type == "mysql" %}
        format!(
            "mysql://{}:{}@{}:{}/{}",
            self.user, self.password, self.host, self.port, self.name
        )
{% elif database_type == "sqlite" %}
        self.name.clone()
{% endif %}
    }
}
{% endif %}

{% if has_kafka %}
#[derive(Debug, Deserialize)]
pub struct KafkaConfig {
    pub brokers: Vec<String>,
    pub schema_registry: String,
}
{% endif %}

{% if has_redis %}
#[derive(Debug, Deserialize)]
pub struct RedisConfig {
    pub addr: String,
    pub password: String,
    pub db: u32,
}
{% endif %}

#[derive(Debug, Deserialize)]
pub struct ObservabilityConfig {
    pub trace_endpoint: String,
    pub metric_endpoint: String,
    pub log_level: String,
}

impl Config {
    pub fn load(path: &str) -> anyhow::Result<Self> {
        let content = fs::read_to_string(path)?;
        let config: Config = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

### Dockerfile (Rust)

`Dockerfile.tera` — [Dockerイメージ戦略.md](Dockerイメージ戦略.md) 準拠。

```dockerfile
# === Build Stage ===
FROM rust:1.82-bookworm AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY . .
RUN cargo build --release

# === Runtime Stage ===
FROM gcr.io/distroless/cc-debian12

COPY --from=builder /app/target/release/{{ rust_crate }} /app/server
COPY --from=builder /app/config /config

EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/app/server"]
```

---

## GraphQL スキーマ定義テンプレート

GraphQL（`api_styles is containing("graphql")`）選択時に生成されるスキーマ定義ファイル。API設計.md D-011 / D-124 に準拠する。

### Go: api/graphql/schema.graphql

`api/graphql/schema.graphql.tera` — GraphQL スキーマ定義。gqlgen のスキーマファースト開発（API設計.md D-124）で使用する。

```graphql
{% if api_styles is containing("graphql") %}
type Query {
  {{ service_name_camel }}(id: ID!): {{ service_name_pascal }}
  {{ service_name_camel }}List: [{{ service_name_pascal }}!]!
}

type {{ service_name_pascal }} {
  id: ID!
  name: String!
  description: String
  status: String!
  createdAt: String!
  updatedAt: String!
}

input Create{{ service_name_pascal }}Input {
  name: String!
  description: String
}
{% endif %}
```

### Go: gqlgen.yml

`gqlgen.yml.tera` — gqlgen コード生成設定。API設計.md D-124 に基づく。

```yaml
{% if api_styles is containing("graphql") %}
schema:
  - api/graphql/*.graphql
exec:
  filename: internal/adapter/graphql/generated.go
  package: graphql
model:
  filename: internal/adapter/graphql/models_gen.go
  package: graphql
resolver:
  layout: follow-schema
  dir: internal/adapter/graphql
  package: graphql
{% endif %}
```

### Rust（スキーマファイルなし）

Rust は async-graphql のマクロベース（コードファースト）方式を採用するため、スキーマファイルおよび gqlgen 設定は生成しない。スキーマ定義は `src/adapter/handler/graphql.rs.tera` 内のマクロアトリビュートで記述する（API設計.md D-124 参照）。

---

## buf 設定テンプレート

gRPC（`api_styles is containing("grpc")`）選択時に生成される buf 設定ファイル。API設計.md D-009 に準拠し、proto ファイルの lint・破壊的変更検出・コード生成を制御する。

### Go: buf.yaml

`buf.yaml.tera` — buf の lint・breaking change 検出設定。

```yaml
{% if api_styles is containing("grpc") %}
version: v2
modules:
  - path: api/proto
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
{% endif %}
```

### Go: buf.gen.yaml

`buf.gen.yaml.tera` — Go 向けコード生成設定。`buf generate` で protobuf + gRPC コードを生成する。

```yaml
{% if api_styles is containing("grpc") %}
version: v2
plugins:
  - remote: buf.build/protocolbuffers/go
    out: api/proto/gen
    opt: paths=source_relative
  - remote: buf.build/grpc/go
    out: api/proto/gen
    opt: paths=source_relative
{% endif %}
```

### Rust: buf.yaml

`buf.yaml.tera` — lint・breaking change 検出設定。Go 版と同一内容。

```yaml
{% if api_styles is containing("grpc") %}
version: v2
modules:
  - path: api/proto
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
{% endif %}
```

### Rust: build.rs（buf.gen.yaml の代替）

Rust は `tonic-build` を使用して `build.rs` から proto コードを生成する。buf は lint・breaking change 検出にのみ使用し、コード生成は行わない。

`build.rs.tera` — tonic-build によるコード生成。

```rust
{% if api_styles is containing("grpc") %}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::configure()
        .build_server(true)
        .build_client(false)
        .out_dir("src/proto")
        .compile_protos(
            &["api/proto/k1s0/{{ tier }}/{{ service_name_snake }}/v1/{{ service_name_snake }}.proto"],
            &["api/proto"],
        )?;
    Ok(())
}
{% endif %}
```

> **補足**: Rust の Cargo.toml テンプレートでは `[build-dependencies]` に `tonic-build = "0.12"` が含まれる。buf.gen.yaml は Go のみ生成し、Rust は build.rs で代替する。

---

## サーバー README テンプレート

サーバー種別に関わらず常に生成される README ファイル。プロジェクトの概要・セットアップ手順・ディレクトリ構成を記載する。

### Go: README.md

`README.md.tera` — Go サーバーの README。

```markdown
# {{ service_name }}

{{ service_name_pascal }} サーバー。

## セットアップ

```bash
# 依存解決
go mod tidy

# 開発サーバー起動
go run ./cmd/main.go

# テスト実行
go test ./...
```

## ディレクトリ構成

```
.
├── cmd/                  # エントリポイント
├── internal/
│   ├── domain/           # ドメインモデル・リポジトリインターフェース
│   ├── usecase/          # ビジネスロジック
│   ├── adapter/handler/  # ハンドラー（REST / gRPC / GraphQL）
│   └── infra/            # DB・メッセージング・設定
├── config/               # 設定ファイル
{% if api_styles is containing("rest") %}
├── api/openapi/          # OpenAPI 定義
{% endif %}
{% if api_styles is containing("grpc") %}
├── api/proto/            # Protocol Buffers 定義
{% endif %}
{% if api_styles is containing("graphql") %}
├── api/graphql/          # GraphQL スキーマ
{% endif %}
├── Dockerfile
└── README.md
```

## API

{% if api_styles is containing("rest") %}
- **方式**: REST（gin）
- **定義**: `api/openapi/openapi.yaml`
{% elif api_styles is containing("grpc") %}
- **方式**: gRPC（protobuf）
- **定義**: `api/proto/service.proto`
{% elif api_styles is containing("graphql") %}
- **方式**: GraphQL（gqlgen）
- **定義**: `api/graphql/schema.graphql`
{% endif %}

## 設定

`config/config.yaml` で接続先を管理する。環境別の上書きは `config/config.dev.yaml` を参照。
```

### Rust: README.md

`README.md.tera` — Rust サーバーの README。

```markdown
# {{ service_name }}

{{ service_name_pascal }} サーバー。

## セットアップ

```bash
# ビルド
cargo build

# 開発サーバー起動
cargo run

# テスト実行
cargo test
```

## ディレクトリ構成

```
.
├── src/
│   ├── main.rs           # エントリポイント
│   ├── domain/           # ドメインモデル・リポジトリ trait
│   ├── usecase/          # ビジネスロジック
│   ├── adapter/handler/  # ハンドラー（REST / gRPC / GraphQL）
│   └── infra/            # DB・メッセージング・設定
├── config/               # 設定ファイル
├── tests/                # 統合テスト
├── Cargo.toml
├── Dockerfile
└── README.md
```

## API

{% if api_styles is containing("rest") %}
- **方式**: REST（axum + utoipa）
{% elif api_styles is containing("grpc") %}
- **方式**: gRPC（tonic）
{% elif api_styles is containing("graphql") %}
- **方式**: GraphQL（async-graphql）
{% endif %}

## 設定

`config/config.yaml` で接続先を管理する。環境別の上書きは `config/config.dev.yaml` を参照。
```

---

## サーバーテストファイルテンプレート

サーバー種別に関わらず常に生成されるテストファイル。コーディング規約.md のテストツール選定に準拠する。

- **Go**: testify（アサーション）+ gomock（モック自動生成）
- **Rust**: mockall（モック自動生成）+ tokio test-util（async テスト）

### Go テンプレート

#### internal/usecase/usecase_test.go

`internal/usecase/usecase_test.go.tera` — ユースケース層の単体テスト。Repository モックを注入してビジネスロジックを検証する。

```go
package usecase

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
{% if has_database %}
	"go.uber.org/mock/gomock"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/domain/repository"
{% endif %}
)

{% if has_database %}
func TestGetByID(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	mockRepo.EXPECT().
		FindByID(gomock.Any(), "test-id").
		Return(&model.{{ service_name_pascal }}Entity{
			ID:   "test-id",
			Name: "test",
		}, nil)

	uc := New{{ service_name_pascal }}UseCase(mockRepo)
	result, err := uc.GetByID(context.Background(), "test-id")

	require.NoError(t, err)
	assert.Equal(t, "test-id", result.ID)
	assert.Equal(t, "test", result.Name)
}

func TestGetAll(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	mockRepo.EXPECT().
		FindAll(gomock.Any()).
		Return([]*model.{{ service_name_pascal }}Entity{
			{ID: "1", Name: "first"},
			{ID: "2", Name: "second"},
		}, nil)

	uc := New{{ service_name_pascal }}UseCase(mockRepo)
	result, err := uc.GetAll(context.Background())

	require.NoError(t, err)
	assert.Len(t, result, 2)
}

func TestCreate(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	entity := &model.{{ service_name_pascal }}Entity{
		Name: "new-entity",
	}

	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	mockRepo.EXPECT().
		Create(gomock.Any(), entity).
		Return(nil)

	uc := New{{ service_name_pascal }}UseCase(mockRepo)
	err := uc.Create(context.Background(), entity)

	require.NoError(t, err)
}
{% else %}
func TestPlaceholder(t *testing.T) {
	// TODO: ユースケーステストを実装する
	uc := New{{ service_name_pascal }}UseCase()
	assert.NotNil(t, uc)
}
{% endif %}
```

#### internal/adapter/handler/handler_test.go

`internal/adapter/handler/handler_test.go.tera` — ハンドラー層の単体テスト。API設計.md D-007 準拠のレスポンス形式を検証する。

```go
{% if api_styles is containing("rest") %}
package handler

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
{% if has_database %}
	"go.uber.org/mock/gomock"

	"{{ go_module }}/internal/domain/model"
	"{{ go_module }}/internal/domain/repository"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

func setupRouter(t *testing.T) (*gin.Engine, func()) {
	t.Helper()
	gin.SetMode(gin.TestMode)
{% if has_database %}
	ctrl := gomock.NewController(t)
	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	mockRepo.EXPECT().
		FindAll(gomock.Any()).
		Return([]*model.{{ service_name_pascal }}Entity{
			{ID: "1", Name: "test"},
		}, nil).AnyTimes()
	mockRepo.EXPECT().
		FindByID(gomock.Any(), "1").
		Return(&model.{{ service_name_pascal }}Entity{ID: "1", Name: "test"}, nil).AnyTimes()
	uc := usecase.New{{ service_name_pascal }}UseCase(mockRepo)
	cleanup := func() { ctrl.Finish() }
{% else %}
	uc := usecase.New{{ service_name_pascal }}UseCase()
	cleanup := func() {}
{% endif %}
	h := NewHandler(uc)
	r := gin.New()
	h.RegisterRoutes(r)
	return r, cleanup
}

func TestList(t *testing.T) {
	r, cleanup := setupRouter(t)
	defer cleanup()

	req := httptest.NewRequest(http.MethodGet, "/api/v1/{{ service_name }}", nil)
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestGetByID(t *testing.T) {
	r, cleanup := setupRouter(t)
	defer cleanup()

	req := httptest.NewRequest(http.MethodGet, "/api/v1/{{ service_name }}/1", nil)
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code)
}

func TestCreate(t *testing.T) {
	r, cleanup := setupRouter(t)
	defer cleanup()

	body := `{"name":"test","description":"desc"}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/{{ service_name }}", strings.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code)
}
{% endif %}
{% if api_styles is containing("grpc") %}
package handler

import (
	"context"
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"

{% if has_database %}
	"go.uber.org/mock/gomock"

	"{{ go_module }}/internal/domain/repository"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

const bufSize = 1024 * 1024

func setupGRPCServer(t *testing.T) (*grpc.ClientConn, func()) {
	t.Helper()
	lis := bufconn.Listen(bufSize)
{% if has_database %}
	ctrl := gomock.NewController(t)
	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	uc := usecase.New{{ service_name_pascal }}UseCase(mockRepo)
	cleanup := func() { ctrl.Finish() }
{% else %}
	uc := usecase.New{{ service_name_pascal }}UseCase()
	cleanup := func() {}
{% endif %}
	_ = uc // TODO: RegisterServer
	s := grpc.NewServer()
	go func() { _ = s.Serve(lis) }()

	conn, err := grpc.NewClient("passthrough:///bufnet",
		grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {
			return lis.Dial()
		}),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	require.NoError(t, err)
	teardown := func() {
		conn.Close()
		s.Stop()
		cleanup()
	}
	return conn, teardown
}

func TestGRPCPlaceholder(t *testing.T) {
	conn, teardown := setupGRPCServer(t)
	defer teardown()

	assert.NotNil(t, conn)
	// TODO: gRPC クライアントを使用したテストを実装する
}
{% endif %}
{% if api_styles is containing("graphql") %}
package handler

import (
	"testing"

	"github.com/stretchr/testify/assert"

{% if has_database %}
	"go.uber.org/mock/gomock"

	"{{ go_module }}/internal/domain/repository"
{% endif %}
	"{{ go_module }}/internal/usecase"
)

func TestGraphQLResolverCreation(t *testing.T) {
{% if has_database %}
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRepo := repository.NewMock{{ service_name_pascal }}Repository(ctrl)
	uc := usecase.New{{ service_name_pascal }}UseCase(mockRepo)
{% else %}
	uc := usecase.New{{ service_name_pascal }}UseCase()
{% endif %}
	resolver := NewResolver(uc)
	assert.NotNil(t, resolver)
	// TODO: gqlgen client を使用した統合テストを実装する
}
{% endif %}
```

#### internal/infra/persistence/repository_test.go

`internal/infra/persistence/repository_test.go.tera` — リポジトリ層の統合テスト。testcontainers を使用して実際の DB に対してテストする。

```go
{% if has_database %}
package persistence

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
{% if database_type == "postgresql" %}
	"github.com/testcontainers/testcontainers-go/modules/postgres"
{% endif %}
{% if database_type == "mysql" %}
	"github.com/testcontainers/testcontainers-go/modules/mysql"
{% endif %}
)

func TestRepositoryIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	ctx := context.Background()
{% if database_type == "postgresql" %}
	container, err := postgres.Run(ctx,
		"postgres:17-alpine",
		postgres.WithDatabase("testdb"),
		postgres.WithUsername("test"),
		postgres.WithPassword("test"),
	)
{% endif %}
{% if database_type == "mysql" %}
	container, err := mysql.Run(ctx,
		"mysql:8",
		mysql.WithDatabase("testdb"),
		mysql.WithUsername("test"),
		mysql.WithPassword("test"),
	)
{% endif %}
{% if database_type == "sqlite" %}
	// SQLite は testcontainers 不要
	_ = ctx
	t.Log("SQLite integration test placeholder")
	assert.True(t, true)
	return
{% endif %}
{% if database_type != "sqlite" %}
	require.NoError(t, err)
	defer func() { _ = container.Terminate(ctx) }()

	// TODO: マイグレーション実行 → Repository 初期化 → CRUD テスト
	assert.NotNil(t, container)
{% endif %}
}
{% endif %}
```

### Rust テンプレート

#### tests/integration_test.rs

`tests/integration_test.rs.tera` — サーバー統合テスト。mockall でリポジトリをモック化し、axum ハンドラーをテストする。

```rust
{% if api_styles is containing("rest") %}
use axum::body::Body;
use axum::http::{Request, StatusCode};
use tower::ServiceExt;

use {{ rust_crate }}::adapter::handler::rest::AppHandler;
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;
{% if has_database %}
use {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository;
use {{ rust_crate }}::domain::model::{{ service_name_pascal }}Entity;
{% endif %}

#[tokio::test]
async fn test_list_returns_ok() {
{% if has_database %}
    let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
    mock_repo.expect_find_all()
        .returning(|| Ok(vec![]));
    let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
{% else %}
    let uc = {{ service_name_pascal }}UseCase::new();
{% endif %}
    let handler = AppHandler::new(uc);
    let app = handler.routes();

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/{{ service_name }}")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_get_by_id_not_found() {
{% if has_database %}
    let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
    mock_repo.expect_find_by_id()
        .returning(|_| Ok(None));
    let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
{% else %}
    let uc = {{ service_name_pascal }}UseCase::new();
{% endif %}
    let handler = AppHandler::new(uc);
    let app = handler.routes();

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/{{ service_name }}/nonexistent")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);
}
{% endif %}
{% if api_styles is containing("grpc") %}
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;

#[tokio::test]
async fn test_grpc_placeholder() {
    // TODO: tonic テストクライアントを使用した統合テストを実装する
    let _uc = {{ service_name_pascal }}UseCase::new(
{% if has_database %}
        {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository::new(),
{% endif %}
    );
    assert!(true);
}
{% endif %}
{% if api_styles is containing("graphql") %}
use {{ rust_crate }}::adapter::handler::graphql::build_schema;
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;

#[tokio::test]
async fn test_graphql_schema_creation() {
    let uc = {{ service_name_pascal }}UseCase::new(
{% if has_database %}
        {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository::new(),
{% endif %}
    );
    let schema = build_schema(uc);
    let result = schema.execute("{ __typename }").await;
    assert!(result.errors.is_empty());
}
{% endif %}
```

---

## 既存ドキュメント参照マップ

各テンプレートファイルが準拠する既存ドキュメントの設計パターン。

| テンプレートファイル        | 参照ドキュメント                               | 該当セクション                                |
| --------------------------- | ---------------------------------------------- | --------------------------------------------- |
| config/config.yaml          | [config設計.md](config設計.md)                 | YAML スキーマ定義                             |
| adapter/handler (REST)      | [API設計.md](API設計.md)                       | D-007 エラーレスポンス、D-008 バージョニング  |
| adapter/handler (gRPC)      | [API設計.md](API設計.md)                       | D-009 gRPC 定義パターン、D-010 バージョニング |
| adapter/handler (GraphQL)   | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、D-124 実装技術選定        |
| api/openapi/                | [API設計.md](API設計.md)                       | D-123 oapi-codegen / utoipa                   |
| Dockerfile                  | [Dockerイメージ戦略.md](Dockerイメージ戦略.md) | ベースイメージ・マルチステージビルド          |
| infra/messaging             | [メッセージング設計.md](メッセージング設計.md) | D-119 Kafka トピック、D-120 イベント駆動      |
| OTel 初期化                 | [可観測性設計.md](可観測性設計.md)             | D-110 分散トレーシング                        |
| 構造化ログ (slog / tracing) | [可観測性設計.md](可観測性設計.md)             | D-109 構造化ログ                              |
| domain/repository           | [コーディング規約.md](コーディング規約.md)     | モック生成（gomock / mockall）                |
| api/graphql/schema.graphql  | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、D-124 実装技術選定       |
| gqlgen.yml                  | [API設計.md](API設計.md)                       | D-124 gqlgen 設定                            |
| buf.yaml / buf.gen.yaml     | [API設計.md](API設計.md)                       | D-009 gRPC 定義、buf lint・codegen           |
| build.rs（Rust gRPC）       | [API設計.md](API設計.md)                       | D-009 tonic-build によるコード生成           |
| テストファイル（*_test.*）  | [コーディング規約.md](コーディング規約.md)     | テストツール（testify / gomock / mockall）    |
| oapi-codegen.yaml           | [API設計.md](API設計.md)                       | D-123 oapi-codegen コード生成設定            |
| README.md                   | —                                              | プロジェクト概要・セットアップ手順           |
| BFF テンプレート            | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、BFF パターン             |

## BFF (Backend for Frontend) テンプレート

### 概要

BFF（Backend for Frontend）は、フロントエンドクライアントに特化した API ゲートウェイパターンである。上流の各マイクロサービスを集約し、GraphQL エンドポイントとしてフロントエンドに提供する。

BFF テンプレートは以下の条件で生成される:

| 条件 | 値 |
|---|---|
| Tier | `service` |
| API 方式 | `graphql` を含む |
| BFF 言語 | CLI 対話フローで Go / Rust を選択 |

CLI の対話フローでは `step_detail_server()` 内で「GraphQL BFF を生成しますか？」と確認し、「はい」の場合に BFF 言語（Go / Rust）を選択する。`GenerateConfig.detail.bff_language` に `Some(Language::Go)` または `Some(Language::Rust)` が設定される。

### BFF 設計原則

- **DB / Kafka / Redis を使用しない** — BFF はデータストアを持たず、上流サーバーへの HTTP プロキシのみを行う
- **GraphQL + HTTP のみ** — クライアントとの通信は GraphQL、上流サービスとの通信は HTTP（REST / gRPC クライアント）
- **テンプレート変数**: `service_name` に `-bff` サフィックスを付与（例: `order-bff`）

### 配置パス

BFF は親サーバーのディレクトリ内に `bff/` サブディレクトリとして生成される。

```
regions/service/{service_name}/server/{server_lang}/bff/
```

例: `regions/service/order/server/go/bff/`

> **注記**: `{server_lang}` はサーバー本体の言語ディレクトリ。BFF 言語の選択は BFF 内部のスケルトンコード生成に影響するが、配置パスはサーバー本体の言語に従う。

### Go BFF ディレクトリ構造

```
bff/go/
├── cmd/main.go
├── go.mod
├── internal/handler/graphql_resolver.go
├── api/graphql/schema.graphql
├── api/graphql/gqlgen.yml
├── config/config.yaml
├── Dockerfile
└── README.md
```

| ファイル | 説明 |
|---|---|
| `cmd/main.go` | エントリポイント。gin + gqlgen ルーター初期化 |
| `go.mod` | 依存定義。gin + gqlgen + HTTP クライアントのみ |
| `internal/handler/graphql_resolver.go` | GraphQL リゾルバー。上流サービスへの HTTP コールを実装 |
| `api/graphql/schema.graphql` | GraphQL スキーマ定義 |
| `api/graphql/gqlgen.yml` | gqlgen コード生成設定 |
| `config/config.yaml` | サーバーポート・上流サービス URL の設定 |
| `Dockerfile` | マルチステージビルド。distroless ランタイム |
| `README.md` | セットアップ手順・API 概要 |

### Rust BFF ディレクトリ構造

```
bff/rust/
├── src/main.rs
├── src/handler/graphql.rs
├── Cargo.toml
├── config/config.yaml
├── Dockerfile
└── README.md
```

| ファイル | 説明 |
|---|---|
| `src/main.rs` | エントリポイント。axum + async-graphql ルーター初期化 |
| `src/handler/graphql.rs` | GraphQL リゾルバー。reqwest による上流サービス呼び出し |
| `Cargo.toml` | 依存定義。axum + async-graphql + reqwest のみ |
| `config/config.yaml` | サーバーポート・上流サービス URL の設定 |
| `Dockerfile` | マルチステージビルド。distroless ランタイム |
| `README.md` | セットアップ手順・API 概要 |

### 生成ロジック

`execute.rs` の `execute_generate_at()` / `execute_generate_with_config()` において、以下の条件で BFF ディレクトリが追加生成される:

```rust
if config.kind == Kind::Server
    && config.tier == Tier::Service
    && config.detail.api_styles.contains(&ApiStyle::GraphQL)
{
    let bff_path = output_path.join("bff");
    fs::create_dir_all(&bff_path)?;
}
```

`bff_language` が `None` の場合でも `service + GraphQL` の条件を満たせば空の `bff/` ディレクトリが作成される（後方互換性維持）。`bff_language` が `Some(Language::Go)` または `Some(Language::Rust)` の場合は、対応する言語のスケルトンコードが生成される。

---

## TODO スタブ実装方針

### 概要

テンプレートから生成されるスケルトンコードには、未実装箇所を示す TODO スタブが含まれる。本セクションでは、スタブの記述方針と各言語のパターンを定義する。

### スケルトンコードの原則

1. **コンパイル可能であること** — 生成直後に `go build` / `cargo build` が成功すること
2. **テスト可能であること** — 最低限のインターフェース実装が存在し、テストランナーが実行可能であること
3. **最小限の依存のみ** — 未使用の依存は含めない。必要な依存は `go.mod` / `Cargo.toml` に記載済みであること

### Go のスタブパターン

Go では、関数のシグネチャに応じて以下のスタブ値を返す。

| 戻り値の型 | スタブ値 | 例 |
|---|---|---|
| `error` | `nil` | `return nil` |
| `(*T, error)` | `nil, nil` | `return nil, nil` |
| `([]T, error)` | `nil, nil` | `return nil, nil` |
| `T`（値型） | ゼロ値 | `return ""`, `return 0` |

コメント付きスタブの記述例:

```go
func (uc *OrderUseCase) GetByID(ctx context.Context, id string) (*model.OrderEntity, error) {
    // TODO: 実装
    return nil, nil
}
```

テストのスタブ:

```go
func TestPlaceholder(t *testing.T) {
    // TODO: ユースケーステストを実装する
    uc := NewOrderUseCase()
    assert.NotNil(t, uc)
}
```

### Rust のスタブパターン

Rust では、コンパイル可能性を優先し、以下の段階的なスタブパターンを使用する。

| パターン | 用途 | コンパイル | 実行時 |
|---|---|---|---|
| `todo!()` | 未実装を明示（開発初期） | 可能 | パニック |
| `unimplemented!()` | 意図的に未実装（インターフェース実装時） | 可能 | パニック |
| 最小実装 | テスト可能なスタブ（テンプレートデフォルト） | 可能 | 正常動作 |

テンプレートでは **最小実装** パターンをデフォルトとする。これにより、生成直後にテストが通る状態を保証する。

```rust
pub async fn get_by_id(&self, id: &str) -> anyhow::Result<Option<OrderEntity>> {
    // TODO: 実装
    Ok(None)
}

pub async fn get_all(&self) -> anyhow::Result<Vec<OrderEntity>> {
    // TODO: 実装
    Ok(vec![])
}

pub async fn create(&self, entity: &OrderEntity) -> anyhow::Result<()> {
    // TODO: 実装
    Ok(())
}
```

gRPC ハンドラーのスタブ:

```rust
async fn create_order(
    &self,
    _request: Request<CreateOrderRequest>,
) -> Result<Response<CreateOrderResponse>, Status> {
    // TODO: 実装
    Ok(Response::new(CreateOrderResponse {
        id: "todo".to_string(),
    }))
}
```

### TODO コメント規約

- すべての TODO スタブには `// TODO: ` プレフィックスを付与する
- grep / IDE で一括検索可能な統一フォーマットとする
- 具体的な実装内容を示す場合は `// TODO: req → entity 変換、uc.Create 呼び出し` のように記述する
- テストの TODO は `// TODO: gRPC クライアントを使用した統合テストを実装する` のように次のアクションを明示する

---

## 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) — 変数置換・条件分岐の仕様
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) — クライアントテンプレート
- [テンプレート仕様-ライブラリ](テンプレート仕様-ライブラリ.md) — ライブラリテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) — データベーステンプレート
- [CLIフロー](CLIフロー.md) — CLI の対話フローと操作手順
- [ディレクトリ構成図](ディレクトリ構成図.md) — 生成先ディレクトリ構成
- [API設計](API設計.md) — REST / gRPC / GraphQL 設計
- [config設計](config設計.md) — config.yaml スキーマと環境別管理
- [可観測性設計](可観測性設計.md) — 監視・トレーシング設計
- [Dockerイメージ戦略](Dockerイメージ戦略.md) — Docker ビルド戦略
- [メッセージング設計](メッセージング設計.md) — Kafka トピック・イベント駆動設計
- [コーディング規約](コーディング規約.md) — Linter・Formatter・テストツール
