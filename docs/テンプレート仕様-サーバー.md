# テンプレート仕様 — サーバー

## 概要

本ドキュメントは、k1s0 CLI の「ひな形生成」機能でサーバーを選択した際に生成される **全ファイルのスケルトンコード** を定義する。対象フレームワークは **Rust (axum + tokio)**。

クリーンアーキテクチャに基づく4レイヤー構成を採用する。

```
domain（エンティティ・リポジトリインターフェース）
  ↑
usecase（ビジネスロジック）
  ↑
adapter（ハンドラー・プレゼンター）
  ↑
infra（DB接続・メッセージング・設定ローダー）
```

## 条件付き生成表

CLI の対話フローで選択されたオプションに応じて、生成されるファイルが変わる。

| 条件                      | 選択肢                            | 影響を受けるファイル                                             |
| ------------------------- | --------------------------------- | ---------------------------------------------------------------- |
| API 方式 (`api_styles`)   | `rest`                            | handler/rest, OpenAPI 定義                                       |
|                           | `grpc`                            | handler/grpc, proto 定義, buf.yaml                               |
|                           | `graphql`                         | handler/graphql, schema.graphql（Rust はコードファースト）        |
| DB 有無 (`has_database`)  | `true`                            | persistence, config 内 database セクション, migrations/          |
|                           | `false`                           | 上記を生成しない                                                 |
| DB 種別 (`database_type`) | `postgresql` / `mysql` / `sqlite` | sqlx ドライバ依存、接続文字列形式                                |
| Kafka 有無 (`has_kafka`)  | `true`                            | messaging, config 内 kafka セクション                            |
|                           | `false`                           | 上記を生成しない                                                 |
| Redis 有無 (`has_redis`)  | `true`                            | config 内 redis セクション                                       |
|                           | `false`                           | 上記を生成しない                                                 |
| BFF (`bff_language`)      | `Go` / `Rust`                     | bff/ ディレクトリ（GraphQL + HTTP のみ、DB/Kafka/Redis なし）            |
| 常に生成                  | —                                 | テストファイル（usecase_test, handler_test, repository_test 等）、README.md |
| 常に生成                  | —                                 | observability（tracer, metrics）、auth middleware、rbac middleware        |
| API 方式 (`api_styles`)   | `grpc`                            | gRPC Health Check ハンドラー（grpc_health）                              |
| API 方式 (`api_styles`)   | `graphql`                         | GraphQL Subscription 型定義、WebSocket transport 設定                    |

### 複数 API 方式の同時選択

`api_styles` は配列型であり、REST と gRPC を同時に選択可能。テンプレート内では `api_styles is containing("xxx")` パターンで条件分岐を行う。

```tera
{% if api_styles is containing("rest") %}
  {# REST 固有のファイル内容 #}
{% endif %}
{% if api_styles is containing("grpc") %}
  {# gRPC 固有のファイル内容 #}
{% endif %}
```

REST + gRPC 同時選択時の生成ファイル一覧（Rust の例）:

| カテゴリ | 生成されるファイル |
|---|---|
| REST 固有 | `src/adapter/handler/rest.rs`, `api/openapi/openapi.yaml` |
| gRPC 固有 | `src/adapter/handler/grpc.rs`, `api/proto/service.proto`, `buf.yaml`, `build.rs` |
| 共通 | `Cargo.toml`（両方の依存を含む）, `src/main.rs`, ドメイン層, インフラ層 |

## Tier 別配置パス

| Tier     | 配置パス                                                  |
| -------- | --------------------------------------------------------- |
| system   | `regions/system/server/{lang}/{service_name}/`            |
| business | `regions/business/{domain}/server/{lang}/{service_name}/` |
| service  | `regions/service/{service_name}/server/{lang}/`           |

配置パスは CLI の `build_output_path()` で Tier・領域名・サービス名から動的に構築される。テンプレート内では `{{ rust_crate }}` でクレートパスを参照する。

---

## Rust (axum + tokio) テンプレート

### Redis クライアント

`has_redis = true` の場合に生成される Redis キャッシュクライアント。`redis_session`（BFF用セッション管理）とは独立した汎用キャッシュクライアントである。

#### `src/infra/redis_client.rs`

テンプレート: `CLI/templates/server/rust/src/infra/redis_client.rs.tera`

redis クレートのラッパーとして以下のメソッドを提供する:
- `RedisClient::new(cfg)` — クライアント初期化
- `get(key)` — キャッシュ取得
- `set(key, value, ttl_secs)` — TTL付きキャッシュ保存
- `delete(key)` — キャッシュ削除
- `ping()` — ヘルスチェック

### config/config.yaml

`config/config.yaml.tera` — [config設計.md](config設計.md) 準拠のアプリケーション設定ファイル。

```yaml
app:
  name: "{{ service_name }}"
  version: "0.1.0"
  environment: "development"

server:
  port: "8080"
  read_timeout_sec: 30
  write_timeout_sec: 30

{% if has_database %}
database:
  host: "localhost"
{% if database_type == "postgresql" %}
  port: 5432
{% elif database_type == "mysql" %}
  port: 3306
{% endif %}
  user: "{{ service_name_snake }}"
  password: ""
  name: "{{ service_name_snake }}"
{% if database_type == "postgresql" %}
  ssl_mode: "disable"
{% endif %}
  pool:
    max_open: 25
    max_idle: 5
    max_lifetime_sec: 300
{% endif %}

{% if has_kafka %}
kafka:
  brokers:
    - "localhost:9092"
  schema_registry: "http://localhost:8081"
{% endif %}

{% if has_redis %}
redis:
  addr: "localhost:6379"
  password: ""
  db: 0
{% endif %}

observability:
  trace_endpoint: "localhost:4317"
  metric_endpoint: "localhost:4317"
  log_level: "info"
```

### api/openapi/openapi.yaml

`api/openapi/openapi.yaml.tera` — {% if api_styles is containing("rest") %} に該当。OpenAPI 3.0 定義。[API設計.md](API設計.md) D-123 utoipa に準拠する。

```yaml
{% if api_styles is containing("rest") %}
openapi: "3.0.3"
info:
  title: "{{ service_name_pascal }} API"
  version: "1.0.0"
  description: "{{ service_name }} の REST API 定義"
servers:
  - url: "http://localhost:8080"
    description: "ローカル開発環境"
paths:
  /api/v1/{{ service_name }}:
    get:
      summary: "一覧取得"
      operationId: "list{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/{{ service_name_pascal }}"
    post:
      summary: "新規作成"
      operationId: "create{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Create{{ service_name_pascal }}Request"
      responses:
        "201":
          description: "作成成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "400":
          description: "バリデーションエラー"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /api/v1/{{ service_name }}/{id}:
    get:
      summary: "ID 指定取得"
      operationId: "get{{ service_name_pascal }}"
      tags:
        - "{{ service_name }}"
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: "成功"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/{{ service_name_pascal }}"
        "404":
          description: "リソースが見つからない"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
components:
  schemas:
    {{ service_name_pascal }}:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        description:
          type: string
        status:
          type: string
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time
    Create{{ service_name_pascal }}Request:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          maxLength: 255
        description:
          type: string
    ErrorResponse:
      type: object
      properties:
        code:
          type: string
        message:
          type: string
{% endif %}
```

### api/proto/service.proto

`api/proto/service.proto.tera` — {% if api_styles is containing("grpc") %} に該当。[API設計.md](API設計.md) D-009 gRPC 定義パターンに従う。

```proto
{% if api_styles is containing("grpc") %}
syntax = "proto3";

package {{ service_name_snake }}.v1;

// {{ service_name_pascal }}Service は {{ service_name }} の gRPC サービス定義。
service {{ service_name_pascal }}Service {
  rpc Get{{ service_name_pascal }} (Get{{ service_name_pascal }}Request) returns (Get{{ service_name_pascal }}Response);
  rpc List{{ service_name_pascal }} (List{{ service_name_pascal }}Request) returns (List{{ service_name_pascal }}Response);
  rpc Create{{ service_name_pascal }} (Create{{ service_name_pascal }}Request) returns (Create{{ service_name_pascal }}Response);
}

message Get{{ service_name_pascal }}Request {
  string id = 1;
}

message Get{{ service_name_pascal }}Response {
  string id = 1;
  string name = 2;
  string description = 3;
  string status = 4;
  string created_at = 5;
  string updated_at = 6;
}

message List{{ service_name_pascal }}Request {}

message List{{ service_name_pascal }}Response {
  repeated Get{{ service_name_pascal }}Response items = 1;
}

message Create{{ service_name_pascal }}Request {
  string name = 1;
  string description = 2;
}

message Create{{ service_name_pascal }}Response {
  string id = 1;
}
{% endif %}
```

### Cargo.toml

`Cargo.toml.tera` — クレート定義と依存関係。

```toml
[package]
name = "{{ rust_crate }}"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_yaml = "0.9"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }
opentelemetry = "0.24"
opentelemetry-otlp = "0.17"
opentelemetry_sdk = "0.24"
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace"] }
thiserror = "2"
{% if api_styles is containing("rest") %}
utoipa = { version = "5", features = ["axum_extras"] }
utoipa-swagger-ui = { version = "8", features = ["axum"] }
{% endif %}
{% if api_styles is containing("grpc") %}
tonic = "0.12"
prost = "0.13"
{% endif %}
{% if api_styles is containing("graphql") %}
async-graphql = "7"
async-graphql-axum = "7"
{% endif %}
{% if has_database %}
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "{{ database_type }}"] }
{% endif %}
{% if has_kafka %}
rdkafka = { version = "0.36", features = ["cmake-build"] }
{% endif %}
{% if has_redis %}
redis = { version = "0.27", features = ["tokio-comp"] }
{% endif %}

[dev-dependencies]
mockall = "0.13"
tokio = { version = "1", features = ["test-util", "macros"] }

{% if api_styles is containing("grpc") %}
[build-dependencies]
tonic-build = "0.12"
{% endif %}
```

### src/main.rs

`src/main.rs.tera` — エントリポイント。axum Router、tower ミドルウェア、graceful shutdown。

```rust
use axum::{routing::get, Json, Router};
use serde_json::json;
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;
use tower_http::trace::TraceLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod adapter;
mod domain;
mod infra;
mod usecase;

use infra::config::Config;

#[tokio::main]
async fn main() {
    // --- Logger ---
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer().json())
        .init();

    // --- Config ---
    let config = Config::load("config/config.yaml")
        .expect("Failed to load config");

{% if has_database %}
    // --- Database ---
    let pool = infra::persistence::create_pool(&config.database)
        .await
        .expect("Failed to connect to database");
{% endif %}

{% if has_kafka %}
    // --- Kafka ---
    let producer = infra::messaging::Producer::new(&config.kafka);
{% endif %}

    // --- DI: Repository → UseCase → Handler ---
{% if has_database %}
    let repo = infra::persistence::Repository::new(pool.clone());
{% endif %}
    let uc = usecase::{{ service_name_pascal }}UseCase::new(
{% if has_database %}
        repo,
{% endif %}
    );
    let handler = adapter::handler::AppHandler::new(uc);

    // --- Router ---
    let app = Router::new()
        .route("/healthz", get(|| async { Json(json!({"status": "ok"})) }))
        .route("/readyz", get({
{% if has_database %}
            let pool = pool.clone();
{% endif %}
            move || async move {
{% if has_database %}
                match sqlx::query("SELECT 1").execute(&pool).await {
                    Ok(_) => Json(json!({"status": "ready"})),
                    Err(_) => Json(json!({"status": "not ready"})),
                }
{% else %}
                Json(json!({"status": "ready"}))
{% endif %}
            }
        }))
        .merge(handler.routes())
        .layer(TraceLayer::new_for_http())
        .layer(CorsLayer::permissive());

    // --- Server ---
    let addr: SocketAddr = format!("0.0.0.0:{}", config.server.port)
        .parse()
        .expect("Invalid address");
    tracing::info!("server starting on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr)
        .await
        .expect("Failed to bind");

    // --- Graceful Shutdown ---
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .expect("Server error");
}

async fn shutdown_signal() {
    let ctrl_c = async {
        tokio::signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
            .expect("Failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }
    tracing::info!("shutdown signal received");
}
```

### src/domain/mod.rs

`src/domain/mod.rs.tera` — ドメインモジュール宣言。

```rust
pub mod model;
pub mod repository;
```

### src/domain/model.rs

`src/domain/model.rs.tera` — エンティティ定義。

```rust
use serde::{Deserialize, Serialize};

/// {{ service_name_pascal }}Entity はドメインエンティティを表す。
#[derive(Debug, Clone, Serialize, Deserialize)]
{% if has_database %}
#[derive(sqlx::FromRow)]
{% endif %}
pub struct {{ service_name_pascal }}Entity {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub created_at: String,
    pub updated_at: String,
}
```

### src/domain/repository.rs

`src/domain/repository.rs.tera` — リポジトリ trait。

```rust
use async_trait::async_trait;

use super::model::{{ service_name_pascal }}Entity;

/// {{ service_name_pascal }}Repository はデータアクセスの抽象化 trait。
#[cfg_attr(test, mockall::automock)]
#[async_trait]
pub trait {{ service_name_pascal }}Repository: Send + Sync {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>>;
    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>>;
    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()>;
    async fn delete(&self, id: &str) -> anyhow::Result<()>;
}
```

### src/usecase/mod.rs

`src/usecase/mod.rs.tera` — ユースケースモジュール。

```rust
pub mod service;

pub use service::{{ service_name_pascal }}UseCase;
```

### src/usecase/service.rs

`src/usecase/service.rs.tera` — ユースケース実装（DI パターン）。

```rust
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
{% if has_database %}
use crate::domain::repository::{{ service_name_pascal }}Repository;
{% endif %}

/// {{ service_name_pascal }}UseCase はビジネスロジックを提供する。
pub struct {{ service_name_pascal }}UseCase {
{% if has_database %}
    repo: Arc<dyn {{ service_name_pascal }}Repository>,
{% endif %}
}

impl {{ service_name_pascal }}UseCase {
    pub fn new(
{% if has_database %}
        repo: impl {{ service_name_pascal }}Repository + 'static,
{% endif %}
    ) -> Self {
        Self {
{% if has_database %}
            repo: Arc::new(repo),
{% endif %}
        }
    }

    pub async fn get_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_by_id(id).await
{% else %}
        // TODO: 実装
        Ok(None)
{% endif %}
    }

    pub async fn get_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
{% if has_database %}
        self.repo.find_all().await
{% else %}
        // TODO: 実装
        Ok(vec![])
{% endif %}
    }

    pub async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
{% if has_database %}
        self.repo.create(entity).await
{% else %}
        // TODO: 実装
        Ok(())
{% endif %}
    }

    pub async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
{% if has_database %}
        self.repo.update(entity).await
{% else %}
        // TODO: 実装
        Ok(())
{% endif %}
    }

    pub async fn delete(&self, id: &str) -> anyhow::Result<()> {
{% if has_database %}
        self.repo.delete(id).await
{% else %}
        // TODO: 実装
        Ok(())
{% endif %}
    }
}
```

### usecase_test のエラーケーステスト仕様（Rust）

`src/usecase/service.rs` 内の `#[cfg(test)]` モジュール — mockall を使用したエラーケーステスト。

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::repository::Mock{{ service_name_pascal }}Repository;

    #[tokio::test]
    async fn test_get_by_id_not_found() {
        let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
        mock_repo
            .expect_find_by_id()
            .with(mockall::predicate::eq("nonexistent"))
            .returning(|_| Ok(None));

        let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
        let result = uc.get_by_id("nonexistent").await.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn test_create_duplicate() {
        let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
        mock_repo
            .expect_create()
            .returning(|_| Err(anyhow::anyhow!("duplicate entity")));

        let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
        let entity = {{ service_name_pascal }}Entity {
            id: "dup-id".to_string(),
            name: "duplicate".to_string(),
            description: None,
            status: "active".to_string(),
            created_at: "2024-01-01T00:00:00Z".to_string(),
            updated_at: "2024-01-01T00:00:00Z".to_string(),
        };
        let result = uc.create(&entity).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_update_not_found() {
        let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
        mock_repo
            .expect_update()
            .returning(|_| Err(anyhow::anyhow!("entity not found")));

        let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
        let entity = {{ service_name_pascal }}Entity {
            id: "nonexistent".to_string(),
            name: "updated".to_string(),
            description: None,
            status: "active".to_string(),
            created_at: "2024-01-01T00:00:00Z".to_string(),
            updated_at: "2024-01-01T00:00:00Z".to_string(),
        };
        let result = uc.update(&entity).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_delete_not_found() {
        let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
        mock_repo
            .expect_delete()
            .with(mockall::predicate::eq("nonexistent"))
            .returning(|_| Err(anyhow::anyhow!("entity not found")));

        let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
        let result = uc.delete("nonexistent").await;
        assert!(result.is_err());
    }
}
```

### src/adapter/mod.rs

`src/adapter/mod.rs.tera` — アダプターモジュール宣言。

```rust
pub mod handler;
```

### src/adapter/handler/ — REST (axum + utoipa)

`src/adapter/handler/rest.rs.tera` — {% if api_styles is containing("rest") %} に該当。

```rust
{% if api_styles is containing("rest") %}
use axum::{
    extract::{Path, State},
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

/// AppHandler は REST ハンドラーを提供する。
pub struct AppHandler {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl AppHandler {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }

    pub fn routes(&self) -> Router {
        let uc = self.uc.clone();
        Router::new()
            .route("/api/v1/{{ service_name }}", get(list).post(create))
            .route("/api/v1/{{ service_name }}/:id", get(get_by_id))
            .with_state(uc)
    }
}

/// ErrorResponse は API設計.md D-007 準拠のエラーレスポンス。
#[derive(Serialize)]
struct ErrorResponse {
    code: String,
    message: String,
}

async fn list(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
) -> Result<Json<Vec<crate::domain::model::{{ service_name_pascal }}Entity>>, StatusCode> {
    uc.get_all()
        .await
        .map(Json)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

async fn get_by_id(
    State(uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Path(id): Path<String>,
) -> Result<Json<crate::domain::model::{{ service_name_pascal }}Entity>, StatusCode> {
    match uc.get_by_id(&id).await {
        Ok(Some(entity)) => Ok(Json(entity)),
        Ok(None) => Err(StatusCode::NOT_FOUND),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

#[derive(Deserialize)]
struct CreateRequest {
    name: String,
    description: Option<String>,
}

async fn create(
    State(_uc): State<Arc<{{ service_name_pascal }}UseCase>>,
    Json(_req): Json<CreateRequest>,
) -> StatusCode {
    // TODO: req → entity 変換、uc.create 呼び出し
    StatusCode::CREATED
}
{% endif %}
```

### src/adapter/handler/ — gRPC (tonic)

`src/adapter/handler/grpc.rs.tera` — {% if api_styles is containing("grpc") %} に該当。

```rust
{% if api_styles is containing("grpc") %}
use tonic::{Request, Response, Status};
use std::sync::Arc;

use crate::usecase::{{ service_name_pascal }}UseCase;

pub mod proto {
    tonic::include_proto!("{{ service_name_snake }}.v1");
}

use proto::{{ service_name_snake }}_service_server::{{ service_name_pascal }}Service;
use proto::{
    Get{{ service_name_pascal }}Request, Get{{ service_name_pascal }}Response,
    List{{ service_name_pascal }}Request, List{{ service_name_pascal }}Response,
    Create{{ service_name_pascal }}Request, Create{{ service_name_pascal }}Response,
};

pub struct {{ service_name_pascal }}GrpcService {
    uc: Arc<{{ service_name_pascal }}UseCase>,
}

impl {{ service_name_pascal }}GrpcService {
    pub fn new(uc: {{ service_name_pascal }}UseCase) -> Self {
        Self { uc: Arc::new(uc) }
    }
}

#[tonic::async_trait]
impl {{ service_name_pascal }}Service for {{ service_name_pascal }}GrpcService {
    async fn get_{{ service_name_snake }}(
        &self,
        request: Request<Get{{ service_name_pascal }}Request>,
    ) -> Result<Response<Get{{ service_name_pascal }}Response>, Status> {
        let id = request.into_inner().id;
        match self.uc.get_by_id(&id).await {
            Ok(Some(entity)) => Ok(Response::new(Get{{ service_name_pascal }}Response {
                id: entity.id,
                name: entity.name,
                description: entity.description.unwrap_or_default(),
                status: entity.status,
                created_at: entity.created_at,
                updated_at: entity.updated_at,
            })),
            Ok(None) => Err(Status::not_found(format!("resource not found: {}", id))),
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn list_{{ service_name_snake }}(
        &self,
        _request: Request<List{{ service_name_pascal }}Request>,
    ) -> Result<Response<List{{ service_name_pascal }}Response>, Status> {
        match self.uc.get_all().await {
            Ok(entities) => {
                let items = entities.into_iter().map(|e| Get{{ service_name_pascal }}Response {
                    id: e.id,
                    name: e.name,
                    description: e.description.unwrap_or_default(),
                    status: e.status,
                    created_at: e.created_at,
                    updated_at: e.updated_at,
                }).collect();
                Ok(Response::new(List{{ service_name_pascal }}Response { items }))
            }
            Err(e) => Err(Status::internal(format!("internal error: {}", e))),
        }
    }

    async fn create_{{ service_name_snake }}(
        &self,
        _request: Request<Create{{ service_name_pascal }}Request>,
    ) -> Result<Response<Create{{ service_name_pascal }}Response>, Status> {
        // TODO: 実装
        Ok(Response::new(Create{{ service_name_pascal }}Response {
            id: "todo".to_string(),
        }))
    }
}
{% endif %}
```

### src/adapter/handler/ — GraphQL (async-graphql)

`src/adapter/handler/graphql.rs.tera` — {% if api_styles is containing("graphql") %} に該当。

```rust
{% if api_styles is containing("graphql") %}
use async_graphql::{Context, Object, Schema, EmptyMutation, EmptySubscription};
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::usecase::{{ service_name_pascal }}UseCase;

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn {{ service_name_snake }}(
        &self,
        ctx: &Context<'_>,
        id: String,
    ) -> async_graphql::Result<Option<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_by_id(&id).await?)
    }

    async fn {{ service_name_snake }}_list(
        &self,
        ctx: &Context<'_>,
    ) -> async_graphql::Result<Vec<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_all().await?)
    }
}

pub type {{ service_name_pascal }}Schema = Schema<QueryRoot, EmptyMutation, EmptySubscription>;

pub fn build_schema(uc: {{ service_name_pascal }}UseCase) -> {{ service_name_pascal }}Schema {
    Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
        .data(Arc::new(uc))
        .finish()
}
{% endif %}
```

### src/adapter/handler/mod.rs

`src/adapter/handler/mod.rs.tera` — ハンドラーモジュール宣言。

```rust
{% if api_styles is containing("rest") %}
mod rest;
pub use rest::AppHandler;
{% elif api_styles is containing("grpc") %}
mod grpc;
pub use grpc::{{ service_name_pascal }}GrpcService as AppHandler;
{% elif api_styles is containing("graphql") %}
mod graphql;
pub use graphql::{build_schema, {{ service_name_pascal }}Schema, QueryRoot};
{% endif %}
```

### src/infra/mod.rs

`src/infra/mod.rs.tera` — インフラモジュール宣言。

```rust
pub mod config;
{% if has_database %}
pub mod persistence;
{% endif %}
{% if has_kafka %}
pub mod messaging;
{% endif %}
```

### src/infra/persistence.rs

`src/infra/persistence.rs.tera` — {% if has_database %} に該当。sqlx 接続プール。

```rust
{% if has_database %}
use sqlx::{{ database_type }}::{{ database_type | title }}Pool;
use sqlx::{{ database_type }}::{{ database_type | title }}PoolOptions;
use async_trait::async_trait;
use std::time::Duration;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::domain::repository::{{ service_name_pascal }}Repository;
use crate::infra::config::DatabaseConfig;

pub type DbPool = {{ database_type | title }}Pool;

pub async fn create_pool(cfg: &DatabaseConfig) -> anyhow::Result<DbPool> {
    let pool = {{ database_type | title }}PoolOptions::new()
        .max_connections(cfg.pool.max_open)
        .idle_timeout(Duration::from_secs(cfg.pool.max_lifetime_sec))
        .connect(&cfg.connection_string())
        .await?;
    Ok(pool)
}

pub struct Repository {
    pool: DbPool,
}

impl Repository {
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl {{ service_name_pascal }}Repository for Repository {
    async fn find_by_id(&self, id: &str) -> anyhow::Result<Option<{{ service_name_pascal }}Entity>> {
        let entity = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        Ok(entity)
    }

    async fn find_all(&self) -> anyhow::Result<Vec<{{ service_name_pascal }}Entity>> {
        let entities = sqlx::query_as::<_, {{ service_name_pascal }}Entity>(
            "SELECT * FROM examples ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;
        Ok(entities)
    }

    async fn create(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "INSERT INTO examples (id, name, description, status) VALUES ($1, $2, $3, $4)"
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn update(&self, entity: &{{ service_name_pascal }}Entity) -> anyhow::Result<()> {
        sqlx::query(
            "UPDATE examples SET name = $1, description = $2, status = $3 WHERE id = $4"
        )
        .bind(&entity.name)
        .bind(&entity.description)
        .bind(&entity.status)
        .bind(&entity.id)
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    async fn delete(&self, id: &str) -> anyhow::Result<()> {
        sqlx::query("DELETE FROM examples WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        Ok(())
    }
}
{% endif %}
```

### src/infra/messaging.rs

`src/infra/messaging.rs.tera` — {% if has_kafka %} に該当。[メッセージング設計.md](メッセージング設計.md) D-119 準拠。

```rust
{% if has_kafka %}
use rdkafka::config::ClientConfig;
use rdkafka::producer::{FutureProducer, FutureRecord};
use rdkafka::consumer::{StreamConsumer, Consumer as _};
use rdkafka::Message;
use std::time::Duration;

use crate::infra::config::KafkaConfig;

/// Producer は Kafka プロデューサー。
/// トピック命名規則: k1s0.{tier}.{domain}.{event-type}.{version}
pub struct Producer {
    producer: FutureProducer,
}

impl Producer {
    pub fn new(cfg: &KafkaConfig) -> Self {
        let producer: FutureProducer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .create()
            .expect("Failed to create Kafka producer");
        Self { producer }
    }

    pub async fn publish(&self, topic: &str, key: &str, payload: &[u8]) -> anyhow::Result<()> {
        self.producer
            .send(
                FutureRecord::to(topic)
                    .key(key)
                    .payload(payload),
                Duration::from_secs(5),
            )
            .await
            .map_err(|(e, _)| anyhow::anyhow!("Failed to publish: {}", e))?;
        Ok(())
    }
}

/// Consumer は Kafka コンシューマー。
/// コンシューマーグループ命名規則: {service-name}.{purpose}
pub struct KafkaConsumer {
    consumer: StreamConsumer,
}

impl KafkaConsumer {
    pub fn new(cfg: &KafkaConfig, group_id: &str, topics: &[&str]) -> Self {
        let consumer: StreamConsumer = ClientConfig::new()
            .set("bootstrap.servers", cfg.brokers.join(","))
            .set("group.id", group_id)
            .set("auto.offset.reset", "earliest")
            .create()
            .expect("Failed to create Kafka consumer");
        consumer.subscribe(topics).expect("Failed to subscribe");
        Self { consumer }
    }
}
{% endif %}
```

### src/infra/config.rs

`src/infra/config.rs.tera` — [config設計.md](config設計.md) 準拠の設定ローダー。

```rust
use serde::Deserialize;
use std::fs;

/// Config はアプリケーション設定の全体構造。
#[derive(Debug, Deserialize)]
pub struct Config {
    pub app: AppConfig,
    pub server: ServerConfig,
{% if has_database %}
    pub database: DatabaseConfig,
{% endif %}
{% if has_kafka %}
    pub kafka: KafkaConfig,
{% endif %}
{% if has_redis %}
    pub redis: RedisConfig,
{% endif %}
    pub observability: ObservabilityConfig,
}

#[derive(Debug, Deserialize)]
pub struct AppConfig {
    pub name: String,
    pub version: String,
    pub environment: String,
}

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub port: String,
    pub read_timeout_sec: u64,
    pub write_timeout_sec: u64,
}

{% if has_database %}
#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub user: String,
    pub password: String,
    pub name: String,
{% if database_type == "postgresql" %}
    pub ssl_mode: String,
{% endif %}
    pub pool: PoolConfig,
}

#[derive(Debug, Deserialize)]
pub struct PoolConfig {
    pub max_open: u32,
    pub max_idle: u32,
    pub max_lifetime_sec: u64,
}

impl DatabaseConfig {
    pub fn connection_string(&self) -> String {
{% if database_type == "postgresql" %}
        format!(
            "postgres://{}:{}@{}:{}/{}?sslmode={}",
            self.user, self.password, self.host, self.port, self.name, self.ssl_mode
        )
{% elif database_type == "mysql" %}
        format!(
            "mysql://{}:{}@{}:{}/{}",
            self.user, self.password, self.host, self.port, self.name
        )
{% elif database_type == "sqlite" %}
        self.name.clone()
{% endif %}
    }
}
{% endif %}

{% if has_kafka %}
#[derive(Debug, Deserialize)]
pub struct KafkaConfig {
    pub brokers: Vec<String>,
    pub schema_registry: String,
}
{% endif %}

{% if has_redis %}
#[derive(Debug, Deserialize)]
pub struct RedisConfig {
    pub addr: String,
    pub password: String,
    pub db: u32,
}
{% endif %}

#[derive(Debug, Deserialize)]
pub struct ObservabilityConfig {
    pub trace_endpoint: String,
    pub metric_endpoint: String,
    pub log_level: String,
}

impl Config {
    pub fn load(path: &str) -> anyhow::Result<Self> {
        let content = fs::read_to_string(path)?;
        let config: Config = serde_yaml::from_str(&content)?;
        Ok(config)
    }
}
```

### Dockerfile

`Dockerfile.tera` — [Dockerイメージ戦略.md](Dockerイメージ戦略.md) 準拠。

```dockerfile
# === Build Stage ===
FROM rust:1.82-bookworm AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY . .
RUN cargo build --release

# === Runtime Stage ===
FROM gcr.io/distroless/cc-debian12

COPY --from=builder /app/target/release/{{ rust_crate }} /app/server
COPY --from=builder /app/config /config

EXPOSE 8080
USER nonroot:nonroot
ENTRYPOINT ["/app/server"]
```

---

## GraphQL スキーマ定義テンプレート

GraphQL（`api_styles is containing("graphql")`）選択時のスキーマ定義。API設計.md D-011 / D-124 に準拠する。

Rust は async-graphql のマクロベース（コードファースト）方式を採用するため、スキーマファイルは生成しない。スキーマ定義は `src/adapter/handler/graphql.rs.tera` 内のマクロアトリビュートで記述する（API設計.md D-124 参照）。

---

## buf 設定テンプレート

gRPC（`api_styles is containing("grpc")`）選択時に生成される buf 設定ファイル。API設計.md D-009 に準拠し、proto ファイルの lint・破壊的変更検出を制御する。コード生成は `tonic-build` を使用して `build.rs` から行う。

### buf.yaml

`buf.yaml.tera` — lint・breaking change 検出設定。

```yaml
{% if api_styles is containing("grpc") %}
version: v2
modules:
  - path: api/proto
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
{% endif %}
```

### build.rs

Rust は `tonic-build` を使用して `build.rs` から proto コードを生成する。buf は lint・breaking change 検出にのみ使用し、コード生成は行わない。

`build.rs.tera` — tonic-build によるコード生成。

```rust
{% if api_styles is containing("grpc") %}
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::configure()
        .build_server(true)
        .build_client(false)
        .out_dir("src/proto")
        .compile_protos(
            &["api/proto/k1s0/{{ tier }}/{{ service_name_snake }}/v1/{{ service_name_snake }}.proto"],
            &["api/proto"],
        )?;
    Ok(())
}
{% endif %}
```

> **補足**: Rust の Cargo.toml テンプレートでは `[build-dependencies]` に `tonic-build = "0.12"` が含まれる。

---

## サーバー README テンプレート

常に生成される README ファイル。プロジェクトの概要・セットアップ手順・ディレクトリ構成を記載する。

### README.md

`README.md.tera` — サーバーの README。

```markdown
# {{ service_name }}

{{ service_name_pascal }} サーバー。

## セットアップ

```bash
# ビルド
cargo build

# 開発サーバー起動
cargo run

# テスト実行
cargo test
```

## ディレクトリ構成

```
.
├── src/
│   ├── main.rs           # エントリポイント
│   ├── domain/           # ドメインモデル・リポジトリ trait
│   ├── usecase/          # ビジネスロジック
│   ├── adapter/handler/  # ハンドラー（REST / gRPC / GraphQL）
│   └── infra/            # DB・メッセージング・設定
├── config/               # 設定ファイル
├── tests/                # 統合テスト
├── Cargo.toml
├── Dockerfile
└── README.md
```

## API

{% if api_styles is containing("rest") %}
- **方式**: REST（axum + utoipa）
{% elif api_styles is containing("grpc") %}
- **方式**: gRPC（tonic）
{% elif api_styles is containing("graphql") %}
- **方式**: GraphQL（async-graphql）
{% endif %}

## 設定

`config/config.yaml` で接続先を管理する。環境別の上書きは `config/config.dev.yaml` を参照。
```

---

## サーバーテストファイルテンプレート

常に生成されるテストファイル。コーディング規約.md のテストツール選定に準拠する。

- **Rust**: mockall（モック自動生成）+ tokio test-util（async テスト）

### Rust テンプレート

#### tests/integration_test.rs

`tests/integration_test.rs.tera` — サーバー統合テスト。mockall でリポジトリをモック化し、axum ハンドラーをテストする。

```rust
{% if api_styles is containing("rest") %}
use axum::body::Body;
use axum::http::{Request, StatusCode};
use tower::ServiceExt;

use {{ rust_crate }}::adapter::handler::rest::AppHandler;
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;
{% if has_database %}
use {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository;
use {{ rust_crate }}::domain::model::{{ service_name_pascal }}Entity;
{% endif %}

#[tokio::test]
async fn test_list_returns_ok() {
{% if has_database %}
    let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
    mock_repo.expect_find_all()
        .returning(|| Ok(vec![]));
    let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
{% else %}
    let uc = {{ service_name_pascal }}UseCase::new();
{% endif %}
    let handler = AppHandler::new(uc);
    let app = handler.routes();

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/{{ service_name }}")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
}

#[tokio::test]
async fn test_get_by_id_not_found() {
{% if has_database %}
    let mut mock_repo = Mock{{ service_name_pascal }}Repository::new();
    mock_repo.expect_find_by_id()
        .returning(|_| Ok(None));
    let uc = {{ service_name_pascal }}UseCase::new(mock_repo);
{% else %}
    let uc = {{ service_name_pascal }}UseCase::new();
{% endif %}
    let handler = AppHandler::new(uc);
    let app = handler.routes();

    let response = app
        .oneshot(
            Request::builder()
                .uri("/api/v1/{{ service_name }}/nonexistent")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);
}
{% endif %}
{% if api_styles is containing("grpc") %}
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;

#[tokio::test]
async fn test_grpc_placeholder() {
    // TODO: tonic テストクライアントを使用した統合テストを実装する
    let _uc = {{ service_name_pascal }}UseCase::new(
{% if has_database %}
        {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository::new(),
{% endif %}
    );
    assert!(true);
}
{% endif %}
{% if api_styles is containing("graphql") %}
use {{ rust_crate }}::adapter::handler::graphql::build_schema;
use {{ rust_crate }}::usecase::{{ service_name_pascal }}UseCase;

#[tokio::test]
async fn test_graphql_schema_creation() {
    let uc = {{ service_name_pascal }}UseCase::new(
{% if has_database %}
        {{ rust_crate }}::domain::repository::Mock{{ service_name_pascal }}Repository::new(),
{% endif %}
    );
    let schema = build_schema(uc);
    let result = schema.execute("{ __typename }").await;
    assert!(result.errors.is_empty());
}
{% endif %}
```

---

## 既存ドキュメント参照マップ

各テンプレートファイルが準拠する既存ドキュメントの設計パターン。

| テンプレートファイル        | 参照ドキュメント                               | 該当セクション                                |
| --------------------------- | ---------------------------------------------- | --------------------------------------------- |
| config/config.yaml          | [config設計.md](config設計.md)                 | YAML スキーマ定義                             |
| adapter/handler (REST)      | [API設計.md](API設計.md)                       | D-007 エラーレスポンス、D-008 バージョニング  |
| adapter/handler (gRPC)      | [API設計.md](API設計.md)                       | D-009 gRPC 定義パターン、D-010 バージョニング |
| adapter/handler (GraphQL)   | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、D-124 実装技術選定        |
| api/openapi/                | [API設計.md](API設計.md)                       | D-123 oapi-codegen / utoipa                   |
| Dockerfile                  | [Dockerイメージ戦略.md](Dockerイメージ戦略.md) | ベースイメージ・マルチステージビルド          |
| infra/messaging             | [メッセージング設計.md](メッセージング設計.md) | D-119 Kafka トピック、D-120 イベント駆動      |
| OTel 初期化                 | [可観測性設計.md](可観測性設計.md)             | D-110 分散トレーシング                        |
| 構造化ログ (tracing)        | [可観測性設計.md](可観測性設計.md)             | D-109 構造化ログ                              |
| domain/repository           | [コーディング規約.md](コーディング規約.md)     | モック生成（mockall）                         |
| buf.yaml                    | [API設計.md](API設計.md)                       | D-009 gRPC 定義、buf lint                    |
| build.rs（Rust gRPC）       | [API設計.md](API設計.md)                       | D-009 tonic-build によるコード生成           |
| テストファイル（*_test.rs） | [コーディング規約.md](コーディング規約.md)     | テストツール（mockall）                       |
| README.md                   | —                                              | プロジェクト概要・セットアップ手順           |
| BFF テンプレート            | [API設計.md](API設計.md)                       | D-011 GraphQL 設計、BFF パターン             |

## BFF (Backend for Frontend) テンプレート

BFF テンプレートの詳細は [テンプレート仕様-BFF](テンプレート仕様-BFF.md) を参照。

BFF テンプレートは以下の条件で生成される:

| 条件 | 値 |
|---|---|
| Tier | `service` |
| API 方式 | `graphql` を含む |
| BFF 言語 | CLI 対話フローで Go / Rust を選択 |

### 生成ロジック

`execute.rs` の `execute_generate_at()` / `execute_generate_with_config()` において、以下の条件で BFF ディレクトリが追加生成される:

```rust
if config.kind == Kind::Server
    && config.tier == Tier::Service
    && config.detail.api_styles.contains(&ApiStyle::GraphQL)
{
    let bff_path = output_path.join("bff");
    fs::create_dir_all(&bff_path)?;
}
```

`bff_language` が `None` の場合でも `service + GraphQL` の条件を満たせば空の `bff/` ディレクトリが作成される（後方互換性維持）。`bff_language` が `Some(Language::Go)` または `Some(Language::Rust)` の場合は、対応する言語のスケルトンコードが生成される。

---

## TODO スタブ実装方針

### 概要

テンプレートから生成されるスケルトンコードには、未実装箇所を示す TODO スタブが含まれる。本セクションでは、スタブの記述方針と各言語のパターンを定義する。

### スケルトンコードの原則

1. **コンパイル可能であること** — 生成直後に `cargo build` が成功すること
2. **テスト可能であること** — 最低限のインターフェース実装が存在し、テストランナーが実行可能であること
3. **最小限の依存のみ** — 未使用の依存は含めない。必要な依存は `Cargo.toml` に記載済みであること

### Rust のスタブパターン

Rust では、コンパイル可能性を優先し、以下の段階的なスタブパターンを使用する。

| パターン | 用途 | コンパイル | 実行時 |
|---|---|---|---|
| `todo!()` | 未実装を明示（開発初期） | 可能 | パニック |
| `unimplemented!()` | 意図的に未実装（インターフェース実装時） | 可能 | パニック |
| 最小実装 | テスト可能なスタブ（テンプレートデフォルト） | 可能 | 正常動作 |

テンプレートでは **最小実装** パターンをデフォルトとする。これにより、生成直後にテストが通る状態を保証する。

```rust
pub async fn get_by_id(&self, id: &str) -> anyhow::Result<Option<OrderEntity>> {
    // TODO: 実装
    Ok(None)
}

pub async fn get_all(&self) -> anyhow::Result<Vec<OrderEntity>> {
    // TODO: 実装
    Ok(vec![])
}

pub async fn create(&self, entity: &OrderEntity) -> anyhow::Result<()> {
    // TODO: 実装
    Ok(())
}
```

gRPC ハンドラーのスタブ:

```rust
async fn create_order(
    &self,
    _request: Request<CreateOrderRequest>,
) -> Result<Response<CreateOrderResponse>, Status> {
    // TODO: 実装
    Ok(Response::new(CreateOrderResponse {
        id: "todo".to_string(),
    }))
}
```

### TODO コメント規約

- すべての TODO スタブには `// TODO: ` プレフィックスを付与する
- grep / IDE で一括検索可能な統一フォーマットとする
- 具体的な実装内容を示す場合は `// TODO: req → entity 変換、uc.Create 呼び出し` のように記述する
- テストの TODO は `// TODO: gRPC クライアントを使用した統合テストを実装する` のように次のアクションを明示する

---

## 可観測性テンプレート（Metrics / Tracing Exporter）

[可観測性設計.md](可観測性設計.md) D-107（監視・アラート設計）および D-110（分散トレーシング設計）に基づき、サーバーテンプレート生成時に可観測性のスケルトンコードを自動生成する。メトリクスは Prometheus 形式（RED メソッド）、トレースは OpenTelemetry OTLP gRPC Exporter を使用する。

#### src/infra/observability/tracer.rs

`src/infra/observability/tracer.rs.tera` — tracing-opentelemetry 初期化。[可観測性設計.md](可観測性設計.md) D-110 の Rust 実装例に準拠する。

```rust
use opentelemetry::global;
use opentelemetry_otlp::SpanExporter;
use opentelemetry_sdk::{trace as sdktrace, Resource};
use std::error::Error;

/// OpenTelemetry TracerProvider を初期化する。
/// OTLP gRPC exporter を使用して Jaeger/Collector にトレースを送信する。
pub fn init_tracer() -> Result<sdktrace::TracerProvider, Box<dyn Error>> {
    let exporter = SpanExporter::builder()
        .with_tonic()
        .build()?;

    let provider = sdktrace::TracerProvider::builder()
        .with_batch_exporter(exporter)
        .with_resource(
            Resource::builder()
                .with_service_name("{{ service_name }}")
                .build(),
        )
        .build();

    global::set_tracer_provider(provider.clone());
    Ok(provider)
}
```

#### src/infra/observability/metrics.rs

`src/infra/observability/metrics.rs.tera` — Prometheus metrics exporter。RED メソッドに基づくメトリクス公開。

```rust
use axum::{
    extract::MatchedPath,
    http::Request,
    middleware::Next,
    response::{IntoResponse, Response},
};
use prometheus::{
    register_counter_vec, register_histogram_vec, CounterVec, Encoder, HistogramVec,
    TextEncoder,
};
use std::time::Instant;

lazy_static::lazy_static! {
    static ref HTTP_REQUESTS_TOTAL: CounterVec = register_counter_vec!(
        "http_requests_total",
        "Total number of HTTP requests",
        &["method", "path", "status"]
    )
    .expect("failed to register http_requests_total");

    static ref HTTP_REQUEST_DURATION_SECONDS: HistogramVec = register_histogram_vec!(
        "http_request_duration_seconds",
        "HTTP request duration in seconds",
        &["method", "path"]
    )
    .expect("failed to register http_request_duration_seconds");
}

/// Prometheus メトリクスを収集する axum ミドルウェア。
pub async fn metrics_middleware<B>(req: Request<B>, next: Next<B>) -> Response {
    let method = req.method().to_string();
    let path = req
        .extensions()
        .get::<MatchedPath>()
        .map(|p| p.as_str().to_string())
        .unwrap_or_else(|| "unknown".to_string());

    let start = Instant::now();
    let response = next.run(req).await;
    let duration = start.elapsed().as_secs_f64();

    let status = response.status().as_u16().to_string();
    HTTP_REQUESTS_TOTAL
        .with_label_values(&[&method, &path, &status])
        .inc();
    HTTP_REQUEST_DURATION_SECONDS
        .with_label_values(&[&method, &path])
        .observe(duration);

    response
}

/// /metrics エンドポイントのハンドラー。Prometheus テキスト形式でメトリクスを返す。
pub async fn metrics_handler() -> impl IntoResponse {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = Vec::new();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    (
        [(axum::http::header::CONTENT_TYPE, "text/plain; charset=utf-8")],
        buffer,
    )
}
```

#### src/infra/observability/mod.rs

`src/infra/observability/mod.rs.tera` — 可観測性モジュール宣言。

```rust
pub mod tracer;
pub mod metrics;
```

---

## 認証認可 Middleware テンプレート

[認証認可設計.md](認証認可設計.md) D-004（Kong API Gateway 認証フロー）および D-005（アプリケーションレベル RBAC）に基づき、Kong から転送されるヘッダーを使用した認証認可ミドルウェアのスケルトンコードを生成する。

### 認証フロー概要

```
Client → Kong (JWT検証) → Backend Service (auth middleware → rbac middleware → handler)
```

Kong が JWT を検証し、`X-User-Id` / `X-User-Roles` / `X-User-Email` ヘッダーをバックエンドに転送する。バックエンドの auth middleware はこれらのヘッダーからユーザー情報を取得し、rbac middleware がパーミッション検証を行う。

#### src/adapter/middleware/auth.rs

`src/adapter/middleware/auth.rs.tera` — JWT Claims 検証（Kong 転送ヘッダーからユーザー情報取得）。

```rust
use axum::{
    extract::Request,
    http::StatusCode,
    middleware::Next,
    response::{IntoResponse, Json, Response},
};
use serde::Serialize;

/// Kong から転送された JWT Claims のユーザー情報。
#[derive(Debug, Clone)]
pub struct UserInfo {
    pub user_id: String,
    pub roles: Vec<String>,
    pub email: String,
}

#[derive(Serialize)]
struct ErrorResponse {
    code: String,
    message: String,
}

/// Kong から転送されたヘッダーを検証し、UserInfo をリクエスト拡張に格納する。
pub async fn auth_middleware(mut req: Request, next: Next) -> Result<Response, Response> {
    let user_id = req
        .headers()
        .get("X-User-Id")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string());

    let user_id = match user_id {
        Some(id) if !id.is_empty() => id,
        _ => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    code: "SYS_AUTH_UNAUTHENTICATED".to_string(),
                    message: "認証が必要です".to_string(),
                }),
            )
                .into_response());
        }
    };

    let roles: Vec<String> = req
        .headers()
        .get("X-User-Roles")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("")
        .split(',')
        .filter(|s| !s.is_empty())
        .map(|s| s.to_string())
        .collect();

    let email = req
        .headers()
        .get("X-User-Email")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("")
        .to_string();

    let user_info = UserInfo {
        user_id,
        roles,
        email,
    };

    req.extensions_mut().insert(user_info);
    Ok(next.run(req).await)
}
```

#### src/adapter/middleware/rbac.rs

`src/adapter/middleware/rbac.rs.tera` — RBAC パーミッション検証。

```rust
use axum::{
    extract::Request,
    http::StatusCode,
    middleware::Next,
    response::{IntoResponse, Json, Response},
};
use serde::Serialize;

use super::auth::UserInfo;

#[derive(Serialize)]
struct ErrorResponse {
    code: String,
    message: String,
}

/// 指定されたパーミッションを要求する axum ミドルウェア。
/// ロール → パーミッション変換は JWT Claims ベースの静的解決で行う。
pub async fn require_permission(
    permission: &str,
    resource: &str,
    req: Request,
    next: Next,
) -> Result<Response, Response> {
    let user_info = req
        .extensions()
        .get::<UserInfo>()
        .cloned();

    let user_info = match user_info {
        Some(info) => info,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse {
                    code: "SYS_AUTH_UNAUTHENTICATED".to_string(),
                    message: "認証が必要です".to_string(),
                }),
            )
                .into_response());
        }
    };

    if !has_permission(&user_info.roles, permission, resource) {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse {
                code: "SYS_AUTH_FORBIDDEN".to_string(),
                message: "この操作を実行する権限がありません".to_string(),
            }),
        )
            .into_response());
    }

    Ok(next.run(req).await)
}

/// ロール一覧から指定されたパーミッションを持つかチェックする。
/// パーミッション解決はインメモリのロール → パーミッション変換テーブルで行う（DB ルックアップ不要）。
fn has_permission(roles: &[String], _permission: &str, _resource: &str) -> bool {
    // TODO: Keycloak Admin API から取得したロール → パーミッション変換テーブルで解決する
    // 現在はプレースホルダー実装（全ロールに全パーミッションを許可）
    !roles.is_empty()
}
```

#### src/adapter/middleware/mod.rs

`src/adapter/middleware/mod.rs.tera` — ミドルウェアモジュール宣言。

```rust
pub mod auth;
pub mod rbac;
```

---

## gRPC Health Check テンプレート

`api_styles is containing("grpc")` の場合のみ生成される gRPC Health Checking Protocol 実装。[gRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md) に準拠し、Kubernetes の gRPC ネイティブプローブに対応する。

> **Helm Chart との連携**: gRPC Health Check プローブの設定値（`probes.grpcHealthCheck.enabled` / `probes.grpcHealthCheck.port`）は [テンプレート仕様-Helm](テンプレート仕様-Helm.md) の values.yaml で定義済みである。`grpcHealthCheck.enabled: true` に設定することで、Kubernetes の liveness/readiness プローブが gRPC ネイティブプローブに切り替わる。

#### src/adapter/handler/grpc_health.rs

`src/adapter/handler/grpc_health.rs.tera` — tonic-health crate を使用した gRPC Health Checking Protocol 実装。条件: `{% if api_styles is containing("grpc") %}`。

```rust
{% if api_styles is containing("grpc") %}
use tonic_health::server::health_reporter;

/// gRPC Health Checking Protocol のサービスを初期化する。
/// tonic-health を使用して grpc.health.v1.Health サービスを提供し、
/// Kubernetes の gRPC ネイティブプローブに対応する。
pub async fn create_health_service() -> (
    tonic_health::server::HealthReporter,
    tonic_health::server::HealthServer,
) {
    let (mut reporter, service) = health_reporter();

    // サービス名を指定してヘルスステータスを設定
    reporter
        .set_serving::<tonic::transport::Server>()
        .await;

    (reporter, service)
}
{% endif %}
```

---

## GraphQL Subscription テンプレート

`api_styles is containing("graphql")` の場合のみ生成される GraphQL Subscription サポート。WebSocket transport を使用してリアルタイム通信を実現する。

> **BFF との関連**: BFF テンプレート（[テンプレート仕様-BFF](テンプレート仕様-BFF.md)）はデフォルトで Query / Mutation のみを提供する。サーバーテンプレートの GraphQL Subscription は、サーバー側でリアルタイムイベントを配信する際に使用する。BFF が Subscription を中継する場合は、BFF の schema.graphql に Subscription 型を追加し、upstream サーバーの WebSocket エンドポイントに接続する拡張が必要となる。

#### schema 定義への SubscriptionRoot 追加

`src/adapter/handler/graphql.rs.tera` — async-graphql の SubscriptionRoot を追加する。条件: `{% if api_styles is containing("graphql") %}`。

```rust
{% if api_styles is containing("graphql") %}
use async_graphql::{Context, Object, Schema, Subscription};
use futures_core::stream::Stream;
use std::sync::Arc;

use crate::domain::model::{{ service_name_pascal }}Entity;
use crate::usecase::{{ service_name_pascal }}UseCase;

pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn {{ service_name_snake }}(
        &self,
        ctx: &Context<'_>,
        id: String,
    ) -> async_graphql::Result<Option<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_by_id(&id).await?)
    }

    async fn {{ service_name_snake }}_list(
        &self,
        ctx: &Context<'_>,
    ) -> async_graphql::Result<Vec<{{ service_name_pascal }}Entity>> {
        let uc = ctx.data::<Arc<{{ service_name_pascal }}UseCase>>()?;
        Ok(uc.get_all().await?)
    }
}

pub struct MutationRoot;

#[Object]
impl MutationRoot {
    // TODO: Mutation リゾルバーを実装する
    async fn placeholder(&self) -> bool {
        true
    }
}

pub struct SubscriptionRoot;

#[Subscription]
impl SubscriptionRoot {
    /// エンティティ変更通知
    async fn {{ service_name_snake }}_changed(
        &self,
    ) -> impl Stream<Item = {{ service_name_pascal }}Entity> {
        // TODO: 実際のイベントストリーム（Kafka consumer 等）に接続する
        futures_util::stream::empty()
    }
}

pub type {{ service_name_pascal }}Schema = Schema<QueryRoot, MutationRoot, SubscriptionRoot>;

pub fn build_schema(uc: {{ service_name_pascal }}UseCase) -> {{ service_name_pascal }}Schema {
    Schema::build(QueryRoot, MutationRoot, SubscriptionRoot)
        .data(Arc::new(uc))
        .finish()
}
{% endif %}
```

#### main.rs への WebSocket route 追加

`src/main.rs.tera` — axum の WebSocket サポートを追加する。`axum::extract::ws` を使用する。

```rust
{% if api_styles is containing("graphql") %}
use async_graphql_axum::{GraphQLRequest, GraphQLResponse, GraphQLSubscription};

// GraphQL エンドポイント
let app = Router::new()
    .route("/query", post(graphql_handler))
    .route("/ws", get(GraphQLSubscription::new(schema.clone())));

async fn graphql_handler(
    schema: Extension<{{ service_name_pascal }}Schema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}
{% endif %}
```

---

## 関連ドキュメント

- [テンプレートエンジン仕様](テンプレートエンジン仕様.md) — 変数置換・条件分岐の仕様
- [テンプレート仕様-クライアント](テンプレート仕様-クライアント.md) — クライアントテンプレート
- [テンプレート仕様-ライブラリ](テンプレート仕様-ライブラリ.md) — ライブラリテンプレート
- [テンプレート仕様-データベース](テンプレート仕様-データベース.md) — データベーステンプレート
- [CLIフロー](CLIフロー.md) — CLI の対話フローと操作手順
- [ディレクトリ構成図](ディレクトリ構成図.md) — 生成先ディレクトリ構成
- [API設計](API設計.md) — REST / gRPC / GraphQL 設計
- [config設計](config設計.md) — config.yaml スキーマと環境別管理
- [可観測性設計](可観測性設計.md) — 監視・トレーシング設計
- [認証認可設計](認証認可設計.md) — 認証・認可・シークレット管理
- [Dockerイメージ戦略](Dockerイメージ戦略.md) — Docker ビルド戦略
- [メッセージング設計](メッセージング設計.md) — Kafka トピック・イベント駆動設計
- [コーディング規約](コーディング規約.md) — Linter・Formatter・テストツール
- [テンプレート仕様-Helm](テンプレート仕様-Helm.md) — Helm Chart テンプレート（gRPC ヘルスチェック設定含む）
- [テンプレート仕様-BFF](テンプレート仕様-BFF.md) — BFF テンプレート
