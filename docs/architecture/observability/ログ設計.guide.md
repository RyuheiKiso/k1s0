# ログ設計 ガイド

> **仕様**: JSON フィールド定義・ログレベル・保持期間は [ログ設計.md](./ログ設計.md) を参照。

## 構造化ログの設計背景

JSON 構造化ログを標準とする理由:

- Loki のラベルベースクエリと組み合わせることで、フィールド単位のフィルタリングが容易
- `trace_id` / `span_id` の埋め込みにより、ログとトレースの相関分析が可能
- 機械的なパースが可能で、アラート条件やダッシュボードの PromQL/LogQL と直接連携

## トレース相関の仕組み

OpenTelemetry で伝搬される `trace_id` と `span_id` をログに埋め込み、ログとトレースを相関させる。

```
Client → Kong → Service A → Service B
  │                │              │
  └── trace_id: abc123 ──────────┘
       span_id: A001   span_id: B001
```

Grafana でログとトレースを統合表示し、trace_id をキーにドリルダウン可能にする。Loki データソースの `derivedFields` 設定により、ログ内の `trace_id` をクリックするだけで Jaeger のトレースビューに遷移できる。

## dev 環境のログフォーマット

dev 環境では開発者の可読性を優先し `text` フォーマットを許容する（[helm設計.md](../../infrastructure/kubernetes/helm設計.md) の values-dev.yaml 参照）。staging / prod では JSON 構造化ログを必須とする。

## Go 実装例（slog）

```go
// internal/infra/config/logger.go
package config

import (
    "log/slog"
    "os"

    "go.opentelemetry.io/otel/trace"
)

func NewLogger(env, service, version, tier string) *slog.Logger {
    level := slog.LevelWarn
    switch env {
    case "dev":
        level = slog.LevelDebug
    case "staging":
        level = slog.LevelInfo
    }

    handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: level,
    })

    return slog.New(handler).With(
        slog.String("service", service),
        slog.String("version", version),
        slog.String("tier", tier),
        slog.String("environment", env),
    )
}

// トレースコンテキストをログに埋め込むミドルウェア
func LogWithTrace(ctx context.Context, logger *slog.Logger) *slog.Logger {
    spanCtx := trace.SpanContextFromContext(ctx)
    if spanCtx.HasTraceID() {
        return logger.With(
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
        )
    }
    return logger
}
```

## Rust 実装例（tracing）

```rust
// src/infra/config/logger.rs
use tracing_subscriber::{fmt, EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};

pub fn init_logger(env: &str) {
    let filter = match env {
        "dev" => "debug",
        "staging" => "info",
        _ => "warn",
    };

    tracing_subscriber::registry()
        .with(EnvFilter::new(filter))
        .with(
            fmt::layer()
                .json()
                .with_target(true)
                .with_span_events(fmt::format::FmtSpan::CLOSE),
        )
        .init();
}

// リクエストハンドラーでのトレース付きログ
#[tracing::instrument(
    skip(state),
    fields(
        service = "order-server",
        tier = "service",
    )
)]
async fn create_order(
    State(state): State<AppState>,
    Json(input): Json<CreateOrderInput>,
) -> Result<Json<Order>, AppError> {
    tracing::info!(
        method = "POST",
        path = "/api/v1/orders",
        "Processing create order request"
    );
    // ...
}
```

## 監査ログ長期保存の設計背景

監査ログ（認証・認可関連）は通常ログとは別に長期保存する。1 年間の保持期間は、コンプライアンス要件とセキュリティ監査の観点から設定している。Loki のマルチテナント機能を利用し、`audit` テナントに対して個別の保持期間を設定することで、通常ログの保持コストに影響を与えずに長期保存を実現する。
