# 可観測性 - ログ設計

D-109: 構造化ログ設計。JSON 標準フィールド、Loki・Promtail 構成を定義する。

元ドキュメント: [可観測性設計.md](./可観測性設計.md)

---

## D-109: 構造化ログ設計

### JSON ログ標準フィールド

すべてのサービスは JSON 形式の構造化ログを標準出力に出力する。

```json
{
  "timestamp": "2026-02-15T10:30:00.123Z",
  "level": "info",
  "message": "Request completed",
  "service": "order-server",
  "version": "1.2.3",
  "tier": "service",
  "environment": "prod",
  "trace_id": "abc123def456",
  "span_id": "789ghi012",
  "request_id": "req_xyz789",
  "method": "POST",
  "path": "/api/v1/orders",
  "status": 201,
  "duration_ms": 45,
  "user_id": "usr_123",
  "error": null
}
```

### 標準フィールド定義

| フィールド    | 型     | 必須 | 説明                              |
| ------------- | ------ | ---- | --------------------------------- |
| `timestamp`   | string | Yes  | ISO 8601 形式（UTC）              |
| `level`       | string | Yes  | `debug`, `info`, `warn`, `error`  |
| `message`     | string | Yes  | ログメッセージ                    |
| `service`     | string | Yes  | サービス名                        |
| `version`     | string | Yes  | アプリケーションバージョン        |
| `tier`        | string | Yes  | `system`, `business`, `service`   |
| `environment` | string | Yes  | `dev`, `staging`, `prod`          |
| `trace_id`    | string | No   | 分散トレースの Trace ID           |
| `span_id`     | string | No   | 分散トレースの Span ID            |
| `request_id`  | string | No   | リクエスト追跡 ID                 |
| `error`       | object | No   | エラー詳細（スタックトレース等）  |

### リクエストコンテキストフィールド（ミドルウェア付与）

HTTP ミドルウェアがリクエスト処理時に自動的に付与するフィールド。

| フィールド    | 型     | 必須 | 説明                              |
| ------------- | ------ | ---- | --------------------------------- |
| `method`      | string | No   | HTTP メソッド（`GET`, `POST` 等） |
| `path`        | string | No   | リクエストパス                    |
| `status`      | number | No   | HTTP ステータスコード             |
| `duration_ms` | number | No   | リクエスト処理時間（ミリ秒）      |
| `user_id`     | string | No   | 認証済みユーザー ID               |

### 言語固有フィールド（オプショナル）

| フィールド | 型     | 必須 | 言語 | 説明                    |
| ---------- | ------ | ---- | ---- | ----------------------- |
| `logger`   | string | No   | Dart | ロガー名（loggerName）  |

### トレース相関

OpenTelemetry で伝搬される `trace_id` と `span_id` をログに埋め込み、ログとトレースを相関させる。

```
Client → Kong → Service A → Service B
  │                │              │
  └── trace_id: abc123 ──────────┘
       span_id: A001   span_id: B001
```

Grafana でログとトレースを統合表示し、trace_id をキーにドリルダウン可能にする。Loki データソースの `derivedFields` 設定により、ログ内の `trace_id` をクリックするだけで Jaeger のトレースビューに遷移できる。

### 環境別ログレベル

| 環境    | デフォルトレベル | フォーマット | 出力先   |
| ------- | ---------------- | ------------ | -------- |
| dev     | debug            | text         | stdout   |
| staging | info             | json         | stdout   |
| prod    | warn             | json         | stdout   |

dev 環境では開発者の可読性を優先し `text` フォーマットを許容する（[helm設計.md](../../infrastructure/kubernetes/helm設計.md) の values-dev.yaml 参照）。staging / prod では JSON 構造化ログを必須とする。

### ログ保持期間ポリシー

| 環境    | 保持期間 | 設定方法                            |
| ------- | -------- | ----------------------------------- |
| dev     | 7 日     | Loki `retention_period` で自動削除  |
| staging | 30 日    | Loki `retention_period` で自動削除  |
| prod    | 90 日    | Loki `retention_period` で自動削除  |

監査ログ（認証・認可関連）は通常ログとは別に長期保存する。

| ログ種別     | 保持期間 | 保存先                               |
| ------------ | -------- | ------------------------------------ |
| 監査ログ     | 1 年間   | Ceph オブジェクトストレージにアーカイブ |

```yaml
# Loki 保持期間設定例（prod）
limits_config:
  retention_period: 2160h  # 90日

# 監査ログ用の別テナント設定
overrides:
  audit:
    retention_period: 8760h  # 1年（365日）
```

### ログ集約（Loki）

```yaml
# Loki Stack (Promtail → Loki → Grafana)
apiVersion: v1
kind: ConfigMap
metadata:
  name: promtail-config
  namespace: observability
data:
  promtail.yaml: |
    server:
      http_listen_port: 3100
    positions:
      filename: /tmp/positions.yaml
    clients:
      - url: http://loki:3100/loki/api/v1/push
    scrape_configs:
      - job_name: kubernetes-pods
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels: [__meta_kubernetes_namespace]
            target_label: namespace
          - source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
            target_label: app
          - source_labels: [__meta_kubernetes_pod_label_tier]
            target_label: tier
        pipeline_stages:
          - json:
              expressions:
                level: level
                trace_id: trace_id
                service: service
          - labels:
              level:
              trace_id:
              service:
```

> **注記**: Promtail の `http_listen_port: 3100` は Loki のポート 3100 と同じだが、Kubernetes 環境では Promtail (DaemonSet) と Loki は異なる Pod にデプロイされるため問題ない。

---

## Go 実装例（slog）

```go
// regions/system/library/go/telemetry/logger.go
package telemetry

import (
    "context"
    "log/slog"
    "os"

    "go.opentelemetry.io/otel/trace"
)

func NewLogger(cfg TelemetryConfig) *slog.Logger {
    var level slog.Level
    switch cfg.LogLevel {
    case "debug":
        level = slog.LevelDebug
    case "info":
        level = slog.LevelInfo
    case "warn":
        level = slog.LevelWarn
    case "error":
        level = slog.LevelError
    default:
        level = slog.LevelWarn
    }

    opts := &slog.HandlerOptions{Level: level}
    var handler slog.Handler
    if cfg.LogFormat == "text" {
        handler = slog.NewTextHandler(os.Stdout, opts)
    } else {
        handler = slog.NewJSONHandler(os.Stdout, opts)
    }

    return slog.New(handler).With(
        slog.String("service", cfg.ServiceName),
        slog.String("version", cfg.Version),
        slog.String("tier", cfg.Tier),
        slog.String("environment", cfg.Environment),
    )
}

// トレースコンテキストをログに埋め込むミドルウェア
func LogWithTrace(ctx context.Context, logger *slog.Logger) *slog.Logger {
    spanCtx := trace.SpanContextFromContext(ctx)
    if spanCtx.HasTraceID() {
        return logger.With(
            slog.String("trace_id", spanCtx.TraceID().String()),
            slog.String("span_id", spanCtx.SpanID().String()),
        )
    }
    return logger
}
```

## Rust 実装例（tracing）

```rust
// regions/system/library/rust/telemetry/src/logger.rs
use tracing_subscriber::{fmt, EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};

pub fn init_logger(env: &str, format: &str) {
    let filter = match env {
        "dev" => "debug",
        "staging" => "info",
        _ => "warn",
    };

    let registry = tracing_subscriber::registry()
        .with(EnvFilter::new(filter));

    if format == "text" {
        registry
            .with(
                fmt::layer()
                    .with_target(true)
                    .with_span_events(fmt::format::FmtSpan::CLOSE),
            )
            .init();
    } else {
        registry
            .with(
                fmt::layer()
                    .json()
                    .with_target(true)
                    .with_span_events(fmt::format::FmtSpan::CLOSE),
            )
            .init();
    }
}

// リクエストハンドラーでのトレース付きログ
#[tracing::instrument(
    skip(state),
    fields(
        service = "order-server",
        tier = "service",
    )
)]
async fn create_order(
    State(state): State<AppState>,
    Json(input): Json<CreateOrderInput>,
) -> Result<Json<Order>, AppError> {
    tracing::info!(
        method = "POST",
        path = "/api/v1/orders",
        "Processing create order request"
    );
    // ...
}
```

> **注記**: 上記は `init_logger` 関数の内部実装例である。サーバーでは `init_telemetry(&TelemetryConfig{...})` を呼び出すことで、トレーシングとログの初期化が統合的に行われる（[可観測性設計.md](./可観測性設計.md) の「Rust」セクション参照）。

## 監査ログ長期保存の設計背景

監査ログ（認証・認可関連）は通常ログとは別に長期保存する。1 年間の保持期間は、コンプライアンス要件とセキュリティ監査の観点から設定している。Loki のマルチテナント機能を利用し、`audit` テナントに対して個別の保持期間を設定することで、通常ログの保持コストに影響を与えずに長期保存を実現する。

---

## 関連ドキュメント

- [可観測性設計.md](./可観測性設計.md) -- 基本方針・概要
- [可観測性-監視アラート設計.md](./監視アラート設計.md) -- 監視・アラート設計
- [可観測性-SLO設計.md](./SLO設計.md) -- SLO/SLA・エラーバジェット
- [可観測性-トレーシング設計.md](./トレーシング設計.md) -- 分散トレーシング
- [helm設計.md](../../infrastructure/kubernetes/helm設計.md) -- Helm Chart 設計
