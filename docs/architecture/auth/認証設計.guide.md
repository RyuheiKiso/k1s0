# 認証設計 ガイド

> **仕様**: テーブル定義・APIスキーマは [認証設計.md](./認証設計.md) を参照。

---

## Keycloak HA 構成の設計背景

環境ごとに異なる構成でデプロイする理由と各環境の詳細。

- **prod**: Keycloak 3 ノード構成。外部 PostgreSQL をセッションストアおよびデータベースとして共有し、Infinispan 分散キャッシュによりノード間でセッション・認証キャッシュを同期する
- **staging**: Keycloak 2 ノード構成。prod と同一アーキテクチャで縮小運用
- **dev**: Keycloak 1 ノード構成。開発・検証用途のためシングルノードで運用

## LDAP 同期方式の詳細

- **Changed Users Sync（差分同期）**: 60 秒間隔で LDAP の変更分のみを同期する。通常運用ではこの差分同期により、ユーザーの追加・変更・無効化が 1 分以内に反映される
- **Full Sync（完全同期）**: 毎日深夜に LDAP 全ユーザーの完全同期を実行する。差分同期で漏れた変更を補完し、データの整合性を保証する

## SPA トークン保存方式の選定理由（D-013）

SPA（React）ではトークンを **ブラウザの JavaScript から直接保持しない**。BFF（Backend for Frontend）がトークン管理を担い、ブラウザへは **HttpOnly Cookie** でセッションを維持する。

### 方式比較

| 方式                    | XSS 耐性 | CSRF 耐性    | 実装コスト | 採用  |
| ----------------------- | --------- | ------------ | ---------- | ----- |
| localStorage            | 脆弱      | 不要         | 低         | 不採用 |
| sessionStorage          | 脆弱      | 不要         | 低         | 不採用 |
| メモリ（変数）          | 安全      | 不要         | 中         | 不採用 |
| HttpOnly Cookie（BFF）  | 安全      | 対策必要     | 中         | **採用** |

- **localStorage / sessionStorage**: XSS 攻撃でトークンが窃取されるリスクがある
- **メモリ保持**: ページリロードでトークンが失われ、UX が悪化する
- **HttpOnly Cookie + BFF**: JavaScript からトークンにアクセスできず、XSS 耐性が最も高い

## BFF Proxy 言語選定理由

BFF Proxy は **Go** で実装する。BFF Proxy はトークン管理・セッション管理を担うリバースプロキシであり、[API設計.md](../api/API設計.md) で定義する **GraphQL BFF**（データ集約を担う BFF）とは異なるコンポーネントである。GraphQL BFF は `regions/service/{サービス名}/server/{go|rust}/bff/` に配置されるが、BFF Proxy は system 層の共通基盤として `regions/system/server/go/bff-proxy/` に配置する。

| 項目       | 内容                                                                 |
| ---------- | -------------------------------------------------------------------- |
| 言語       | Go                                                                   |
| 選定理由   | 標準ライブラリの `net/http` が充実しており、リバースプロキシの実装が容易 |
|            | ミドルウェアのエコシステムが豊富（CORS、セッション管理、ロギング等） |
|            | チームの Go スキルを活用できる                                       |

## BFF Redis セッションストアの設計背景

BFF のセッション管理には **専用の Redis インスタンス** を使用する。セッション管理はセキュリティ要件が高いため、他用途（キャッシュ等）の Redis とは共用しない。

- **スライディングウィンドウ**: ユーザーがアクティブな間はセッション TTL が延長される。30 分間操作がない場合にセッションが失効する
- **Redis Sentinel**: Master 障害時に自動フェイルオーバーを実行し、セッションの可用性を確保する
- **専用インスタンス**: セッションデータの分離により、他ワークロードの影響を受けずにセキュリティ・パフォーマンスを保証する

## クライアント実装例

### React（SPA）実装例

```typescript
// src/lib/api.ts
// BFF 経由のため、トークンを直接扱わない

const apiClient = axios.create({
  baseURL: '/api',           // BFF のプロキシエンドポイント
  withCredentials: true,      // Cookie を自動送信
});

// CSRF トークンをリクエストヘッダーに付与
apiClient.interceptors.request.use((config) => {
  const csrfToken = document.querySelector<HTMLMetaElement>(
    'meta[name="csrf-token"]'
  )?.content;
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});

// 401 レスポンス時はログインページにリダイレクト
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      window.location.href = '/auth/login';
    }
    return Promise.reject(error);
  }
);
```

### Flutter（Mobile）実装例

```dart
// lib/features/auth/data/auth_repository.dart

class AuthRepository {
  final FlutterAppAuth _appAuth = const FlutterAppAuth();

  Future<TokenResponse> login() async {
    final result = await _appAuth.authorizeAndExchangeCode(
      AuthorizationTokenRequest(
        'flutter-mobile',                             // client_id
        'com.example.k1s0://callback',                // redirect_url
        issuer: 'https://auth.k1s0.internal.example.com/realms/k1s0',
        scopes: ['openid', 'profile', 'email'],
      ),
    );
    // Access Token はセキュアストレージに保存
    await _secureStorage.write(key: 'access_token', value: result.accessToken);
    await _secureStorage.write(key: 'refresh_token', value: result.refreshToken);
    return result;
  }
}
```

### CLI（Rust）実装例

```rust
// CLI/src/commands/login.rs

pub async fn login() -> Result<()> {
    let client = reqwest::Client::new();

    // 1. Device Authorization Request
    let device_resp: DeviceAuthResponse = client
        .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/auth/device")
        .form(&[
            ("client_id", "k1s0-cli"),
            ("scope", "openid profile email"),
        ])
        .send()
        .await?
        .json()
        .await?;

    println!("ブラウザで {} にアクセスし、コード {} を入力してください",
        device_resp.verification_uri_complete,
        device_resp.user_code);

    // 2. Token Polling
    loop {
        tokio::time::sleep(Duration::from_secs(device_resp.interval as u64)).await;

        let token_resp = client
            .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/token")
            .form(&[
                ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
                ("client_id", "k1s0-cli"),
                ("device_code", &device_resp.device_code),
            ])
            .send()
            .await?;

        match token_resp.status() {
            StatusCode::OK => {
                let tokens: TokenResponse = token_resp.json().await?;
                save_tokens(&tokens)?;
                println!("ログインに成功しました");
                return Ok(());
            }
            _ => {
                let err: ErrorResponse = token_resp.json().await?;
                if err.error != "authorization_pending" {
                    return Err(anyhow!("認証エラー: {}", err.error_description));
                }
            }
        }
    }
}
```

---

## 関連ドキュメント

- [認証設計.md](./認証設計.md) -- 仕様（テーブル・スキーマ定義）
- [認証認可設計.md](認証認可設計.md) -- 基本方針・技術スタック
- [JWT設計.md](./JWT設計.md) -- JWT 公開鍵ローテーション
- [サービス間認証設計.md](サービス間認証設計.md) -- mTLS 設計
- [RBAC設計.md](./RBAC設計.md) -- RBAC 設計
- [Vault設計.md](../../infrastructure/security/Vault設計.md) -- シークレット管理
- [APIゲートウェイ設計.md](../api/APIゲートウェイ設計.md) -- Kong 認証フロー
- [config.md](../../cli/config/config設計.md) -- config.yaml スキーマ
