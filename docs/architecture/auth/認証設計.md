# 認証設計

> **ガイド**: 設計背景・選定理由は [認証設計.guide.md](./認証設計.guide.md) を参照。

D-001: OAuth 2.0 / OIDC 実装。Keycloak セルフホスト、LDAP 連携、クライアント別 OAuth 2.0 フロー、JWT Claims 構造を定義する。

元ドキュメント: [認証認可設計.md](認証認可設計.md)

---

## D-001: OAuth 2.0 / OIDC 実装

### Keycloak セルフホスト

認証基盤として Keycloak 26.0（LTS）をオンプレミス Kubernetes クラスタ上にデプロイする。

| 項目               | 値                                          |
| ------------------ | ------------------------------------------- |
| バージョン         | 26.0（LTS）                                |
| デプロイ先         | `k1s0-system` Namespace                     |
| Realm              | `k1s0`                                      |
| IdP プロトコル     | OpenID Connect (OIDC)                       |
| ユーザーストア     | LDAP / AD 連携                              |
| 管理コンソール     | `auth.k1s0.internal.example.com`            |
| OIDC Discovery     | `https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration` |

### Keycloak HA 構成

| 環境    | Keycloak ノード数 | セッションストア / DB          | キャッシュ             |
| ------- | ----------------- | ------------------------------ | ---------------------- |
| prod    | 3 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| staging | 2 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| dev     | 1 ノード          | 組み込み H2 または外部 PostgreSQL | ローカルキャッシュ     |

### LDAP / AD 連携

Keycloak の **User Federation** 機能を使用して LDAP プロバイダーを設定する。

#### 接続設定

| 項目           | 値                                      |
| -------------- | --------------------------------------- |
| プロトコル     | LDAPS（636 ポート）                     |
| 暗号化         | TLS 必須（平文 LDAP 接続は禁止）       |
| Bind DN        | `cn=keycloak,ou=service-accounts,dc=example,dc=com` |
| User DN        | `ou=users,dc=example,dc=com`           |

#### 属性マッピングルール

| LDAP 属性         | Keycloak 属性   | 説明                         |
| ----------------- | --------------- | ---------------------------- |
| `sAMAccountName`  | `username`      | ログイン ID                  |
| `mail`            | `email`         | メールアドレス               |
| `memberOf`        | グループ        | LDAP グループ → Keycloak グループにマッピング |

#### 同期方式

| 同期種別               | 方式                    | 間隔             |
| ---------------------- | ----------------------- | ---------------- |
| 差分同期               | Changed Users Sync      | 60 秒間隔        |
| 完全同期               | Full Sync               | 毎日深夜（0:00） |

### クライアント別 OAuth 2.0 フロー

| クライアント種別   | OAuth 2.0 フロー                     | 用途                   |
| ------------------ | ------------------------------------ | ---------------------- |
| SPA（React）       | Authorization Code + PKCE            | ブラウザベースの認証   |
| Mobile（Flutter）  | Authorization Code + PKCE            | モバイルアプリの認証   |
| CLI                | Device Authorization Grant           | CLI ツールからの認証   |
| Tauri GUI          | Device Authorization Grant           | デスクトップアプリの認証（[TauriGUI設計](../../cli/gui/TauriGUI設計.md) 参照） |
| サービス間         | Client Credentials                   | バックエンド間の認証   |

### Authorization Code + PKCE（SPA / Mobile）

```
1. Client → Keycloak: GET /authorize?response_type=code&code_challenge=...&code_challenge_method=S256
2. User → Keycloak: ログイン
3. Keycloak → Client: redirect with authorization_code
4. Client → Keycloak: POST /token (code + code_verifier)
5. Keycloak → Client: access_token + refresh_token + id_token
```

### Device Authorization Grant（CLI）

```
1. CLI → Keycloak: POST /device (client_id, scope)
2. Keycloak → CLI: device_code, user_code, verification_uri
3. CLI → User: 「ブラウザで https://auth.../device にアクセスし、コード XXXX-XXXX を入力してください」
4. User → Keycloak: ブラウザでコード入力・ログイン
5. CLI → Keycloak: POST /token (device_code) をポーリング
6. Keycloak → CLI: access_token + refresh_token
```

### Client Credentials（サービス間）

```
1. Service → Keycloak: POST /token (client_id, client_secret, grant_type=client_credentials)
2. Keycloak → Service: access_token
```

サービス間通信では mTLS に加え、必要に応じて Client Credentials で取得したトークンを使用する。

### トークンライフタイム

| トークン種別   | 有効期限 | 説明                                   |
| -------------- | -------- | -------------------------------------- |
| Access Token   | 15 分    | 短命にしてリスクを最小化               |
| Refresh Token  | 7 日     | Access Token の更新に使用              |
| ID Token       | 15 分    | ユーザー情報の取得に使用（Access と同期） |

### JWT Claims 構造

Access Token の JWT ペイロードは以下の Claims を含む。

> **注**: `aud`（audience）のデフォルト値は `k1s0-api`（全体共通）である。以下の例はサービス固有のトークン例であり、`aud` にはトークンの発行対象サービス名（例: `order-service`）が設定される。API Gateway 経由の共通アクセスでは `k1s0-api` が使用され、特定サービス向けに発行されたトークンではサービス名が個別に設定される。

```json
{
  "iss": "https://auth.k1s0.internal.example.com/realms/k1s0",
  "sub": "user-uuid-1234",
  "aud": "order-service",  // サービス固有トークンの例。デフォルト（全体共通）は "k1s0-api"
  "exp": 1710000900,
  "iat": 1710000000,
  "jti": "token-uuid-5678",
  "typ": "Bearer",
  "azp": "react-spa",
  "scope": "openid profile email",
  "realm_access": {
    "roles": ["user", "order_manager"]
  },
  "resource_access": {
    "order-service": {
      "roles": ["read", "write"]
    }
  },
  "preferred_username": "taro.yamada",
  "email": "taro.yamada@example.com",
  "tier_access": ["system", "business", "service"]
}
```

| Claim              | 説明                                          |
| ------------------ | --------------------------------------------- |
| `sub`              | ユーザーの一意識別子（UUID）                  |
| `realm_access`     | グローバルロール                              |
| `resource_access`  | サービス固有のロール                          |
| `tier_access`      | アクセス可能な Tier の一覧                    |

### config.yaml の auth セクション拡張

既存の [config.md](../../cli/config/config設計.md) の `auth` セクションに OIDC 設定を追加する。

```yaml
# config/config.yaml（auth セクション）
# 詳細なスキーマは config.md を参照
auth:
  jwt:
    issuer: "https://auth.k1s0.internal.example.com/realms/k1s0"
    audience: "k1s0-api"           # デフォルト値。サービス固有の audience が必要な場合は環境別 config で上書き
    public_key_path: ""                    # 非推奨: JWKS（oidc.jwks_uri）による動的取得を優先。オフライン検証が必要な場合のみ PEM ファイルパスを指定（例: "/etc/secrets/jwt-public.pem"）
  oidc:
    discovery_url: "https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration"
    client_id: "k1s0-bff"          # BFF 用のデフォルト値。サービスごとに異なる client_id を使用する場合は環境別 config で上書き
    client_secret: ""              # Vault パス: secret/data/k1s0/system/bff/oidc キー: client_secret
    redirect_uri: "https://app.k1s0.internal.example.com/callback"
    scopes: ["openid", "profile", "email"]
    jwks_uri: "https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs"
    jwks_cache_ttl: "10m"
```

### クライアントのトークン管理

### SPA トークン保存方式（D-013）

BFF プロキシ + HttpOnly Cookie 方式を採用。

```
Browser → [HttpOnly Cookie] → Nginx Ingress Controller → Kong → BFF Proxy → [Bearer Token] → Istio Sidecar → Backend
```

#### CSRF 対策

| 対策                    | 実装方法                                           |
| ----------------------- | -------------------------------------------------- |
| SameSite 属性           | `SameSite=Strict`（同一サイトからのリクエストのみ） |
| CSRF トークン           | BFF が発行し、リクエストヘッダー `X-CSRF-Token` で送信 |
| Origin チェック          | BFF が `Origin` / `Referer` ヘッダーを検証         |

#### Cookie 設定

```
Set-Cookie: session={encrypted_session_id};
  HttpOnly;
  Secure;
  SameSite=Strict;
  Path=/;
  Max-Age=604800;
  Domain=.k1s0.internal.example.com
```

| 属性         | 値                               | 理由                               |
| ------------ | -------------------------------- | ---------------------------------- |
| `HttpOnly`   | true                             | JavaScript からのアクセスを遮断    |
| `Secure`     | true                             | HTTPS 通信のみで送信               |
| `SameSite`   | `Strict`                         | クロスサイトリクエストを遮断       |
| `Max-Age`    | 604800（7日）                    | Refresh Token のライフタイムと同期 |
| `Domain`     | `.k1s0.internal.example.com`    | サブドメイン間で共有               |

#### BFF Proxy 構成

| 項目       | 内容                                                                 |
| ---------- | -------------------------------------------------------------------- |
| 言語       | Go                                                                   |
| 配置       | `regions/system/server/go/bff-proxy/`                                |
| 役割       | トークン管理・セッション管理を担うリバースプロキシ                   |

BFF Proxy は [API設計.md](../api/API設計.md) の **GraphQL BFF**（データ集約）とは異なるコンポーネントである。

#### BFF Redis セッションストア

| 項目                 | 値                                          |
| -------------------- | ------------------------------------------- |
| 構成                 | Redis Sentinel                              |
| prod 構成            | Master 1 + Replica 2 + Sentinel 3           |
| セッション TTL       | 30 分（スライディングウィンドウ）           |
| TLS                  | 有効（暗号化通信必須）                      |
| AUTH                 | パスワード必須（Vault パス: `secret/data/k1s0/system/bff/redis` キー: `password`） |

#### BFF のトークン管理フロー

```
1. Browser → BFF: GET /auth/login（PKCE フロー開始）
2. BFF → Keycloak: Authorization Code + PKCE
3. Keycloak → BFF: access_token + refresh_token
4. BFF: トークンをサーバーサイドセッション（Redis）に保存
5. BFF → Browser: Set-Cookie: session={session_id}（HttpOnly）
6. Browser → BFF: API リクエスト（Cookie 自動送信）
7. BFF: セッションから access_token を取得し、Authorization ヘッダーに付与
8. BFF → Kong → Backend: Bearer {access_token}
```

#### トークンリフレッシュ

- Access Token の有効期限の **2 分前** にバックグラウンドリフレッシュを実行
- リフレッシュ成功時、新しい Access Token と Refresh Token をセッションに上書き保存
- Refresh Token は **ワンタイム使用**（使用済みトークンでのリフレッシュ試行は全セッション無効化）

---

## 関連ドキュメント

- [認証設計.guide.md](./認証設計.guide.md) -- 設計背景・選定理由
- [認証認可設計.md](認証認可設計.md) -- 基本方針・技術スタック
- [JWT設計.md](./JWT設計.md) -- JWT 公開鍵ローテーション
- [サービス間認証設計.md](サービス間認証設計.md) -- mTLS 設計
- [RBAC設計.md](./RBAC設計.md) -- RBAC 設計
- [Vault設計.md](../../infrastructure/security/Vault設計.md) -- シークレット管理
- [APIゲートウェイ設計.md](../api/APIゲートウェイ設計.md) -- Kong 認証フロー
- [config.md](../../cli/config/config設計.md) -- config.yaml スキーマ
