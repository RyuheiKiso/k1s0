# 認証設計

D-001: OAuth 2.0 / OIDC 実装。Keycloak セルフホスト、LDAP 連携、クライアント別 OAuth 2.0 フロー、JWT Claims 構造を定義する。

元ドキュメント: [認証認可設計.md](認証認可設計.md)

---

## D-001: OAuth 2.0 / OIDC 実装

### Keycloak セルフホスト

認証基盤として Keycloak 26.0（LTS）をオンプレミス Kubernetes クラスタ上にデプロイする。

| 項目               | 値                                          |
| ------------------ | ------------------------------------------- |
| バージョン         | 26.0（LTS）                                |
| デプロイ先         | `k1s0-system` Namespace                     |
| Realm              | `k1s0`                                      |
| IdP プロトコル     | OpenID Connect (OIDC)                       |
| ユーザーストア     | LDAP / AD 連携                              |
| 管理コンソール     | `auth.k1s0.internal.example.com`            |
| OIDC Discovery     | `https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration` |

### Keycloak HA 構成

環境ごとに異なる構成でデプロイする。

| 環境    | Keycloak ノード数 | セッションストア / DB          | キャッシュ             |
| ------- | ----------------- | ------------------------------ | ---------------------- |
| prod    | 3 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| staging | 2 ノード          | 外部 PostgreSQL（DB 共有）     | Infinispan 分散キャッシュ |
| dev     | 1 ノード          | 組み込み H2 または外部 PostgreSQL | ローカルキャッシュ     |

- **prod**: Keycloak 3 ノード構成。外部 PostgreSQL をセッションストアおよびデータベースとして共有し、Infinispan 分散キャッシュによりノード間でセッション・認証キャッシュを同期する
- **staging**: Keycloak 2 ノード構成。prod と同一アーキテクチャで縮小運用
- **dev**: Keycloak 1 ノード構成。開発・検証用途のためシングルノードで運用

### LDAP / AD 連携

Keycloak の **User Federation** 機能を使用して LDAP プロバイダーを設定する。

#### 接続設定

| 項目           | 値                                      |
| -------------- | --------------------------------------- |
| プロトコル     | LDAPS（636 ポート）                     |
| 暗号化         | TLS 必須（平文 LDAP 接続は禁止）       |
| Bind DN        | `cn=keycloak,ou=service-accounts,dc=example,dc=com` |
| User DN        | `ou=users,dc=example,dc=com`           |

#### 属性マッピングルール

| LDAP 属性         | Keycloak 属性   | 説明                         |
| ----------------- | --------------- | ---------------------------- |
| `sAMAccountName`  | `username`      | ログイン ID                  |
| `mail`            | `email`         | メールアドレス               |
| `memberOf`        | グループ        | LDAP グループ → Keycloak グループにマッピング |

#### 同期方式

| 同期種別               | 方式                    | 間隔             |
| ---------------------- | ----------------------- | ---------------- |
| 差分同期               | Changed Users Sync      | 60 秒間隔        |
| 完全同期               | Full Sync               | 毎日深夜（0:00） |

- **Changed Users Sync（差分同期）**: 60 秒間隔で LDAP の変更分のみを同期する。通常運用ではこの差分同期により、ユーザーの追加・変更・無効化が 1 分以内に反映される
- **Full Sync（完全同期）**: 毎日深夜に LDAP 全ユーザーの完全同期を実行する。差分同期で漏れた変更を補完し、データの整合性を保証する

### クライアント別 OAuth 2.0 フロー

| クライアント種別   | OAuth 2.0 フロー                     | 用途                   |
| ------------------ | ------------------------------------ | ---------------------- |
| SPA（React）       | Authorization Code + PKCE            | ブラウザベースの認証   |
| Mobile（Flutter）  | Authorization Code + PKCE            | モバイルアプリの認証   |
| CLI                | Device Authorization Grant           | CLI ツールからの認証   |
| Tauri GUI          | Device Authorization Grant           | デスクトップアプリの認証（[TauriGUI設計](TauriGUI設計.md) 参照） |
| サービス間         | Client Credentials                   | バックエンド間の認証   |

### Authorization Code + PKCE（SPA / Mobile）

```
1. Client → Keycloak: GET /authorize?response_type=code&code_challenge=...&code_challenge_method=S256
2. User → Keycloak: ログイン
3. Keycloak → Client: redirect with authorization_code
4. Client → Keycloak: POST /token (code + code_verifier)
5. Keycloak → Client: access_token + refresh_token + id_token
```

### Device Authorization Grant（CLI）

```
1. CLI → Keycloak: POST /device (client_id, scope)
2. Keycloak → CLI: device_code, user_code, verification_uri
3. CLI → User: 「ブラウザで https://auth.../device にアクセスし、コード XXXX-XXXX を入力してください」
4. User → Keycloak: ブラウザでコード入力・ログイン
5. CLI → Keycloak: POST /token (device_code) をポーリング
6. Keycloak → CLI: access_token + refresh_token
```

### Client Credentials（サービス間）

```
1. Service → Keycloak: POST /token (client_id, client_secret, grant_type=client_credentials)
2. Keycloak → Service: access_token
```

サービス間通信では mTLS に加え、必要に応じて Client Credentials で取得したトークンを使用する。

### トークンライフタイム

| トークン種別   | 有効期限 | 説明                                   |
| -------------- | -------- | -------------------------------------- |
| Access Token   | 15 分    | 短命にしてリスクを最小化               |
| Refresh Token  | 7 日     | Access Token の更新に使用              |
| ID Token       | 15 分    | ユーザー情報の取得に使用（Access と同期） |

### JWT Claims 構造

Access Token の JWT ペイロードは以下の Claims を含む。

> **注**: `aud`（audience）のデフォルト値は `k1s0-api`（全体共通）である。以下の例はサービス固有のトークン例であり、`aud` にはトークンの発行対象サービス名（例: `order-service`）が設定される。API Gateway 経由の共通アクセスでは `k1s0-api` が使用され、特定サービス向けに発行されたトークンではサービス名が個別に設定される。

```json
{
  "iss": "https://auth.k1s0.internal.example.com/realms/k1s0",
  "sub": "user-uuid-1234",
  "aud": "order-service",  // サービス固有トークンの例。デフォルト（全体共通）は "k1s0-api"
  "exp": 1710000900,
  "iat": 1710000000,
  "jti": "token-uuid-5678",
  "typ": "Bearer",
  "azp": "react-spa",
  "scope": "openid profile email",
  "realm_access": {
    "roles": ["user", "order_manager"]
  },
  "resource_access": {
    "order-service": {
      "roles": ["read", "write"]
    }
  },
  "preferred_username": "taro.yamada",
  "email": "taro.yamada@example.com",
  "tier_access": ["system", "business", "service"]
}
```

| Claim              | 説明                                          |
| ------------------ | --------------------------------------------- |
| `sub`              | ユーザーの一意識別子（UUID）                  |
| `realm_access`     | グローバルロール                              |
| `resource_access`  | サービス固有のロール                          |
| `tier_access`      | アクセス可能な Tier の一覧                    |

### config.yaml の auth セクション拡張

既存の [config設計.md](config設計.md) の `auth` セクションに OIDC 設定を追加する。

```yaml
# config/config.yaml（auth セクション）
# 詳細なスキーマは config設計.md を参照
auth:
  jwt:
    issuer: "https://auth.k1s0.internal.example.com/realms/k1s0"
    audience: "k1s0-api"           # デフォルト値。サービス固有の audience が必要な場合は環境別 config で上書き
    public_key_path: ""                    # 非推奨: JWKS（oidc.jwks_uri）による動的取得を優先。オフライン検証が必要な場合のみ PEM ファイルパスを指定（例: "/etc/secrets/jwt-public.pem"）
  oidc:
    discovery_url: "https://auth.k1s0.internal.example.com/realms/k1s0/.well-known/openid-configuration"
    client_id: "k1s0-bff"          # BFF 用のデフォルト値。サービスごとに異なる client_id を使用する場合は環境別 config で上書き
    client_secret: ""              # Vault パス: secret/data/k1s0/system/bff/oidc キー: client_secret
    redirect_uri: "https://app.k1s0.internal.example.com/callback"
    scopes: ["openid", "profile", "email"]
    jwks_uri: "https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/certs"
    jwks_cache_ttl: "10m"
```

### クライアントのトークン管理

### SPA トークン保存方式（D-013）

#### 決定: BFF プロキシ + HttpOnly Cookie 方式

SPA（React）ではトークンを **ブラウザの JavaScript から直接保持しない**。BFF（Backend for Frontend）がトークン管理を担い、ブラウザへは **HttpOnly Cookie** でセッションを維持する。

```
Browser → [HttpOnly Cookie] → Nginx Ingress Controller → Kong → BFF Proxy → [Bearer Token] → Istio Sidecar → Backend
```

#### 選定理由

| 方式                    | XSS 耐性 | CSRF 耐性    | 実装コスト | 採用  |
| ----------------------- | --------- | ------------ | ---------- | ----- |
| localStorage            | 脆弱      | 不要         | 低         | 不採用 |
| sessionStorage          | 脆弱      | 不要         | 低         | 不採用 |
| メモリ（変数）          | 安全      | 不要         | 中         | 不採用 |
| HttpOnly Cookie（BFF）  | 安全      | 対策必要     | 中         | **採用** |

- **localStorage / sessionStorage**: XSS 攻撃でトークンが窃取されるリスクがある
- **メモリ保持**: ページリロードでトークンが失われ、UX が悪化する
- **HttpOnly Cookie + BFF**: JavaScript からトークンにアクセスできず、XSS 耐性が最も高い

#### CSRF 対策

HttpOnly Cookie 方式では CSRF 対策が必須となる。以下の多層防御を適用する。

| 対策                    | 実装方法                                           |
| ----------------------- | -------------------------------------------------- |
| SameSite 属性           | `SameSite=Strict`（同一サイトからのリクエストのみ） |
| CSRF トークン           | BFF が発行し、リクエストヘッダー `X-CSRF-Token` で送信 |
| Origin チェック          | BFF が `Origin` / `Referer` ヘッダーを検証         |

#### Cookie 設定

```
Set-Cookie: session={encrypted_session_id};
  HttpOnly;
  Secure;
  SameSite=Strict;
  Path=/;
  Max-Age=604800;
  Domain=.k1s0.internal.example.com
```

| 属性         | 値                               | 理由                               |
| ------------ | -------------------------------- | ---------------------------------- |
| `HttpOnly`   | true                             | JavaScript からのアクセスを遮断    |
| `Secure`     | true                             | HTTPS 通信のみで送信               |
| `SameSite`   | `Strict`                         | クロスサイトリクエストを遮断       |
| `Max-Age`    | 604800（7日）                    | Refresh Token のライフタイムと同期 |
| `Domain`     | `.k1s0.internal.example.com`    | サブドメイン間で共有               |

#### BFF Proxy 実装

BFF Proxy は **Go** で実装する。BFF Proxy はトークン管理・セッション管理を担うリバースプロキシであり、[API設計.md](API設計.md) で定義する **GraphQL BFF**（データ集約を担う BFF）とは異なるコンポーネントである。GraphQL BFF は `regions/service/{サービス名}/server/{go|rust}/bff/` に配置されるが、BFF Proxy は system 層の共通基盤として `regions/system/server/go/bff-proxy/` に配置する。

| 項目       | 内容                                                                 |
| ---------- | -------------------------------------------------------------------- |
| 言語       | Go                                                                   |
| 選定理由   | 標準ライブラリの `net/http` が充実しており、リバースプロキシの実装が容易 |
|            | ミドルウェアのエコシステムが豊富（CORS、セッション管理、ロギング等） |
|            | チームの Go スキルを活用できる                                       |

#### BFF Redis セッションストア

BFF のセッション管理には **専用の Redis インスタンス** を使用する。セッション管理はセキュリティ要件が高いため、他用途（キャッシュ等）の Redis とは共用しない。

| 項目                 | 値                                          |
| -------------------- | ------------------------------------------- |
| 構成                 | Redis Sentinel                              |
| prod 構成            | Master 1 + Replica 2 + Sentinel 3           |
| セッション TTL       | 30 分（スライディングウィンドウ）           |
| TLS                  | 有効（暗号化通信必須）                      |
| AUTH                 | パスワード必須（Vault パス: `secret/data/k1s0/system/bff/redis` キー: `password`） |

- **スライディングウィンドウ**: ユーザーがアクティブな間はセッション TTL が延長される。30 分間操作がない場合にセッションが失効する
- **Redis Sentinel**: Master 障害時に自動フェイルオーバーを実行し、セッションの可用性を確保する
- **専用インスタンス**: セッションデータの分離により、他ワークロードの影響を受けずにセキュリティ・パフォーマンスを保証する

#### BFF のトークン管理フロー

```
1. Browser → BFF: GET /auth/login（PKCE フロー開始）
2. BFF → Keycloak: Authorization Code + PKCE
3. Keycloak → BFF: access_token + refresh_token
4. BFF: トークンをサーバーサイドセッション（Redis）に保存
5. BFF → Browser: Set-Cookie: session={session_id}（HttpOnly）
6. Browser → BFF: API リクエスト（Cookie 自動送信）
7. BFF: セッションから access_token を取得し、Authorization ヘッダーに付与
8. BFF → Kong → Backend: Bearer {access_token}
```

#### トークンリフレッシュ

BFF がサーバーサイドでリフレッシュを管理する。

- Access Token の有効期限の **2 分前** にバックグラウンドリフレッシュを実行
- リフレッシュ成功時、新しい Access Token と Refresh Token をセッションに上書き保存
- Refresh Token は **ワンタイム使用**（使用済みトークンでのリフレッシュ試行は全セッション無効化）

#### React（SPA）実装例

```typescript
// src/lib/api.ts
// BFF 経由のため、トークンを直接扱わない

const apiClient = axios.create({
  baseURL: '/api',           // BFF のプロキシエンドポイント
  withCredentials: true,      // Cookie を自動送信
});

// CSRF トークンをリクエストヘッダーに付与
apiClient.interceptors.request.use((config) => {
  const csrfToken = document.querySelector<HTMLMetaElement>(
    'meta[name="csrf-token"]'
  )?.content;
  if (csrfToken) {
    config.headers['X-CSRF-Token'] = csrfToken;
  }
  return config;
});

// 401 レスポンス時はログインページにリダイレクト
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      window.location.href = '/auth/login';
    }
    return Promise.reject(error);
  }
);
```

#### Flutter（Mobile）

```dart
// lib/features/auth/data/auth_repository.dart

class AuthRepository {
  final FlutterAppAuth _appAuth = const FlutterAppAuth();

  Future<TokenResponse> login() async {
    final result = await _appAuth.authorizeAndExchangeCode(
      AuthorizationTokenRequest(
        'flutter-mobile',                             // client_id
        'com.example.k1s0://callback',                // redirect_url
        issuer: 'https://auth.k1s0.internal.example.com/realms/k1s0',
        scopes: ['openid', 'profile', 'email'],
      ),
    );
    // Access Token はセキュアストレージに保存
    await _secureStorage.write(key: 'access_token', value: result.accessToken);
    await _secureStorage.write(key: 'refresh_token', value: result.refreshToken);
    return result;
  }
}
```

#### CLI

```rust
// CLI/src/commands/login.rs

pub async fn login() -> Result<()> {
    let client = reqwest::Client::new();

    // 1. Device Authorization Request
    let device_resp: DeviceAuthResponse = client
        .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/auth/device")
        .form(&[
            ("client_id", "k1s0-cli"),
            ("scope", "openid profile email"),
        ])
        .send()
        .await?
        .json()
        .await?;

    println!("ブラウザで {} にアクセスし、コード {} を入力してください",
        device_resp.verification_uri_complete,
        device_resp.user_code);

    // 2. Token Polling
    loop {
        tokio::time::sleep(Duration::from_secs(device_resp.interval as u64)).await;

        let token_resp = client
            .post("https://auth.k1s0.internal.example.com/realms/k1s0/protocol/openid-connect/token")
            .form(&[
                ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
                ("client_id", "k1s0-cli"),
                ("device_code", &device_resp.device_code),
            ])
            .send()
            .await?;

        match token_resp.status() {
            StatusCode::OK => {
                let tokens: TokenResponse = token_resp.json().await?;
                save_tokens(&tokens)?;
                println!("ログインに成功しました");
                return Ok(());
            }
            _ => {
                let err: ErrorResponse = token_resp.json().await?;
                if err.error != "authorization_pending" {
                    return Err(anyhow!("認証エラー: {}", err.error_description));
                }
            }
        }
    }
}
```

---

## 関連ドキュメント

- [認証認可設計.md](認証認可設計.md) -- 基本方針・技術スタック
- [JWT設計.md](JWT設計.md) -- JWT 公開鍵ローテーション
- [サービス間認証設計.md](サービス間認証設計.md) -- mTLS 設計
- [RBAC設計.md](RBAC設計.md) -- RBAC 設計
- [Vault設計.md](Vault設計.md) -- シークレット管理
- [APIゲートウェイ設計.md](APIゲートウェイ設計.md) -- Kong 認証フロー
- [config設計.md](config設計.md) -- config.yaml スキーマ
