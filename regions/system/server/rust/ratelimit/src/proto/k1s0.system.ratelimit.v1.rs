// This file is @generated by prost-build.
/// CheckRateLimitRequest はレートリミットチェックリクエスト。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRateLimitRequest {
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subject: ::prost::alloc::string::String,
}
/// CheckRateLimitResponse はレートリミットチェックレスポンス。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRateLimitResponse {
    #[prost(bool, tag = "1")]
    pub allowed: bool,
    #[prost(int64, tag = "2")]
    pub remaining: i64,
    #[prost(int64, tag = "3")]
    pub reset_at: i64,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
/// CreateRuleRequest はルール作成リクエスト。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub limit: i64,
    #[prost(int64, tag = "4")]
    pub window_secs: i64,
    #[prost(string, tag = "5")]
    pub algorithm: ::prost::alloc::string::String,
}
/// CreateRuleResponse はルール作成レスポンス。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuleResponse {
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<RateLimitRule>,
}
/// GetRuleRequest はルール取得リクエスト。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleRequest {
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
}
/// GetRuleResponse はルール取得レスポンス。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleResponse {
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<RateLimitRule>,
}
/// RateLimitRule はレートリミットルール。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateLimitRule {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub limit: i64,
    #[prost(int64, tag = "5")]
    pub window_secs: i64,
    #[prost(string, tag = "6")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub enabled: bool,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated server implementations.
pub mod rate_limit_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RateLimitServiceServer.
    #[async_trait]
    pub trait RateLimitService: Send + Sync + 'static {
        async fn check_rate_limit(
            &self,
            request: tonic::Request<super::CheckRateLimitRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckRateLimitResponse>, tonic::Status>;
        async fn create_rule(
            &self,
            request: tonic::Request<super::CreateRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateRuleResponse>, tonic::Status>;
        async fn get_rule(
            &self,
            request: tonic::Request<super::GetRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRuleResponse>, tonic::Status>;
    }
    /// RateLimitService はレートリミットサービス。
    #[derive(Debug)]
    pub struct RateLimitServiceServer<T: RateLimitService> {
        inner: Arc<T>,
    }
    impl<T: RateLimitService> RateLimitServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self {
                inner: Arc::new(inner),
            }
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self { inner }
        }
    }
    impl<T> tonic::codegen::Service<http::Request<tonic::body::BoxBody>>
        for RateLimitServiceServer<T>
    where
        T: RateLimitService,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut std::task::Context<'_>,
        ) -> std::task::Poll<std::result::Result<(), Self::Error>> {
            std::task::Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<tonic::body::BoxBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/k1s0.system.ratelimit.v1.RateLimitService/CheckRateLimit" => {
                    #[allow(non_camel_case_types)]
                    struct CheckRateLimitSvc<T: RateLimitService>(pub Arc<T>);
                    impl<T: RateLimitService>
                        tonic::server::UnaryService<super::CheckRateLimitRequest>
                        for CheckRateLimitSvc<T>
                    {
                        type Response = super::CheckRateLimitResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckRateLimitRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RateLimitService>::check_rate_limit(&*inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckRateLimitSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/k1s0.system.ratelimit.v1.RateLimitService/CreateRule" => {
                    #[allow(non_camel_case_types)]
                    struct CreateRuleSvc<T: RateLimitService>(pub Arc<T>);
                    impl<T: RateLimitService>
                        tonic::server::UnaryService<super::CreateRuleRequest>
                        for CreateRuleSvc<T>
                    {
                        type Response = super::CreateRuleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RateLimitService>::create_rule(&*inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/k1s0.system.ratelimit.v1.RateLimitService/GetRule" => {
                    #[allow(non_camel_case_types)]
                    struct GetRuleSvc<T: RateLimitService>(pub Arc<T>);
                    impl<T: RateLimitService>
                        tonic::server::UnaryService<super::GetRuleRequest>
                        for GetRuleSvc<T>
                    {
                        type Response = super::GetRuleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RateLimitService>::get_rule(&*inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut resp = http::Response::new(
                        http::StatusCode::OK,
                    );
                    resp.headers_mut()
                        .insert("grpc-status", "12".parse().unwrap());
                    resp.headers_mut().insert(
                        "content-type",
                        "application/grpc".parse().unwrap(),
                    );
                    Ok(resp.map(|_| tonic::body::BoxBody::default()))
                }),
            }
        }
    }
    impl<T: RateLimitService> Clone for RateLimitServiceServer<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
    impl<T: RateLimitService> tonic::server::NamedService for RateLimitServiceServer<T> {
        const NAME: &'static str = "k1s0.system.ratelimit.v1.RateLimitService";
    }
}
